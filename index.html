<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>電波人間 家系図ツール</title>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet">
  <style>
    /* --- Base Styles --- */
    body,
    html {
      margin: 0;
      padding: 0;
      font-family: 'Noto Sans JP', sans-serif;
      height: 100%;
      /* overflow: hidden; */
      background-color: #f4f4f4;
      color: #333;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    .top-area {
      display: flex;
      flex-grow: 1;
      overflow: hidden;
      position: relative;
    }

    /* --- Left Panel --- */
    #left-panel-toggle-button {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      z-index: 1010;
      /* background-color は .panel-is-open / .panel-is-closed で制御 */
      color: white;
      border: none;
      padding: 15px 8px;
      cursor: pointer;
      font-size: 1em;
      line-height: 1;
      box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
      transition: left 0.3s ease, background-color 0.3s ease, border-radius 0.3s ease;
      left: 340px;
      background-color: #007bff;
      /* 収納ボタンの色 */
      border-top-left-radius: 5px;
      border-bottom-left-radius: 5px;
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
    }

    #left-panel-toggle-button.panel-is-closed {
      left: 0px !important;
      background-color: #007bff;
      /* 展開ボタンの色 */
      border-top-right-radius: 5px;
      border-bottom-right-radius: 5px;
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
    }

    .left-panel {
      width: 340px;
      min-width: 340px;
      padding: 15px;
      background-color: #fff;
      border-right: 1px solid #ddd;
      overflow-y: auto;
      box-shadow: 2px 0 5px rgba(0, 0, 0, 0.05);
      display: flex;
      flex-direction: column;
      gap: 15px;
      z-index: 1005;
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      transform: translateX(0%);
      transition: transform 0.3s ease;
    }

    .left-panel.collapsed {
      transform: translateX(-100%);
    }

    .left-panel h2,
    .left-panel h3 {
      margin-top: 0;
      margin-bottom: 10px;
      color: #555;
      border-bottom: 1px solid #eee;
      padding-bottom: 5px;
    }

    .left-panel .panel-section small {
      display: block;
      font-size: 0.75em;
      color: #6c757d;
      margin-bottom: 10px;
      line-height: 1.4;
    }


    .left-panel .panel-section {
      background-color: #f9f9f9;
      padding: 12px;
      border-radius: 8px;
      border: 1px solid #eee;
      margin-bottom: 15px;
    }

    .left-panel .image-slot-group {
      border: 1px solid #e0e0e0;
      padding: 10px;
      margin-bottom: 15px;
      border-radius: 6px;
      background-color: #fff;
    }

    .left-panel .image-slot-group h4 {
      margin-top: 0;
      margin-bottom: 8px;
      font-size: 0.95em;
      color: #333;
    }

    .left-panel .file-input-wrapper {
      display: flex;
      flex-direction: column;
      margin-bottom: 5px;
      padding-left: 0;
    }

    .left-panel .file-input-wrapper .file-input-label {
      font-weight: bold;
      font-size: 0.8em;
      margin-bottom: 3px;
      text-align: left;
    }

    .left-panel .file-input-controls {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .left-panel .file-input-controls input[type="file"] {
      flex-grow: 1;
      font-size: 0.7em;
      padding: 4px;
      border: 1px solid #ccc;
      border-radius: 4px;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      max-width: calc(100% - 50px);
      color: #888;
    }

    .left-panel .file-input-controls input[type="file"]::file-selector-button {
      font-size: 0.9em;
      padding: 2px 6px;
      margin-right: 5px;
    }

    .left-panel .file-input-controls input[type="file"]:not(:placeholder-shown) {
      color: #333;
    }

    .left-panel .clear-image-button {
      padding: 4px 8px;
      font-size: 0.7em;
      background-color: #f8f9fa;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
      line-height: 1;
      height: fit-content;
      flex-shrink: 0;
    }

    .left-panel .clear-image-button:hover {
      background-color: #e9ecef;
    }

    .left-panel .clear-image-button.hidden {
      display: none;
    }


    .left-panel img.preview-image {
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #fff;
      display: block;
      margin: 8px auto;
      max-width: calc(100% - 16px);
      max-height: 60px;
      object-fit: contain;
    }

    .left-panel .post-preview-edit-button {
      display: block;
      width: calc(100% - 0px);
      margin: 5px 0 10px 0;
      padding: 5px 10px;
      font-size: 0.8em;
      background-color: #5bc0de;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .left-panel .post-preview-edit-button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    .left-panel .form-group {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      padding-left: 0;
    }

    .left-panel .form-group label {
      flex-basis: 70px;
      flex-shrink: 0;
      font-weight: bold;
      font-size: 0.8em;
      margin-bottom: 0;
      text-align: right;
    }

    .left-panel .form-group input[type="text"],
    .left-panel .form-group select,
    .left-panel .form-group textarea {
      flex-grow: 1;
      padding: 6px 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 0.85em;
      box-sizing: border-box;
      margin-bottom: 0;
      width: auto;
    }


    .left-panel .form-group input[type="color"] {
      padding: 2px;
      height: 30px;
      flex-basis: 50px;
      min-width: 50px;
    }

    .left-panel .form-group input[type="number"] {
      width: 60px;
      flex-grow: 0;
    }


    .left-panel .order-checkbox-group {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-bottom: 8px;
      padding-left: 0;
      font-size: 0.75em;
    }

    .left-panel .order-checkbox-group .order-label {
      font-weight: bold;
      margin-right: 5px;
      flex-basis: auto;
      white-space: nowrap;
      text-align: right;
    }

    .left-panel .order-checkbox-group label {
      font-weight: normal;
      margin-right: 5px;
    }

    .left-panel .order-checkbox-group input[type="checkbox"] {
      margin-right: 1px;
    }

    .left-panel .form-group-checkbox {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      padding-left: 0;
    }

    .left-panel .form-group-checkbox label {
      flex-basis: auto;
      flex-shrink: 1;
      text-align: left;
      font-weight: normal;
      font-size: 0.85em;
    }

    #add-unit-border-visible-group label,
    #add-text-border-visible-group label,
    #image-collection-border-group label {
      flex-basis: 70px;
      flex-shrink: 0;
      font-weight: bold;
      font-size: 0.8em;
      text-align: right;
    }


    .left-panel .form-group-checkbox input[type="checkbox"] {
      margin-right: 1px;
    }


    .left-panel button.action-button {
      display: block;
      width: 100%;
      padding: 12px 15px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1em;
      transition: background-color 0.2s;
      margin-top: 15px;
    }

    .left-panel button.action-button:hover:not(:disabled) {
      background-color: #0056b3;
    }

    .left-panel button.action-button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    #image-collection-previews {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 10px;
      max-height: 150px;
      overflow-y: auto;
      border: 1px dashed #eee;
      padding: 5px;
      background-color: #f0f0f0;
    }

    #image-collection-previews img {
      width: 40px;
      height: 40px;
      object-fit: contain;
      border: 1px solid #ddd;
      background-color: white;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.2s;
    }

    #image-collection-previews img.selected-preview {
      opacity: 1.0;
      border-color: #007bff;
      box-shadow: 0 0 3px rgba(0, 123, 255, 0.5);
    }

    #image-collection-details {
      margin-top: 15px;
      border-top: 1px solid #eee;
      padding-top: 15px;
      max-height: 200px;
      overflow-y: auto;
    }

    #image-collection-details .detail-item {
      border: 1px dashed #ccc;
      padding: 8px;
      margin-bottom: 10px;
      border-radius: 4px;
      background-color: #fff;
    }

    #image-collection-details .detail-item p {
      font-size: 0.8em;
      margin: 0 0 5px 0;
      word-break: break-all;
      color: #555;
    }

    #image-collection-details .detail-item .form-group label {
      flex-basis: 50px;
    }

    #image-collection-details .detail-item .form-group input[type="text"] {
      font-size: 0.8em;
      padding: 4px 5px;
    }

    #image-collection-details .detail-item .form-group select {
      font-size: 0.8em;
      padding: 4px 5px;
    }


    /* --- Status Bar --- */
    #status-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      color: white;
      padding: 8px 15px;
      font-size: 0.9em;
      text-align: center;
      z-index: 1000;
      display: none;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      transition: background-color 0.3s ease;
    }

    /* --- Main Canvas Area --- */
    .main-canvas-area {
      flex-grow: 1;
      position: relative;
      overflow: auto;
      background-color: #e0e0e0;
    }

    #family-tree-canvas {
      display: block;
      background-color: #fdfdfd;
      cursor: grab;
    }

    #family-tree-canvas.dragging,
    #family-tree-canvas.connecting,
    #family-tree-canvas.grouping {
      cursor: grabbing;
    }

    #family-tree-canvas.mode-active {
      cursor: crosshair;
    }

    #family-tree-canvas.edit-mode {
      cursor: pointer;
    }

    /* --- Bottom Controls --- */
    .bottom-controls {
      padding: 8px 10px;
      background-color: #fff;
      border-top: 1px solid #ddd;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.05);
      flex-wrap: wrap;
      flex-shrink: 0;
    }

    .bottom-controls button {
      padding: 8px 10px;
      background-color: #555;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.85em;
      min-width: 70px;
      transition: background-color 0.2s;
    }

    .bottom-controls button:hover:not(:disabled) {
      filter: brightness(1.2);
    }

    .bottom-controls button:disabled {
      filter: grayscale(50%);
      cursor: not-allowed;
      opacity: 0.7;
    }


    .bottom-controls button.active-mode-button {
      background-color: #dc3545 !important;
      color: white;
    }

    .bottom-controls button.active-mode-button:disabled {
      background-color: #f5c6cb !important;
      color: #721c24;
      filter: none;
      opacity: 0.8;
    }


    .bottom-controls button#undo-button,
    .bottom-controls button#redo-button {
      background-color: #ffc107;
      color: #333;
    }

    .bottom-controls button#undo-button:disabled,
    .bottom-controls button#redo-button:disabled {
      background-color: #ffeeba;
      color: #856404;
    }

    .bottom-controls button#connect-button {
      background-color: #17a2b8;
    }

    .bottom-controls button#edit-unit-button {
      background-color: #fd7e14;
    }

    .bottom-controls button#group-button {
      background-color: #6f42c1;
    }

    .bottom-controls button#unify-size-button {
      background-color: #20c997;
    }

    .bottom-controls button#save-canvas-button {
      background-color: #28a745;
    }

    .bottom-controls button#zoom-in-button,
    .bottom-controls button#zoom-out-button {
      background-color: #6c757d;
    }

    #zoom-level-indicator {
      display: inline-block;
      min-width: 30px;
      padding: 0 5px;
      font-size: 0.9em;
      font-weight: bold;
      text-align: center;
      color: #555;
      border: 1px solid #ccc;
      border-radius: 4px;
      margin: 0 5px;
      line-height: 1.5;
    }

    /* --- Info Button --- */
    #info-button-container {
      position: fixed;
      top: 10px;
      right: 15px;
      z-index: 1001;
      transition: top 0.3s ease;
    }

    #info-button-container button {
      padding: 8px 12px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    /* --- Modal Styles --- */
    .modal-overlay {
      display: none;
      position: fixed;
      z-index: 1040;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
    }

    .modal {
      display: none;
      position: fixed;
      z-index: 1050;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background-color: #fff;
      padding: 20px;
      border: 1px solid #888;
      width: 80%;
      max-width: 500px;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      max-height: 90vh;
      overflow-y: auto;
    }

    #unit-edit-modal {
      z-index: 1050;
    }

    #cropper-modal {
      z-index: 1060;
    }

    #text-edit-modal {
      z-index: 1050;
    }


    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
      margin-bottom: 15px;
    }

    .modal-header h2 {
      margin: 0;
      font-size: 1.2em;
    }

    .modal-close-button {
      color: #aaa;
      font-size: 28px;
      font-weight: bold;
      background: none;
      border: none;
      cursor: pointer;
    }

    .modal-close-button:hover,
    .modal-close-button:focus {
      color: black;
    }

    .modal-body {
      padding-bottom: 15px;
    }

    .modal-footer {
      border-top: 1px solid #eee;
      padding-top: 15px;
      text-align: right;
    }

    .modal-footer button {
      padding: 8px 15px;
      margin-left: 10px;
      border-radius: 4px;
      cursor: pointer;
    }

    .modal-footer button.primary {
      background-color: #007bff;
      color: white;
      border: none;
    }

    .modal-footer button.secondary {
      background-color: #6c757d;
      color: white;
      border: none;
    }

    .modal-footer button.danger {
      background-color: #dc3545;
      color: white;
      border: none;
    }

    .modal-footer button.duplicate {
      background-color: #17a2b8;
      color: white;
      border: none;
    }

    .modal-footer button.duplicate:hover {
      background-color: #117a8b;
    }

    /* --- Cropper Modal Specific --- */
    #cropper-modal-content img {
      max-width: 100%;
      display: block;
    }

    #cropper-modal-controls {
      margin-top: 15px;
      text-align: center;
    }

    #cropper-modal-controls button,
    #cropper-modal-controls select {
      margin: 0 5px;
      padding: 8px 12px;
    }

    #cropper-zoom-controls {
      margin-top: 10px;
      text-align: center;
    }

    #cropper-zoom-controls button {
      font-size: 0.8em;
      padding: 5px 8px;
      margin: 2px;
    }

    /* --- Edit Modals Specific --- */
    #unit-edit-modal .form-group,
    #group-edit-modal .form-group,
    #text-edit-modal .form-group {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }

    #unit-edit-modal .form-group label,
    #group-edit-modal .form-group label,
    #text-edit-modal .form-group label {
      width: 100px;
      margin-right: 10px;
      text-align: right;
      font-size: 0.9em;
      flex-shrink: 0;
    }

    #unit-edit-modal .form-group input,
    #unit-edit-modal .form-group select,
    #group-edit-modal .form-group input,
    #text-edit-modal .form-group input,
    #text-edit-modal .form-group select,
    #text-edit-modal .form-group textarea {
      flex-grow: 1;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    #text-edit-modal .form-group input[type="color"] {
      padding: 2px;
      height: 30px;
      flex-basis: 50px;
      min-width: 50px;
    }

    #text-edit-modal .form-group input[type="number"] {
      width: 70px;
      flex-grow: 0;
    }


    #unit-edit-modal .slot-edit-section {
      border: 1px dashed #ccc;
      padding: 10px;
      margin-bottom: 10px;
      border-radius: 4px;
    }

    #unit-edit-modal .slot-edit-section h5 {
      margin-top: 0;
    }

    #unit-edit-modal .slot-edit-section img {
      max-width: 100px;
      max-height: 50px;
      display: block;
      margin-bottom: 5px;
    }

    #unit-edit-modal .slot-edit-section button {
      font-size: 0.8em;
      padding: 4px 8px;
      margin-top: 5px;
    }

    #unit-edit-modal .order-checkbox-group {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-bottom: 8px;
      padding-left: 0;
      font-size: 0.75em;
    }

    #unit-edit-modal .order-checkbox-group .order-label {
      font-weight: bold;
      margin-right: 5px;
      flex-basis: auto;
      white-space: nowrap;
      text-align: right;
    }

    #unit-edit-modal .order-checkbox-group label:not(.order-label) {
      font-weight: normal;
      margin-right: 5px;
    }

    #unit-edit-modal .order-checkbox-group input[type="checkbox"] {
      margin-right: 1px;
    }

    .form-group-checkbox {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }

    .form-group-checkbox label {
      width: 100px;
      margin-right: 10px;
      text-align: right;
      font-size: 0.9em;
      flex-shrink: 0;
    }

    .form-group-checkbox input[type="checkbox"] {
      margin-right: 5px;
    }


    /* --- Info Modal Specific --- */
    #info-modal .crop-list-item {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }

    .crop-color-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
      display: inline-block;
    }

    /* --- Responsive --- */
    @media (max-width: 768px) {
      .bottom-controls {
        height: auto;
        padding: 10px;
        justify-content: space-around;
      }

      .bottom-controls button {
        font-size: 0.8em;
        min-width: 60px;
        padding: 6px 8px;
        margin-bottom: 5px;
      }

      .bottom-controls button:disabled {
        filter: grayscale(50%);
        cursor: not-allowed;
        opacity: 0.7;
      }

      .bottom-controls button.active-mode-button:disabled {
        background-color: #f5c6cb !important;
        color: #721c24;
        filter: none;
        opacity: 0.8;
      }

      .bottom-controls button#undo-button:disabled,
      .bottom-controls button#redo-button:disabled {
        background-color: #ffeeba;
        color: #856404;
      }


      #info-button-container {
        top: 5px;
        right: 10px;
      }

      #info-button-container button {
        padding: 6px 10px;
        font-size: 0.9em;
      }

      .modal {
        width: 90%;
        max-width: 90%;
      }
    }

    .accordion-section {
      border: 1px solid #eee;
      border-radius: 4px;
      margin-bottom: 15px;
      background-color: #fdfdfd;
    }

    .accordion-header {
      padding: 10px;
      cursor: pointer;
      font-weight: bold;
      background-color: #f7f7f7;
      border-bottom: 1px solid #eee;
      list-style: none;
      /* summaryのデフォルトマーカーを消す */
    }

    .accordion-header::-webkit-details-marker {
      display: none;
    }

    /* Chrome/Safariのマーカーを消す */
    .accordion-header::before {
      /* 簡単な開閉アイコン */
      content: '▶ ';
      font-size: 0.8em;
      margin-right: 5px;
      display: inline-block;
      transition: transform 0.2s ease-in-out;
    }

    details[open]>summary.accordion-header::before {
      transform: rotate(90deg);
    }

    .accordion-content {
      padding: 15px;
      border-top: 1px solid #eee;
      /* ヘッダーとの境界線 */
    }

    .accordion-content .form-group {
      margin-bottom: 12px;
      /* 設定項目間のスペース */
    }

    .accordion-content .form-group label {
      width: 100px;
      /* ラベル幅を少し広げる */
    }

    .accordion-content small {
      margin-left: 8px;
      font-size: 0.8em;
      color: #777;
    }

    /* 画像集合ユニット編集モーダルのリストスタイル */
    #collection-edit-image-list li {
      display: flex;
      align-items: center;
      border: 1px solid #eee;
      padding: 8px;
      margin-bottom: 8px;
      border-radius: 4px;
      background-color: #f9f9f9;
      cursor: grab;
      /* ドラッグ可能を示すカーソル */
    }

    #collection-edit-image-list li.dragging {
      /* ドラッグ中のスタイル */
      opacity: 0.5;
      background-color: #e0e0e0;
    }

    /* 削除マーク用スタイル (オプション) */
    #collection-edit-image-list li[data-deleted="true"] {
      opacity: 0.5;
      text-decoration: line-through;
      background-color: #ffe0e0;
    }


    #collection-edit-image-list img {
      width: 40px;
      height: 40px;
      object-fit: contain;
      border: 1px solid #ddd;
      margin-right: 10px;
      background-color: white;
    }

    #collection-edit-image-list .image-details {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      gap: 5px;
      /* 詳細項目間のギャップ */
    }

    #collection-edit-image-list .image-details p {
      margin: 0;
      font-size: 0.75em;
      color: #666;
      word-break: break-all;
      /* ファイル名が長い場合 */
    }

    #collection-edit-image-list .detail-form-group {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    #collection-edit-image-list .detail-form-group label {
      font-size: 0.8em;
      width: 40px;
      /* ラベル幅を調整 */
      text-align: right;
      flex-shrink: 0;
    }

    #collection-edit-image-list .detail-form-group input[type="text"],
    #collection-edit-image-list .detail-form-group select {
      font-size: 0.8em;
      padding: 3px 4px;
      border: 1px solid #ccc;
      border-radius: 3px;
      flex-grow: 1;
    }

    #collection-edit-image-list .delete-image-btn {
      background: none;
      border: none;
      color: #dc3545;
      font-size: 1.2em;
      cursor: pointer;
      padding: 5px;
      margin-left: 10px;
    }

    #collection-edit-image-list .delete-image-btn:hover {
      color: #a71d2a;
    }

    .checkbox-row-container {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .checkbox-item-container {
      display: flex;
      align-items: center;
      margin-right: 20px;
    }

    .checkbox-item-container:last-child {
      margin-right: 0;
    }

    .checkbox-item-container input[type="checkbox"] {
      margin-right: 4px;
    }

    .checkbox-item-container label {
      font-weight: normal;
      white-space: nowrap;
    }

    .capture-phase {
      border: 1px solid #e0e0e0;
      border-radius: 5px;
      margin-bottom: 12px;
      padding: 12px;
      background-color: #f9f9f9;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }

    .capture-phase h5 {
      margin-top: 0;
      margin-bottom: 10px;
      color: #2c3e50;
      border-bottom: 1px solid #ecf0f1;
      padding-bottom: 6px;
      font-size: 1.05em;
    }

    .capture-phase ul {
      list-style-type: none;
      padding-left: 0;
      margin-bottom: 0;
    }

    .capture-phase li {
      padding: 10px 5px;
      border-bottom: 1px dashed #ecf0f1;
      display: flex;
      /* flexboxで画像とテキストを横並び */
      align-items: center;
      /* 上下中央揃え */
    }

    .capture-phase li:last-child {
      border-bottom: none;
    }

    .capture-phase li img {
      /* renderCaptureList内のスタイル指定をこちらに集約しても良い */
      flex-shrink: 0;
      /* 画像が縮まないように */
    }

    .capture-phase li div {
      /* テキストコンテンツを囲むdivを追加する場合 */
      margin-left: 10px;
    }

    .capture-phase li strong {
      font-size: 0.95em;
    }

    .capture-phase li small {
      font-size: 0.8em;
      display: block;
      margin-top: 2px;
    }

    .drawing-undo-redo-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      margin-bottom: 5px;
    }

    .drawing-undo-redo-controls button {
      flex-grow: 1;
      font-size: 0.85em;
      padding: 6px 10px;
      background-color: #6c757d;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .drawing-undo-redo-controls button:hover:not(:disabled) {
      filter: brightness(1.15);
    }

    .drawing-undo-redo-controls button:disabled {
      background-color: #adb5bd;
      cursor: not-allowed;
      opacity: 0.7;
    }
  </style>
</head>

<body>
  <div id="status-bar">ステータスメッセージがここに表示されます</div>
  <div class="modal-overlay" id="modal-overlay"></div>

  <div class="container">
    <div class="top-area">
      <button id="left-panel-toggle-button" title="左パネルを開閉">＜</button>
      <div class="left-panel" id="left-panel">
        <div class="panel-section upload-main-section">
          <h2>ユニット追加</h2>
        </div>


        <div class="image-slot-group">
          <h4>出生スロット</h4>
          <div class="file-input-wrapper">
            <label class="file-input-label" for="birth-image-upload">画像を選択:</label>
            <div class="file-input-controls">
              <input type="file" id="birth-image-upload" accept="image/*">
              <button class="clear-image-button hidden" id="clear-birth-image-button" title="画像をクリア">×</button>
            </div>
          </div>
          <img id="birth-image-preview" src="#" alt="出生画像プレビュー" class="preview-image" style="display:none;">
          <button class="post-preview-edit-button" id="edit-birth-image-button" disabled>この画像を編集</button>
          <div class="form-group">
            <label for="birth-name">名前:</label>
            <input type="text" id="birth-name" maxlength="10" placeholder="名前を入力(任意)">
          </div>
          <div class="form-group">
            <label for="birth-favorite-food">好物:</label>
            <select id="birth-favorite-food">
              <option value="未選択">選択してください(任意)</option>
              <option value="いちご">いちご</option>
              <option value="にがうり">にがうり</option>
              <option value="とうがらし">とうがらし</option>
              <option value="バナナ">バナナ</option>
              <option value="レモン">レモン</option>
              <option value="ぶどう">ぶどう</option>
              <option value="かき">かき</option>
            </select>
          </div>
        </div>

        <div class="image-slot-group">
          <h4>QR1スロット</h4>
          <div class="file-input-wrapper">
            <label class="file-input-label" for="qr1-image-upload">画像を選択:</label>
            <div class="file-input-controls">
              <input type="file" id="qr1-image-upload" accept="image/*">
              <button class="clear-image-button hidden" id="clear-qr1-image-button" title="画像をクリア">×</button>
            </div>
          </div>
          <img id="qr1-image-preview" src="#" alt="QR1画像プレビュー" class="preview-image" style="display:none;">
          <button class="post-preview-edit-button" id="edit-qr1-image-button" disabled>この画像を編集</button>
          <div class="order-checkbox-group">
            <label class="order-label">入居順(任意):</label>
            <input type="checkbox" id="qr1-order-saki" name="qr1-order" value="先"> <label for="qr1-order-saki">先</label>
            <input type="checkbox" id="qr1-order-ato" name="qr1-order" value="後"> <label for="qr1-order-ato">後</label>
          </div>
          <div class="form-group">
            <label for="qr1-name">名前:</label>
            <input type="text" id="qr1-name" maxlength="10" placeholder="名前を入力(任意)">
          </div>
          <div class="form-group">
            <label for="qr1-favorite-food">好物:</label>
            <select id="qr1-favorite-food">
              <option value="未選択">選択してください(任意)</option>
              <option value="いちご">いちご</option>
              <option value="にがうり">にがうり</option>
              <option value="とうがらし">とうがらし</option>
              <option value="バナナ">バナナ</option>
              <option value="レモン">レモン</option>
              <option value="ぶどう">ぶどう</option>
              <option value="かき">かき</option>
            </select>
          </div>
        </div>

        <div class="image-slot-group">
          <h4>QR2スロット</h4>
          <div class="file-input-wrapper">
            <label class="file-input-label" for="qr2-image-upload">画像を選択:</label>
            <div class="file-input-controls">
              <input type="file" id="qr2-image-upload" accept="image/*">
              <button class="clear-image-button hidden" id="clear-qr2-image-button" title="画像をクリア">×</button>
            </div>
          </div>
          <img id="qr2-image-preview" src="#" alt="QR2画像プレビュー" class="preview-image" style="display:none;">
          <button class="post-preview-edit-button" id="edit-qr2-image-button" disabled>この画像を編集</button>
          <div class="order-checkbox-group">
            <label class="order-label">入居順(任意):</label>
            <input type="checkbox" id="qr2-order-saki" name="qr2-order" value="先"> <label for="qr2-order-saki">先</label>
            <input type="checkbox" id="qr2-order-ato" name="qr2-order" value="後"> <label for="qr2-order-ato">後</label>
          </div>
          <div class="form-group">
            <label for="qr2-name">名前:</label>
            <input type="text" id="qr2-name" maxlength="10" placeholder="名前を入力(任意)">
          </div>
          <div class="form-group">
            <label for="qr2-favorite-food">好物:</label>
            <select id="qr2-favorite-food">
              <option value="未選択">選択してください(任意)</option>
              <option value="いちご">いちご</option>
              <option value="にがうり">にがうり</option>
              <option value="とうがらし">とうがらし</option>
              <option value="バナナ">バナナ</option>
              <option value="レモン">レモン</option>
              <option value="ぶどう">ぶどう</option>
              <option value="かき">かき</option>
            </select>
          </div>
        </div>

        <div class="form-group-checkbox" id="add-unit-border-visible-group">
          <label for="add-unit-border-visible">枠を表示:</label>
          <input type="checkbox" id="add-unit-border-visible" checked>
        </div>
        <button id="add-unit-button" class="action-button" disabled>ユニットをキャンバスに追加</button>

        <div class="panel-section image-collection-section">
          <h3>画像集合ユニット追加</h3>
          <div class="file-input-wrapper">
            <label class="file-input-label" for="image-collection-upload">画像を一括選択 (最大20枚):</label>
            <div class="file-input-controls">
              <input type="file" id="image-collection-upload" accept="image/*" multiple>
              <button class="clear-image-button hidden" id="clear-image-collection-button" title="選択画像をクリア">×</button>
            </div>
          </div>
          <div id="image-collection-previews"></div>
          <div id="image-collection-details" style="max-height: 200px; overflow-y: auto;"></div>
          <div class="form-group-checkbox" id="image-collection-border-group">
            <label for="image-collection-border-visible">枠を表示:</label>
            <input type="checkbox" id="image-collection-border-visible" checked>
          </div>
          <button id="add-image-collection-button" class="action-button" disabled>画像集合ユニットを追加</button>
        </div>


        <div class="panel-section text-add-section">
          <h3>テキスト追加</h3>
          <p>
            <small>※文章が長い・文字サイズを大きく設定した場合は改行することをおすすめします。また場合によっては家系図上での表示がおかしくなってしまう場合がありますが、追加後に枠のサイズを変更していただければ解決する可能性があります。</small>
          </p>
          <div class="form-group">
            <label for="add-text-content">内容:</label>
            <textarea id="add-text-content" rows="3" placeholder="表示したいテキスト"></textarea>
          </div>
          <div class="form-group">
            <label for="add-text-color">文字色:</label>
            <input type="color" id="add-text-color" value="#000000">
          </div>
          <div class="form-group">
            <label for="add-text-bgcolor">背景色:</label>
            <input type="color" id="add-text-bgcolor" value="#ffffff">
          </div>
          <div class="form-group">
            <label for="add-text-size">サイズ:</label>
            <input type="number" id="add-text-size" value="20" min="8">
          </div>
          <div class="form-group-checkbox" id="add-text-border-visible-group">
            <label for="add-text-border-visible">枠を表示:</label>
            <input type="checkbox" id="add-text-border-visible" checked>
          </div>
          <button id="add-text-item-button" class="action-button" disabled>テキストをキャンバスに追加</button>
        </div>
        <div class="panel-section drawing-tools-section" id="drawing-tools-panel" style="display: none;">
          <h3>手書きツール</h3>
          <div class="form-group">
            <label for="drawing-color-picker">色:</label> <!-- id変更: drawing-color -> drawing-color-picker -->
            <input type="color" id="drawing-color-picker" value="#000000">
          </div>
          <div class="form-group">
            <label for="drawing-line-width-slider">太さ:</label>
            <!-- id変更: drawing-line-width -> drawing-line-width-slider -->
            <input type="range" id="drawing-line-width-slider" min="1" max="20" value="3">
            <span id="drawing-line-width-value">3</span>px
          </div>
          <div class="form-group">
            <label for="drawing-shape-select">ツール:</label> <!-- id変更: drawing-shape -> drawing-shape-select -->
            <select id="drawing-shape-select">
              <option value="line" selected>線</option>
              <option value="rectangle">四角</option>
              <option value="circle">円</option>
              <option value="arrow">矢印</option>
              <option value="eraser">消しゴム</option>
            </select>
          </div>
          <div class="form-group" id="drawing-fill-group" style="display:none;">
            <label for="drawing-fill-checkbox">塗りつぶし:</label>
            <input type="checkbox" id="drawing-fill-checkbox">
          </div>
          <div class="drawing-undo-redo-controls">
            <button id="drawing-undo-button" title="描画を元に戻す" disabled>描画戻す</button>
            <button id="drawing-redo-button" title="描画をやり直す" disabled>描画進む</button>
          </div>
          <button id="clear-all-drawings-button" class="action-button"
            style="margin-top: 5px; background-color: #dc3545;">全描画消去</button>
        </div>
      </div>

      <div class="main-canvas-area" id="main-canvas-area">
        <canvas id="family-tree-canvas"></canvas>
      </div>
    </div>

    <div class="bottom-controls">
      <button id="undo-button" title="元に戻す">戻す</button>
      <button id="redo-button" title="やり直す">進む</button>
      <button id="connect-button" title="ユニット間を接続">接続</button>
      <button id="edit-unit-button" title="ユニット/グループ/テキストを編集">編集</button>
      <button id="group-button" title="選択した2つをまとめる">まとめる</button>
      <button id="unify-size-button" title="サイズを合わせる (未実装)">サイズ統一</button>
      <button id="unify-size-complete-selection-btn" title="選択したユニットにサイズ統一を適用"
        style="display: none; background-color: #28a745;">選択完了</button>
      <button id="draw-mode-button" title="手書き描画モード">描画</button>
      <button id="save-canvas-button" title="家系図を画像で保存">保存</button>
      <button id="zoom-out-button" title="縮小">-</button>
      <span id="zoom-level-indicator">0</span> <button id="zoom-in-button" title="拡大">+</button>
      <button id="clear-storage-button" title="保存データを削除して新規作成"
        style="background-color: #ffc107; color: #333;">データクリア</button>
      <button id="export-data-button" title="家系図データをJSONファイルでエクスポート" style="background-color: #007bff;">エクスポート</button>
      <button id="import-data-button" title="JSONファイルから家系図データをインポート" style="background-color: #28a745;">インポート</button>
      <input type="file" id="import-file-input" accept=".json" style="display: none;">
    </div>
  </div>

  <div id="info-button-container">
    <button id="show-info-modal-button">家系図情報</button>
  </div>

  <div id="cropper-modal" class="modal">
    <div class="modal-header">
      <h2>画像の編集</h2>
      <button class="modal-close-button" id="cropper-modal-close-button-header">&times;</button>
    </div>
    <div class="modal-body">
      <div>
        <img id="image-to-crop" src="" alt="切り抜き対象" style="max-height: 50vh;">
      </div>
      <div id="cropper-zoom-controls">
        <label>ズーム:</label>
        <button data-zoom="0.01">1%</button>
        <button data-zoom="0.1">10%</button>
        <button data-zoom="0.25">25%</button>
        <button data-zoom="0.5">50%</button>
        <button data-zoom="1">100%</button>
        <button data-zoom-in>+</button>
        <button data-zoom-out>-</button>
      </div>
      <div id="cropper-modal-controls">
        <label for="aspect-ratio-select">アスペクト比:</label>
        <select id="aspect-ratio-select">
          <option value="NaN">自由</option>
          <option value="1">正方形 (1:1)</option>
        </select>
      </div>
    </div>
    <div class="modal-footer">
      <button id="cancel-crop-button" class="secondary">キャンセル</button>
      <button id="crop-image-button" class="primary">適用</button>
    </div>
  </div>

  <div id="unit-edit-modal" class="modal">
    <div class="modal-header">
      <h2 id="unit-edit-modal-title">ユニット編集</h2>
      <button class="modal-close-button" id="unit-edit-modal-close-button">&times;</button>
    </div>
    <div class="modal-body" id="unit-edit-modal-body">
    </div>
    <div class="modal-footer">
      <button id="unit-edit-delete-button" class="danger">ユニット削除</button>
      <button id="unit-edit-duplicate-button" class="duplicate">ユニット複製</button>
      <button id="unit-edit-cancel-button" class="secondary">キャンセル</button>
      <button id="unit-edit-apply-button" class="primary">適用</button>
    </div>
  </div>

  <div id="group-edit-modal" class="modal">
    <div class="modal-header">
      <h2 id="group-edit-modal-title">グループ編集</h2>
      <button class="modal-close-button" id="group-edit-modal-close-button">&times;</button>
    </div>
    <div class="modal-body" id="group-edit-modal-body">
      <div class="form-group">
        <label for="group-edit-name">グループ名:</label>
        <input type="text" id="group-edit-name" placeholder="グループ名 (任意)">
      </div>
      <div class="form-group-checkbox">
        <label for="group-edit-border-visible">枠を表示:</label>
        <input type="checkbox" id="group-edit-border-visible">
      </div>
      <p><small>グループ内のユニットの編集は、一度グループ化を解除するか、各ユニットを個別に編集モードで選択してください。</small></p>
    </div>
    <div class="modal-footer">
      <button id="group-edit-delete-button" class="danger">グループ削除</button>
      <button id="group-edit-ungroup-button" class="secondary">グループ化解除</button>
      <button id="group-edit-duplicate-button" class="duplicate">グループ複製</button>
      <button id="group-edit-cancel-button" class="secondary">キャンセル</button>
      <button id="group-edit-apply-button" class="primary">適用</button>
    </div>
  </div>

  <div id="text-edit-modal" class="modal">
    <div class="modal-header">
      <h2 id="text-edit-modal-title">テキスト編集</h2>
      <button class="modal-close-button" id="text-edit-modal-close-button">&times;</button>
    </div>
    <div class="modal-body" id="text-edit-modal-body">
    </div>
    <div class="modal-footer">
      <button id="text-edit-delete-button" class="danger">テキスト削除</button>
      <button id="text-edit-duplicate-button" class="duplicate">テキスト複製</button>
      <button id="text-edit-cancel-button" class="secondary">キャンセル</button>
      <button id="text-edit-apply-button" class="primary">適用</button>
    </div>
  </div>


  <div id="info-modal" class="modal" style="max-width: 650px;">
    <div class="modal-header">
      <h2>家系図情報</h2>
      <button class="modal-close-button" id="info-modal-close-button-header">&times;</button>
    </div>
    <div class="modal-body">
      <p>
        <small>※必要ゴールド及び作物は、スタミナ1で20までレベルを上げてふれあいで幸せを8にした後に好物を7個使い上限突破可能になるまでしあわせを上げることを想定しています。好物が未設定の場合はその分が反映されません。またこちらの設定ミスでおかしな数値になっている可能性があるのであまりアテにしないでください。</small>
      </p>
      <h3>必要作物</h3>
      <ul id="required-crops-list" style="list-style-type: none; padding-left: 0;">
      </ul>
      <h3>必要ゴールド</h3>
      <p id="total-gold-cost">0 G</p>
      <p><small id="gold-details">上限突破0回 0G、出生0回 0G、作物の種0個 0G</small></p>
      <h3>推奨捕獲順</h3>
      <div id="recommended-capture-order-content">
        <p>この機能は目標個体が設定されている場合のみ使用可能です。<br>(ユニット編集から「最終目標にする」にチェックを入れてください)</p>
      </div>
    </div>
    <div class="modal-footer">
      <button id="info-modal-close-button-footer" class="secondary">閉じる</button>
    </div>

  </div>

  <div id="image-collection-edit-modal" class="modal" style="max-width: 600px;">
    <div class="modal-header">
      <h2 id="collection-edit-modal-title">画像集合ユニット編集</h2>
      <button class="modal-close-button" id="collection-edit-modal-close-button">×</button>
    </div>
    <div class="modal-body" id="collection-edit-modal-body">
      <div class="form-group">
        <label for="collection-edit-name">ユニット名:</label>
        <input type="text" id="collection-edit-name" placeholder="ユニット名 (任意)">
      </div>
      <div class="form-group-checkbox">
        <label for="collection-edit-border-visible">枠を表示:</label>
        <input type="checkbox" id="collection-edit-border-visible">
      </div>
      <hr>

      <details class="accordion-section" id="collection-layout-settings">
        <summary class="accordion-header">ユニット内の配置設定</summary>
        <div class="accordion-content">
          <div class="form-group">
            <label for="collection-edit-max-size">画像サイズ:</label>
            <input type="number" id="collection-edit-max-size" min="10" step="1">
            <small> (基本: 50)</small>
          </div>
          <div class="form-group">
            <label for="collection-edit-margin">基本マージン:</label>
            <input type="number" id="collection-edit-margin" min="0" step="1">
            <small> (基本: 5)</small>
          </div>
          <div class="form-group">
            <label for="collection-edit-padding">パディング:</label>
            <input type="number" id="collection-edit-padding" min="0" step="1">
            <small> (基本: 10)</small>
          </div>
          <div class="form-group">
            <label for="collection-edit-text-gap">テキスト間隔:</label>
            <input type="number" id="collection-edit-text-gap" min="0" step="1">
            <small> (基本: 8)</small>
          </div>
          <div class="form-group">
            <label for="collection-edit-per-row">1行の画像数:</label>
            <input type="number" id="collection-edit-per-row" min="1" step="1">
            <small> (基本: 3)</small>
          </div>
          <div class="form-group">
            <label for="collection-edit-font-size">文字サイズ:</label>
            <input type="number" id="collection-edit-font-size" min="6" step="1">
            <small> (基本: 10)</small>
          </div>
          <button id="reset-layout-settings-button" type="button"
            style="font-size: 0.8em; padding: 3px 6px; margin-left: 110px;">基本設定に戻す</button>
        </div>
      </details>
      <hr>


      <h4>内部の画像 (<span id="collection-edit-image-count">0</span>枚)</h4>
      <p><small>ドラッグ＆ドロップで並び替え、各項目を編集、削除ボタン(<span
            style="color:#dc3545; font-weight:bold;">×</span>)で削除リストに追加できます。</small>
      </p>
      <ul id="collection-edit-image-list" style="list-style: none; padding: 0; max-height: 40vh; overflow-y: auto;">
      </ul>
    </div>
    <div class="modal-footer">
      <button id="collection-edit-delete-button" class="danger">ユニット削除</button>
      <button id="collection-edit-cancel-button" class="secondary">キャンセル</button>
      <button id="collection-edit-apply-button" class="primary">適用</button>
    </div>
  </div>
  <div id="unify-size-options-modal" class="modal" style="max-width: 400px; display: none;">
    <div class="modal-header">
      <h2>サイズ統一の範囲を選択</h2>
    </div>
    <div class="modal-body">
      <p>基準ユニット: <strong id="unify-base-unit-name">未選択</strong> (<span id="unify-base-unit-size">0x0</span>)</p>
      <hr>
      <button id="unify-all-units-btn" class="action-button"
        style="margin-bottom: 10px; width: 100%;">家系図上の全ユニット</button>
      <button id="unify-visible-units-btn" class="action-button"
        style="margin-bottom: 10px; width: 100%;">画面内のユニットのみ</button>
      <button id="unify-select-targets-btn" class="action-button" style="width: 100%;">適用するユニットを選択する</button>
    </div>
    <div class="modal-footer">
      <button id="unify-size-options-modal-cancel-btn" class="secondary">キャンセル</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {


      // ========================================
      // 1. 定数宣言 (const)
      // ========================================
      const BASE_SCALE_FACTOR = 1.2;
      const DEFAULT_FONT = "'Noto Sans JP', sans-serif";
      const SLOT_WIDTH_BASE = 110;
      const SLOT_IMAGE_HEIGHT_BASE = 60 * BASE_SCALE_FACTOR;
      const SLOT_QR_IMAGE_SIZE_BASE = SLOT_IMAGE_HEIGHT_BASE;
      const SLOT_TEXT_LINE_HEIGHT_BASE = 16 * BASE_SCALE_FACTOR;
      const SLOT_PADDING_BASE = 8 * BASE_SCALE_FACTOR;
      const UNIT_INTERNAL_PADDING_BASE = 5 * BASE_SCALE_FACTOR;
      const IMAGE_TEXT_PADDING = SLOT_PADDING_BASE;
      const TEXT_LINE_HEIGHT_MULTIPLIER = 1.2;
      const RESIZE_HANDLE_SIZE = 10;
      const MIN_SLOT_WIDTH_FOR_DRAWING = 30;
      const BORDER_RESIZE_THRESHOLD = 8;
      const UNIT_WIDTH_ONE_SLOT = SLOT_WIDTH_BASE + (SLOT_PADDING_BASE * 2);
      const UNIT_WIDTH_TWO_SLOTS = (SLOT_WIDTH_BASE * 2) + UNIT_INTERNAL_PADDING_BASE + (SLOT_PADDING_BASE * 2);
      const UNIT_WIDTH_THREE_SLOTS = (SLOT_WIDTH_BASE * 3) + (UNIT_INTERNAL_PADDING_BASE * 2) + (SLOT_PADDING_BASE * 2);
      const GROUP_PADDING = 20;
      const TEXT_ITEM_PADDING = 5;
      const MIN_TEXT_ITEM_WIDTH = 30 + (TEXT_ITEM_PADDING * 2);
      const MIN_TEXT_ITEM_HEIGHT = 20 + (TEXT_ITEM_PADDING * 2);
      const COLLECTION_IMAGE_MAX_SIZE = 50;
      const COLLECTION_IMAGE_MARGIN = 5;
      const COLLECTION_PADDING = 10;
      const COLLECTION_IMAGES_PER_ROW = 3;
      const textFontSizeLogical = 10;
      const minTextGapLogical = 8;
      const cropColors = {
        'いちご': '#e73562', 'にがうり': '#47885e', 'とうがらし': '#ff0000',
        'バナナ': '#ffe135', 'レモン': '#fffcbf', 'ぶどう': '#522f60', 'かき': '#ed6d3d'
      };
      const SNAP_THRESHOLD = 15;
      const SNAP_RATIO = 5;

      // ========================================
      // 2. グローバル変数宣言 (let)
      // ========================================
      let units = [];
      let groups = [];
      let textItems = [];
      let connections = [];
      let nextItemId = 0;
      let selectedItem = null;
      let draggingItem = null;
      let resizingItem = null;
      let resizeHandle = null;
      let dragOffsetX, dragOffsetY;
      let currentMode = null;
      let currentModeButtonElement = null;
      let connectFromItem = null;
      let itemsToGroup = [];
      let scale = 1.0;
      let zoomLevel = 0;
      let originX = 0;
      let originY = 0;
      let isPanning = false;
      let lastPanX, lastPanY;
      let history = [];
      let historyIndex = -1;
      let cropper = null;
      let currentCropFinalizeCallback = null;
      let currentImageSlotKeyForEditing = null;
      let currentEditingUnitContext = null;
      let editingUnit = null;
      let editingGroup = null;
      let editingTextItem = null;
      let uploadedCollectionImages = [];
      let editingCollectionUnit = null;
      let editingCollectionImageIndex = null;
      let draggedItem = null;
      let isDrawing = false;
      let lastDrawX, lastDrawY;
      let currentDrawingPath = [];
      let drawnPaths = [];
      let drawingColor = '#000000';
      let drawingLineWidth = 3;
      let drawingShape = 'line';
      let drawnPathsHistory = [];
      let drawnPathsHistoryIndex = -1;
      let unifySizeModeSubState = null;
      let unifySizeBaseUnit = null;
      let unifySizeTargetUnits = [];
      let editingLine = null;

      // ========================================
      // 3. HTML要素取得 (const ... = document.getElementById(...))
      // ========================================
      const leftPanel = document.getElementById('left-panel');
      const leftPanelToggleButton = document.getElementById('left-panel-toggle-button');
      const mainCanvasArea = document.getElementById('main-canvas-area');
      const modalOverlay = document.getElementById('modal-overlay');
      const addUnitBorderVisibleCheckbox = document.getElementById('add-unit-border-visible');
      const imageSlots = {
        birth: {
          uploadInput: document.getElementById('birth-image-upload'),
          previewImg: document.getElementById('birth-image-preview'),
          editBtn: document.getElementById('edit-birth-image-button'),
          clearBtn: document.getElementById('clear-birth-image-button'),
          nameInput: document.getElementById('birth-name'),
          foodSelect: document.getElementById('birth-favorite-food'),
          orderSakiCheckbox: null, orderAtoCheckbox: null, data: null
        },
        qr1: {
          uploadInput: document.getElementById('qr1-image-upload'),
          previewImg: document.getElementById('qr1-image-preview'),
          editBtn: document.getElementById('edit-qr1-image-button'),
          clearBtn: document.getElementById('clear-qr1-image-button'),
          nameInput: document.getElementById('qr1-name'),
          foodSelect: document.getElementById('qr1-favorite-food'),
          orderSakiCheckbox: document.getElementById('qr1-order-saki'),
          orderAtoCheckbox: document.getElementById('qr1-order-ato'), data: null
        },
        qr2: {
          uploadInput: document.getElementById('qr2-image-upload'),
          previewImg: document.getElementById('qr2-image-preview'),
          editBtn: document.getElementById('edit-qr2-image-button'),
          clearBtn: document.getElementById('clear-qr2-image-button'),
          nameInput: document.getElementById('qr2-name'),
          foodSelect: document.getElementById('qr2-favorite-food'),
          orderSakiCheckbox: document.getElementById('qr2-order-saki'),
          orderAtoCheckbox: document.getElementById('qr2-order-ato'), data: null
        }
      };
      const addUnitButton = document.getElementById('add-unit-button');
      const canvas = document.getElementById('family-tree-canvas');
      const ctx = canvas.getContext('2d');
      const statusBar = document.getElementById('status-bar');
      const infoButtonContainer = document.getElementById('info-button-container');
      const addTextContentInput = document.getElementById('add-text-content');
      const addTextColorInput = document.getElementById('add-text-color');
      const addTextBgColorInput = document.getElementById('add-text-bgcolor');
      const addTextSizeInput = document.getElementById('add-text-size');
      const addTextBorderVisibleCheckbox = document.getElementById('add-text-border-visible');
      const addTextItemButton = document.getElementById('add-text-item-button');
      const imageCollectionUploadInput = document.getElementById('image-collection-upload');
      const imageCollectionPreviewsDiv = document.getElementById('image-collection-previews');
      const imageCollectionDetailsDiv = document.getElementById('image-collection-details');
      const imageCollectionBorderCheckbox = document.getElementById('image-collection-border-visible');
      const addImageCollectionButton = document.getElementById('add-image-collection-button');
      const clearImageCollectionButton = document.getElementById('clear-image-collection-button');
      const undoButton = document.getElementById('undo-button');
      const redoButton = document.getElementById('redo-button');
      const connectButton = document.getElementById('connect-button');
      const editUnitButton = document.getElementById('edit-unit-button');
      const groupButton = document.getElementById('group-button');
      const unifySizeButton = document.getElementById('unify-size-button');
      const saveCanvasButton = document.getElementById('save-canvas-button');
      const zoomInButton = document.getElementById('zoom-in-button');
      const zoomOutButton = document.getElementById('zoom-out-button');
      const zoomLevelIndicator = document.getElementById('zoom-level-indicator');
      const cropperModal = document.getElementById('cropper-modal');
      const cropperModalCloseButtonHeader = document.getElementById('cropper-modal-close-button-header');
      const imageToCrop = document.getElementById('image-to-crop');
      const aspectRatioSelect = document.getElementById('aspect-ratio-select');
      const cropImageButton = document.getElementById('crop-image-button');
      const cancelCropButton = document.getElementById('cancel-crop-button');
      const cropperZoomControls = document.getElementById('cropper-zoom-controls');
      const unitEditModal = document.getElementById('unit-edit-modal');
      const unitEditModalTitle = document.getElementById('unit-edit-modal-title');
      const unitEditModalBody = document.getElementById('unit-edit-modal-body');
      const unitEditModalCloseButton = document.getElementById('unit-edit-modal-close-button');
      const unitEditApplyButton = document.getElementById('unit-edit-apply-button');
      const unitEditCancelButton = document.getElementById('unit-edit-cancel-button');
      const unitEditDuplicateButton = document.getElementById('unit-edit-duplicate-button');
      const unitEditDeleteButton = document.getElementById('unit-edit-delete-button');
      const groupEditModal = document.getElementById('group-edit-modal');
      const groupEditModalTitle = document.getElementById('group-edit-modal-title');
      const groupEditModalCloseButton = document.getElementById('group-edit-modal-close-button');
      const groupEditNameInput = document.getElementById('group-edit-name');
      const groupEditBorderVisibleCheckbox = document.getElementById('group-edit-border-visible');
      const groupEditApplyButton = document.getElementById('group-edit-apply-button');
      const groupEditCancelButton = document.getElementById('group-edit-cancel-button');
      const groupEditUngroupButton = document.getElementById('group-edit-ungroup-button');
      const groupEditDuplicateButton = document.getElementById('group-edit-duplicate-button');
      const groupEditDeleteButton = document.getElementById('group-edit-delete-button');
      const textEditModal = document.getElementById('text-edit-modal');
      const textEditModalTitle = document.getElementById('text-edit-modal-title');
      const textEditModalBody = document.getElementById('text-edit-modal-body');
      const textEditModalCloseButton = document.getElementById('text-edit-modal-close-button');
      const textEditApplyButton = document.getElementById('text-edit-apply-button');
      const textEditCancelButton = document.getElementById('text-edit-cancel-button');
      const textEditDeleteButton = document.getElementById('text-edit-delete-button');
      const textEditDuplicateButton = document.getElementById('text-edit-duplicate-button');
      const infoModal = document.getElementById('info-modal');
      const showInfoModalButton = document.getElementById('show-info-modal-button');
      const infoModalCloseButtonHeader = document.getElementById('info-modal-close-button-header');
      const infoModalCloseButtonFooter = document.getElementById('info-modal-close-button-footer');
      const requiredCropsList = document.getElementById('required-crops-list');
      const collectionEditModal = document.getElementById('image-collection-edit-modal');
      const collectionEditModalTitle = document.getElementById('collection-edit-modal-title');
      const collectionEditNameInput = document.getElementById('collection-edit-name');
      const collectionEditBorderCheckbox = document.getElementById('collection-edit-border-visible');
      const collectionEditImageList = document.getElementById('collection-edit-image-list');
      const collectionEditImageCount = document.getElementById('collection-edit-image-count');
      const collectionEditApplyButton = document.getElementById('collection-edit-apply-button');
      const collectionEditCancelButton = document.getElementById('collection-edit-cancel-button');
      const collectionEditDeleteButton = document.getElementById('collection-edit-delete-button');
      const collectionEditModalCloseButton = document.getElementById('collection-edit-modal-close-button');
      const resetLayoutButton = document.getElementById('reset-layout-settings-button');
      const clearStorageButton = document.getElementById('clear-storage-button');
      const modeButtons = {
        'connect': connectButton,
        'edit-item': editUnitButton,
        'grouping': groupButton,
        'unify-size': unifySizeButton
      };
      const modeMessages = {
        'connect': '接続モード: 接続元のユニットまたは線を選択し、次に対象のユニットまたは線を選択してください。',
        'edit-item': '編集モード: 編集したいユニット、グループ、またはテキストを選択してください。',
        'grouping': 'グループ化モード: ユニットを2つ選択してグループ化します。',
        'unify-size-select-base': 'サイズ統一: 基準となるユニットを選択してください。',
        'unify-size-select-targets': 'サイズ統一: 対象ユニットを選択 (クリックで選択/解除)。完了後「選択完了」ボタン。',
        'draw-path': '手書き描画モード: キャンバスに直接描画します。'
      };
      const drawModeButton = document.getElementById('draw-mode-button');
      const drawingToolsPanel = document.getElementById('drawing-tools-panel');
      const drawingColorPicker = document.getElementById('drawing-color-picker');
      const drawingLineWidthSlider = document.getElementById('drawing-line-width-slider');
      const drawingLineWidthValue = document.getElementById('drawing-line-width-value');
      const drawingShapeSelect = document.getElementById('drawing-shape-select');
      const drawingFillGroup = document.getElementById('drawing-fill-group');
      const drawingFillCheckbox = document.getElementById('drawing-fill-checkbox');
      const clearAllDrawingsButton = document.getElementById('clear-all-drawings-button');
      const drawingUndoButton = document.getElementById('drawing-undo-button');
      const drawingRedoButton = document.getElementById('drawing-redo-button');

      console.log("canvas 要素 (初期化時):", canvas);
      console.log("leftPanelToggleButton 要素 (初期化時):", leftPanelToggleButton);


      // ========================================
      // 4. 関数定義 (function ...() { ... })
      // ========================================

      function resizeCanvas() {
        canvas.width = 3000;
        canvas.height = 2000;
        drawCanvas();
      }

      function saveState() {
        const state = {
          units: JSON.parse(JSON.stringify(units.map(u => {
            if (u.type === 'image-collection') {
              return {
                ...u,
                layoutSettings: u.layoutSettings ? { ...u.layoutSettings } : null,
                images: u.images.map(imgInfo => ({
                  imgDataUrl: imgInfo.imgDataUrl,
                  originalDataUrl: imgInfo.originalDataUrl,
                  fileName: imgInfo.fileName,
                  name: imgInfo.name,
                  food: imgInfo.food
                }))
              };
            }
            const serializableSlots = {};
            for (const key in u.slots) {
              const slot = u.slots[key];
              serializableSlots[key] = slot ? {
                imgDataUrl: slot.imgDataUrl || null,
                originalDataUrl: slot.originalDataUrl || null,
                fileName: slot.fileName || null,
                name: slot.name || '',
                food: slot.food || '未選択',
                order: slot.order || null
              } : null;
            }
            return { ...u, width: u.width, height: u.height, slots: serializableSlots, borderVisible: u.borderVisible, activeSlotKeys: u.activeSlotKeys };

          }))),
          groups: JSON.parse(JSON.stringify(groups.map(g => ({ ...g, itemIds: [...g.itemIds], borderVisible: g.borderVisible })))),
          textItems: JSON.parse(JSON.stringify(textItems.map(t => ({ ...t, borderVisible: t.borderVisible, font: t.font || DEFAULT_FONT, rotation: t.rotation || 0 })))),
          connections: JSON.parse(JSON.stringify(connections.map(conn => ({
            id: conn.id,
            fromId: conn.fromId,
            toId: conn.toId,
            isUnitToLine: conn.isUnitToLine,
            isLineToUnit: conn.isLineToUnit,
            color: conn.color || '#555555',
            lineWidth: conn.lineWidth || 10,
            dashArray: conn.dashArray || [],
          })))),
          drawnPaths: JSON.parse(JSON.stringify(drawnPaths)),
          nextItemId: nextItemId,
          scale: scale,
          originX: originX,
          originY: originY,
          zoomLevel: zoomLevel

        };
        history = history.slice(0, historyIndex + 1);
        history.push(state);
        historyIndex++;
        updateUndoRedoButtons();

        try {
          localStorage.setItem('kakeizuToolState', JSON.stringify(state));
          console.log("状態をローカルストレージに保存しました。");
        } catch (e) {
          console.error("ローカルストレージへの保存に失敗しました:", e);
          // クォータ超過などの可能性をユーザーに通知することも検討
        }
      }

      function calculateUnitHeight(unitSlots) {
        let neededHeight = 0;
        let hasImage = false;
        let maxTextLines = 0;
        Object.entries(unitSlots).forEach(([slotKey, slotData]) => {
          let currentSlotLines = 0;
          if (slotData) {
            if (slotData.img || slotData.imgDataUrl) hasImage = true;
            if (slotData.name) currentSlotLines++;
            if (slotData.food && slotData.food !== '未選択') currentSlotLines++;
            if ((slotKey === 'qr1' || slotKey === 'qr2') && slotData.order) currentSlotLines++;
          }
          maxTextLines = Math.max(maxTextLines, currentSlotLines);
        });
        neededHeight += SLOT_PADDING_BASE;
        if (hasImage) {
          neededHeight += Math.max(SLOT_IMAGE_HEIGHT_BASE, SLOT_QR_IMAGE_SIZE_BASE);
          if (maxTextLines > 0) neededHeight += IMAGE_TEXT_PADDING;
        } else if (maxTextLines > 0) {
          neededHeight += SLOT_PADDING_BASE / 2;
        }
        neededHeight += maxTextLines * SLOT_TEXT_LINE_HEIGHT_BASE * TEXT_LINE_HEIGHT_MULTIPLIER;
        neededHeight += SLOT_PADDING_BASE;
        let minHeight;
        if (hasImage) {
          minHeight = SLOT_PADDING_BASE * 2 + Math.max(SLOT_IMAGE_HEIGHT_BASE, SLOT_QR_IMAGE_SIZE_BASE) + (maxTextLines > 0 ? IMAGE_TEXT_PADDING : 0) + (maxTextLines * SLOT_TEXT_LINE_HEIGHT_BASE * TEXT_LINE_HEIGHT_MULTIPLIER);
        } else {
          minHeight = SLOT_PADDING_BASE * 2 + (maxTextLines > 0 ? SLOT_PADDING_BASE / 2 : 0) + (maxTextLines * TEXT_LINE_HEIGHT_MULTIPLIER * SLOT_TEXT_LINE_HEIGHT_BASE);
        }
        minHeight = Math.max(minHeight, SLOT_PADDING_BASE * 2 + (maxTextLines > 0 ? SLOT_TEXT_LINE_HEIGHT_BASE * TEXT_LINE_HEIGHT_MULTIPLIER : SLOT_IMAGE_HEIGHT_BASE * 0.5));
        return Math.max(minHeight, neededHeight);
      }

      async function restoreState(state) {
        const restoredUnits = [];
        const loadImage = async (url) => {
          if (!url) return null;
          return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = () => { console.error(`Error loading image: ${url}`); resolve(null); };
            img.src = url;
          });
        };
        if (state.units) {
          for (const savedItem of state.units) {
            if (savedItem.type === 'image-collection') {
              const restoredImages = [];
              if (savedItem.images && Array.isArray(savedItem.images)) {
                for (const imgInfo of savedItem.images) {
                  restoredImages.push({ ...imgInfo, img: await loadImage(imgInfo.imgDataUrl) });
                }
              }
              restoredUnits.push({ ...savedItem, images: restoredImages, layoutSettings: savedItem.layoutSettings || null });
            } else {
              const newUnitSlots = {};
              if (savedItem.slots) {
                for (const key in savedItem.slots) {
                  const savedSlot = savedItem.slots[key];
                  if (savedSlot) {
                    newUnitSlots[key] = {
                      img: await loadImage(savedSlot.imgDataUrl),
                      imgDataUrl: savedSlot.imgDataUrl,
                      originalDataUrl: savedSlot.originalDataUrl,
                      fileName: savedSlot.fileName,
                      name: savedSlot.name,
                      food: savedSlot.food,
                      order: savedSlot.order || null
                    };
                  } else { newUnitSlots[key] = null; }
                }
              }
              const unitWidth = savedItem.width;
              const unitHeight = savedItem.height;
              const activeSlotKeys = savedItem.activeSlotKeys || Object.keys(newUnitSlots).filter(k => newUnitSlots[k]?.img || newUnitSlots[k]?.imgDataUrl);
              restoredUnits.push({
                ...savedItem, width: unitWidth, height: unitHeight, slots: newUnitSlots,
                borderVisible: savedItem.borderVisible !== undefined ? savedItem.borderVisible : true,
                activeSlotKeys: activeSlotKeys
              });
            }
          }
        }
        units = restoredUnits;
        groups = JSON.parse(JSON.stringify(state.groups || [])).map(g => ({ ...g, borderVisible: g.borderVisible !== undefined ? g.borderVisible : true }));
        textItems = JSON.parse(JSON.stringify(state.textItems || [])).map(t => ({ ...t, borderVisible: t.borderVisible !== undefined ? t.borderVisible : true, font: t.font || DEFAULT_FONT, rotation: t.rotation || 0 }));
        connections = JSON.parse(JSON.stringify(state.connections || [])).map(conn => ({
          ...conn,
          color: conn.color || '#555555',
          lineWidth: conn.lineWidth || 10,
          dashArray: conn.dashArray || [],
        }));
        nextItemId = state.nextItemId || 0;
        selectedItem = null; connectFromItem = null; itemsToGroup = [];
        drawCanvas(); updateUndoRedoButtons(); updateInfoModal();
        if (state.drawnPaths) {
          drawnPaths = JSON.parse(JSON.stringify(state.drawnPaths));
        } else {
          drawnPaths = [];
        }
        resetDrawingHistory();
        if (state.scale !== undefined) scale = state.scale;
        if (state.originX !== undefined) originX = state.originX;
        if (state.originY !== undefined) originY = state.originY;
        if (state.zoomLevel !== undefined) zoomLevel = state.zoomLevel;
        if (zoomLevelIndicator) zoomLevelIndicator.textContent = zoomLevel;

        selectedItem = null; connectFromItem = null; itemsToGroup = [];
        updateUndoRedoButtons();
        updateInfoModal();
        drawCanvas();
      }

      function updateUndoRedoButtons() {
        undoButton.disabled = historyIndex < 0;
        redoButton.disabled = historyIndex >= history.length - 1;
      }

      function checkAddUnitButtonState() {
        let hasAtLeastOneImage = false;
        Object.values(imageSlots).forEach(slot => {
          if (slot.data && slot.data.img) hasAtLeastOneImage = true;
        });
        addUnitButton.disabled = !hasAtLeastOneImage;
      }

      function checkAddTextButtonState() {
        addTextItemButton.disabled = addTextContentInput.value.trim() === '';
      }

      function checkAddImageCollectionButtonState() {
        addImageCollectionButton.disabled = uploadedCollectionImages.length === 0;
      }

      function handleQrOrderChange(changedSlotKey, changedValue, source) {
        const prefix = source === 'left-panel' ? '' : 'unit-edit-';
        const sakiSuffix = (source === 'left-panel') ? 'saki' : '先';
        const atoSuffix = (source === 'left-panel') ? 'ato' : '後';
        const qr1Saki = document.getElementById(`${prefix}qr1-order-${sakiSuffix}`);
        const qr1Ato = document.getElementById(`${prefix}qr1-order-${atoSuffix}`);
        const qr2Saki = document.getElementById(`${prefix}qr2-order-${sakiSuffix}`);
        const qr2Ato = document.getElementById(`${prefix}qr2-order-${atoSuffix}`);
        if (!qr1Saki || !qr1Ato || !qr2Saki || !qr2Ato) return;
        let operatedCheckbox;
        if (changedSlotKey.includes('qr1')) operatedCheckbox = (changedValue === '先') ? qr1Saki : qr1Ato;
        else operatedCheckbox = (changedValue === '先') ? qr2Saki : qr2Ato;
        const isChecked = operatedCheckbox.checked;
        if (isChecked) {
          if (changedSlotKey.includes('qr1')) {
            if (changedValue === '先') { qr1Ato.checked = false; qr2Saki.checked = false; qr2Ato.checked = true; }
            else { qr1Saki.checked = false; qr2Ato.checked = false; qr2Saki.checked = true; }
          } else {
            if (changedValue === '先') { qr2Ato.checked = false; qr1Saki.checked = false; qr1Ato.checked = true; }
            else { qr2Saki.checked = false; qr1Ato.checked = false; qr1Saki.checked = true; }
          }
        } else {
          if (changedSlotKey.includes('qr1')) { if (changedValue === '先') qr2Ato.checked = false; else qr2Saki.checked = false; }
          else { if (changedValue === '先') qr1Ato.checked = false; else qr1Saki.checked = false; }
        }
      }

      function selectCollectionImageForDetail(index) {
        imageCollectionPreviewsDiv.querySelectorAll('img').forEach(img => img.classList.remove('selected-preview'));
        imageCollectionDetailsDiv.querySelectorAll('.detail-item').forEach(item => item.style.display = 'none');
        const selectedPreview = imageCollectionPreviewsDiv.querySelector(`img[data-index="${index}"]`);
        if (selectedPreview) selectedPreview.classList.add('selected-preview');
        const selectedDetail = imageCollectionDetailsDiv.querySelector(`.detail-item[data-index="${index}"]`);
        if (selectedDetail) selectedDetail.style.display = 'block';
      }

      function renderImageCollectionDetails() {
        imageCollectionDetailsDiv.innerHTML = '';
        uploadedCollectionImages.forEach((imgData, index) => {
          const detailDiv = document.createElement('div'); detailDiv.className = 'detail-item'; detailDiv.dataset.index = index; detailDiv.style.display = 'none';
          const fileNameP = document.createElement('p'); fileNameP.textContent = `ファイル名: ${imgData.fileName}`; detailDiv.appendChild(fileNameP);
          const nameGroup = document.createElement('div'); nameGroup.className = 'form-group';
          const nameLabel = document.createElement('label'); nameLabel.textContent = '名前:'; nameLabel.style.flexBasis = '50px';
          const nameInput = document.createElement('input'); nameInput.type = 'text'; nameInput.value = imgData.name; nameInput.maxLength = 10; nameInput.placeholder = '名前(任意)'; nameInput.oninput = (e) => { uploadedCollectionImages[index].name = e.target.value; };
          nameGroup.appendChild(nameLabel); nameGroup.appendChild(nameInput); detailDiv.appendChild(nameGroup);
          const foodGroup = document.createElement('div'); foodGroup.className = 'form-group';
          const foodLabel = document.createElement('label'); foodLabel.textContent = '好物:'; foodLabel.style.flexBasis = '50px';
          const foodSelect = document.createElement('select');
          ['未選択', 'いちご', 'にがうり', 'とうがらし', 'バナナ', 'レモン', 'ぶどう', 'かき'].forEach(food => { const option = document.createElement('option'); option.value = food; option.textContent = food === '未選択' ? '選択(任意)' : food; foodSelect.appendChild(option); });
          foodSelect.value = imgData.food; foodSelect.onchange = (e) => { uploadedCollectionImages[index].food = e.target.value; };
          foodGroup.appendChild(foodLabel); foodGroup.appendChild(foodSelect); detailDiv.appendChild(foodGroup);
          imageCollectionDetailsDiv.appendChild(detailDiv);
        });
        if (uploadedCollectionImages.length > 0) selectCollectionImageForDetail(0);
      }

      function closeCropperModal() {
        cropperModal.style.display = 'none';
        if (currentEditingUnitContext === 'unit-edit-modal' || currentEditingUnitContext === 'collection-edit-modal') modalOverlay.style.zIndex = '1040';
        else modalOverlay.style.display = 'none';
        if (cropper) cropper.destroy(); cropper = null; currentCropFinalizeCallback = null;
      }

      function resetImageUploadsAndInputs() {
        Object.keys(imageSlots).forEach(slotKey => {
          const slotUI = imageSlots[slotKey];
          slotUI.previewImg.style.display = 'none'; slotUI.previewImg.src = '#'; slotUI.uploadInput.value = '';
          slotUI.editBtn.disabled = true; slotUI.clearBtn.classList.add('hidden');
          slotUI.nameInput.value = ''; slotUI.foodSelect.value = '未選択';
          if (slotUI.orderSakiCheckbox) slotUI.orderSakiCheckbox.checked = false;
          if (slotUI.orderAtoCheckbox) slotUI.orderAtoCheckbox.checked = false;
          slotUI.data = null;
        });
        addUnitBorderVisibleCheckbox.checked = true; checkAddUnitButtonState();
        imageCollectionUploadInput.value = ''; uploadedCollectionImages = [];
        imageCollectionPreviewsDiv.innerHTML = ''; imageCollectionDetailsDiv.innerHTML = '';
        imageCollectionBorderCheckbox.checked = true; checkAddImageCollectionButtonState();
        if (clearImageCollectionButton) clearImageCollectionButton.classList.add('hidden');
      }

      function wrapTextAndMeasure(text, maxWidth, fontSize, font, lineHeightMultiplier) {
        const words = text.split(/(\s+|\n)/); const lines = []; let currentLine = ''; let maxLineWidth = 0;
        const originalFont = ctx.font; ctx.font = `${fontSize}px ${font}`;
        for (const word of words) {
          if (word === '\n') { lines.push(currentLine); maxLineWidth = Math.max(maxLineWidth, ctx.measureText(currentLine).width); currentLine = ''; continue; }
          if (word.trim() === '' && word.length > 0) { currentLine += word; continue; }
          const testLine = currentLine + word; const testWidth = ctx.measureText(testLine).width;
          if (testWidth > maxWidth && currentLine !== '' && maxWidth > 0) {
            const wordWidth = ctx.measureText(word).width;
            if (wordWidth > maxWidth) { lines.push(currentLine); maxLineWidth = Math.max(maxLineWidth, ctx.measureText(currentLine).width); lines.push(word); maxLineWidth = Math.max(maxLineWidth, wordWidth); currentLine = ''; }
            else { lines.push(currentLine); maxLineWidth = Math.max(maxLineWidth, ctx.measureText(currentLine).width); currentLine = word.trimStart(); }
          } else { currentLine = testLine; }
        }
        lines.push(currentLine); maxLineWidth = Math.max(maxLineWidth, ctx.measureText(currentLine).width);
        ctx.font = originalFont;
        const nonEmptyLines = lines.filter((line, index) => line.trim() !== '' || index < lines.length - 1 || lines.length === 1);
        const calculatedHeight = nonEmptyLines.length * fontSize * lineHeightMultiplier;
        return { linesArray: nonEmptyLines, calculatedWidth: maxLineWidth, calculatedHeight: calculatedHeight };
      }

      function drawCanvas() {
        const itemsToDraw = {
          units: units,
          groups: groups,
          connections: connections,
          textItems: textItems,
          drawnPaths: drawnPaths,
          drawnPathsInProgress: currentDrawingPath, // 現在描画中のパスも渡す
          selectedItem: selectedItem,
          connectFromItem: connectFromItem,
          itemsToGroup: itemsToGroup,
          isDrawing: isDrawing // 現在描画モードかどうか
        };
        const currentSettings = {
          scale: scale,
          originX: originX,
          originY: originY,
          mode: currentMode // 必要であれば現在の操作モードも渡す
        };
        drawAllElementsOnContext(ctx, canvas, itemsToDraw, currentSettings);
      }
      function performUnifySize(baseUnit, scope, targetUnitsArray = null) {
        if (!baseUnit) {
          console.error("performUnifySize: 基準ユニットが指定されていません。");
          return;
        }
        const baseWidth = baseUnit.width;
        const baseHeight = baseUnit.height;
        let affectedUnits = [];
        let unifiedCount = 0;

        console.log(`performUnifySize: scope=${scope}, baseUnit=${getItemDisplayName(baseUnit)}`);

        if (scope === 'all') {
          affectedUnits = units.filter(u => u.id !== baseUnit.id && u.type === baseUnit.type);
        } else if (scope === 'visible') {
          affectedUnits = units.filter(u => {
            if (u.id === baseUnit.id || u.type !== baseUnit.type) return false;
            const unitRect = { // ユニットの表示上の矩形
              left: u.x * scale + originX,
              top: u.y * scale + originY,
              right: (u.x + u.width) * scale + originX,
              bottom: (u.y + u.height) * scale + originY
            };
            const canvasRect = { // キャンバスの表示領域
              left: 0,
              top: 0,
              right: mainCanvasArea.clientWidth, // mainCanvasArea を使用
              bottom: mainCanvasArea.clientHeight
            };
            // 矩形が一部でも重なっていれば表示されているとみなす
            return unitRect.left < canvasRect.right && unitRect.right > canvasRect.left &&
              unitRect.top < canvasRect.bottom && unitRect.bottom > canvasRect.top;
          });
        } else if (scope === 'selected' && targetUnitsArray && targetUnitsArray.length > 0) {
          // targetUnitsArray は既に isTargetSelectedForUnify でフィルタリングされたものを受け取る想定だが、
          // 念のため、ここでも baseUnit とタイプが同じか確認する
          affectedUnits = targetUnitsArray.filter(u => u.id !== baseUnit.id && u.type === baseUnit.type);
        }

        if (affectedUnits.length === 0) {
          showStatusBar('対象となるユニットがありませんでした。', unifySizeButton);
          // 選択解除
          unifySizeTargetUnits.forEach(u => u.isTargetSelectedForUnify = false);
          unifySizeTargetUnits = [];
          drawCanvas();
          return;
        }

        affectedUnits.forEach(unit => {
          unit.width = baseWidth;
          // アスペクト比を無視して基準ユニットの高さに一旦合わせる
          unit.height = baseHeight;

          // 画像集合ユニットの場合、高さは内容に応じて再計算（オプション）
          if (unit.type === 'image-collection') {
            const newSize = calculateImageCollectionUnitSize(unit.images, unit.layoutSettings);
            // 幅はbaseWidthのまま、高さだけ内容に合わせる
            unit.height = newSize.height;
          }
          // 通常ユニットの場合も、最小高さを下回らないようにする (オプション)
          else if (unit.type === 'unit') {
            const minRequiredHeight = calculateUnitHeight(unit.slots);
            unit.height = Math.max(unit.height, minRequiredHeight);
          }

          if (unit.isTargetSelectedForUnify) { // isTargetSelectedForUnify が設定されていれば解除
            unit.isTargetSelectedForUnify = false;
          }
          unifiedCount++;
        });

        if (unifiedCount > 0) {
          showStatusBar(`${unifiedCount}個のユニットのサイズを統一しました。`, unifySizeButton);
          saveState();
          drawCanvas();
        }
        unifySizeTargetUnits.forEach(u => u.isTargetSelectedForUnify = false);
        unifySizeTargetUnits = [];
      }
      function drawArrowhead(ctx, fromX, fromY, toX, toY, lineWidth) {

        // 矢じりの翼の長さを調整
        const baseHeadLength = 20; // 矢じりの基本的な長さ
        const headLengthFactor = 4; // 線の太さに対する倍率
        const headLength = Math.max(baseHeadLength, lineWidth * headLengthFactor);

        // 矢じりの翼の開く角度 (ラジアン)。小さいほど鋭角に、大きいほど鈍角に。
        const arrowAngle = Math.PI / 7; // (Math.PI / 6 は30度)

        // 線分の角度を計算
        const angle = Math.atan2(toY - fromY, toX - fromX);

        const x1 = toX - headLength * Math.cos(angle - arrowAngle);
        const y1 = toY - headLength * Math.sin(angle - arrowAngle);

        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(x1, y1);
        ctx.stroke();

        const x2 = toX - headLength * Math.cos(angle + arrowAngle);
        const y2 = toY - headLength * Math.sin(angle + arrowAngle);

        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }

      function drawRoundedRect(ctx, x, y, width, height, radius) {
        ctx.beginPath(); ctx.moveTo(x + radius, y); ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius); ctx.quadraticCurveTo(x, y, x + radius, y); ctx.closePath();
      }

      function truncateText(text, maxLength) {
        if (!text) return '';
        return text.length > maxLength ? text.substring(0, maxLength - 1) + '…' : text;
      }

      function findItemById(id) {
        return units.find(u => u.id === id) || groups.find(g => g.id === id) || textItems.find(t => t.id === id);
      }

      function getCanvasCoordinates(event) {
        const rect = canvas.getBoundingClientRect(); let clientX, clientY;
        if (event.touches && event.touches.length > 0) { clientX = event.touches[0].clientX; clientY = event.touches[0].clientY; }
        else { clientX = event.clientX; clientY = event.clientY; }
        const canvasElementX = clientX - rect.left; const canvasElementY = clientY - rect.top;
        return { x: (canvasElementX - originX) / scale, y: (canvasElementY - originY) / scale };
      }

      function getResizeHandle(item, x, y) {
        if (!item || (item.type !== 'unit' && item.type !== 'group' && item.type !== 'text' && item.type !== 'image-collection')) return null;
        if (!selectedItem || selectedItem.id !== item.id) return null;
        const handleSize = BORDER_RESIZE_THRESHOLD / scale;
        const right = item.x + item.width; const bottom = item.y + item.height;
        const left = item.x; const top = item.y;
        const onRight = Math.abs(x - right) < handleSize; const onBottom = Math.abs(y - bottom) < handleSize;
        const onLeft = Math.abs(x - left) < handleSize; const onTop = Math.abs(y - top) < handleSize;
        if (onRight && onBottom) return 'bottom-right'; if (onLeft && onBottom) return 'bottom-left';
        if (onRight && onTop) return 'top-right'; if (onLeft && onTop) return 'top-left';
        if (onRight) return 'right'; if (onBottom) return 'bottom';
        if (onLeft) return 'left'; if (onTop) return 'top';
        return null;
      }
      function getLineMidpoint(lineId) {
        const line = connections.find(conn => conn.id === lineId);
        if (!line) {
          console.warn(`getLineMidpoint: Line with id ${lineId} not found.`);
          return null;
        }

        const fromItem = findItemById(line.fromId);
        const toItem = findItemById(line.toId);

        // 今回の制限では、元の線(lineId)のfromItemとtoItemは必ずユニットのはず
        if (!fromItem || !toItem || fromItem.id.startsWith('conn-') || toItem.id.startsWith('conn-')) {
          console.warn(`getLineMidpoint: Original line ${lineId} does not connect two non-line items.`);
          return null;
        }

        const startX = fromItem.x + fromItem.width / 2;
        const startY = fromItem.y + fromItem.height / 2;
        const endX = toItem.x + toItem.width / 2;
        const endY = toItem.y + toItem.height / 2;

        return { x: (startX + endX) / 2, y: (startY + endY) / 2, originalLineId: lineId }; // 元の線IDも返す
      }

      function handleInteractionStart(event) {
        const coords = getCanvasCoordinates(event);
        let clickedItem = null;
        let clickedResizeHandleType = null;
        let clickedLine = null; // ★ 選択された線を保持する変数 ★

        // クリックされたアイテムの判定 (描画モード以外で実行)
        if (!currentMode || currentMode !== 'draw-path') {
          let foundItem = null;
          // グループ、次にユニット、最後にテキストの順でチェックすると、重なり時の優先順位を制御しやすい
          const checkOrder = [...groups, ...units, ...textItems]; // グループを先にチェック

          for (let i = 0; i < checkOrder.length; i++) { // グループから先にチェックするために逆順ループをやめる
            const item = checkOrder[i];
            let itemBoundary = { x: item.x, y: item.y, width: item.width, height: item.height };

            if (item.type === 'group') {
              // まずグループ枠自体がクリックされたかチェック
              if (coords.x >= itemBoundary.x && coords.x <= itemBoundary.x + itemBoundary.width &&
                coords.y >= itemBoundary.y && coords.y <= itemBoundary.y + itemBoundary.height) {
                // グループ内のユニットがクリックされていないか確認
                let unitInGroupClicked = false;
                for (const unitId of item.itemIds) {
                  const unitInGroup = findItemById(unitId);
                  if (unitInGroup &&
                    coords.x >= unitInGroup.x && coords.x <= unitInGroup.x + unitInGroup.width &&
                    coords.y >= unitInGroup.y && coords.y <= unitInGroup.y + unitInGroup.height) {
                    foundItem = unitInGroup;
                    unitInGroupClicked = true;
                    break;
                  }
                }
                if (!unitInGroupClicked) {
                  foundItem = item;
                }
                if (foundItem) break;
              }
            } else {
              const isItemInAGroup = groups.some(g => g.itemIds.includes(item.id));
              if (!isItemInAGroup ||
                currentMode === 'edit-item' ||
                (currentMode && currentMode.startsWith('unify-size'))
              ) {
                if (coords.x >= itemBoundary.x && coords.x <= itemBoundary.x + itemBoundary.width &&
                  coords.y >= itemBoundary.y && coords.y <= itemBoundary.y + itemBoundary.height) {
                  foundItem = item;
                  break;
                }
              }
            }
          }
          clickedItem = foundItem;
        }


        if (!clickedItem && (!currentMode || currentMode !== 'draw-path')) {
          let minDistanceSq = Infinity;
          const clickThresholdRadius = 10 / scale;
          const clickThresholdSq = clickThresholdRadius * clickThresholdRadius;

          for (const conn of connections) {
            if (conn.fromId.startsWith('conn-') || conn.toId.startsWith('conn-')) {
              continue;
            }

            const fromItem = findItemById(conn.fromId);
            const toItem = findItemById(conn.toId);

            if (fromItem && toItem) {
              const p1 = { x: fromItem.x + fromItem.width / 2, y: fromItem.y + fromItem.height / 2 };
              const p2 = { x: toItem.x + toItem.width / 2, y: toItem.y + toItem.height / 2 };

              const lenSq = (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
              if (lenSq === 0) continue;

              let t = ((coords.x - p1.x) * (p2.x - p1.x) + (coords.y - p1.y) * (p2.y - p1.y)) / lenSq;
              t = Math.max(0, Math.min(1, t));

              const closestPoint = {
                x: p1.x + t * (p2.x - p1.x),
                y: p1.y + t * (p2.y - p1.y)
              };
              const distanceSq = (coords.x - closestPoint.x) ** 2 + (coords.y - closestPoint.y) ** 2;

              if (distanceSq < minDistanceSq && distanceSq < clickThresholdSq) {
                minDistanceSq = distanceSq;
                clickedLine = conn;
              }
            }
          }
          if (clickedLine) {
            console.log("Clicked on line:", clickedLine.id);
          }
        }
        // --- ここまで接続線のクリック判定 ---

        const targetForItemOrLine = clickedItem || clickedLine;

        if (currentMode === 'unify-size-select-base') {
          if (targetForItemOrLine && (targetForItemOrLine.type === 'unit' || targetForItemOrLine.type === 'image-collection')) {
            unifySizeBaseUnit = targetForItemOrLine;
            document.getElementById('unify-base-unit-name').textContent = getItemDisplayName(unifySizeBaseUnit);
            document.getElementById('unify-base-unit-size').textContent = `${unifySizeBaseUnit.width.toFixed(0)}x${unifySizeBaseUnit.height.toFixed(0)}`;
            openModal(document.getElementById('unify-size-options-modal'));
            unifySizeModeSubState = 'show-options';
            hideStatusBar();
          } else if (targetForItemOrLine) {
            showStatusBar('基準としてユニットまたは画像集合ユニットを選択してください。', unifySizeButton);
          }
          return;
        } else if (currentMode === 'unify-size-select-targets') {
          if (targetForItemOrLine && (targetForItemOrLine.type === 'unit' || targetForItemOrLine.type === 'image-collection')) {
            if (unifySizeBaseUnit && targetForItemOrLine.id === unifySizeBaseUnit.id) {
              showStatusBar('基準ユニット自身は対象として選択できません。', unifySizeButton);
            } else {
              const index = unifySizeTargetUnits.findIndex(u => u.id === targetForItemOrLine.id);
              if (index > -1) {
                unifySizeTargetUnits.splice(index, 1);
                targetForItemOrLine.isTargetSelectedForUnify = false;
              } else {
                unifySizeTargetUnits.push(targetForItemOrLine);
                targetForItemOrLine.isTargetSelectedForUnify = true;
              }
              showStatusBar(`${unifySizeTargetUnits.length}個のユニットを選択中。完了したら「選択完了」ボタン。`, unifySizeButton);
              drawCanvas();
            }
          } else if (targetForItemOrLine) {
            showStatusBar('対象としてユニットまたは画像集合ユニットを選択してください。', unifySizeButton);
          }
          return;
        }

        if (currentMode === 'draw-path') {
          isDrawing = true;
          currentDrawingPath = [{
            type: drawingShape,
            color: drawingShape === 'eraser' ? (canvas.style.backgroundColor || '#fdfdfd') : drawingColor,
            lineWidth: drawingLineWidth,
            points: [[coords.x, coords.y]],
            isFilled: (drawingShape === 'rectangle' || drawingShape === 'circle') ? drawingFillCheckbox.checked : false,
            startX: coords.x,
            startY: coords.y
          }];
          drawCanvas();
          return;
        }

        if (selectedItem && !currentMode && !targetForItemOrLine) {
          clickedResizeHandleType = getResizeHandle(selectedItem, coords.x, coords.y);
          if (clickedResizeHandleType) {
            resizingItem = selectedItem;
            resizeHandle = clickedResizeHandleType;
            canvas.style.cursor = getResizeCursor(resizeHandle);
            canvas.classList.add('resizing');
            dragOffsetX = coords.x;
            dragOffsetY = coords.y;
            return;
          }
        }


        if (!resizingItem) {
          if (currentMode === 'connect') {
            if (!connectFromItem) {
              if (targetForItemOrLine) {
                if (targetForItemOrLine.type === 'text') {
                  showStatusBar('テキストアイテムは接続元にできません。', connectButton);
                } else {
                  connectFromItem = targetForItemOrLine;
                  const fromType = targetForItemOrLine.id.startsWith('conn-') ? `線(${truncateText(targetForItemOrLine.id, 10)})` : getItemDisplayName(targetForItemOrLine);
                  showStatusBar(`接続元(${fromType})選択 - 接続先のユニットまたは線を選択`, connectButton);
                }
              } else {
                // 背景クリック: 接続モードで接続元未選択時に背景クリックなら何もしない
              }
            } else {
              if (targetForItemOrLine) {
                if (targetForItemOrLine.id === connectFromItem.id) {
                  showStatusBar('同じアイテム(または線)には接続できません。', connectButton);
                }
                else if (connectFromItem.id.startsWith('conn-') && targetForItemOrLine.id.startsWith('conn-')) {
                  showStatusBar('線と線を直接接続することはできません。ユニットを選択してください。', connectButton);
                }
                else if (targetForItemOrLine.type === 'text') {
                  showStatusBar('テキストアイテムは接続先にできません。', connectButton);
                }
                else {
                  let newConnectionMade = false;
                  let connectionStatusMessage = "";

                  // ケースA: 接続元がユニット、接続先が線
                  if (!connectFromItem.id.startsWith('conn-') && targetForItemOrLine.id.startsWith('conn-')) {
                    const unitToConnect = connectFromItem;
                    const lineToConnectTo = targetForItemOrLine;
                    const lineMidpoint = getLineMidpoint(lineToConnectTo.id);

                    if (unitToConnect && unitToConnect.type !== 'text' && lineMidpoint) {
                      const unitBoundaryPoint = getIntersectionPointWithUnitBoundary(unitToConnect, lineMidpoint);

                      if (unitBoundaryPoint) {
                        const newConnectionId = `conn-${nextItemId++}`;
                        connections.push({
                          id: newConnectionId,
                          fromId: unitToConnect.id,
                          toId: lineToConnectTo.id,
                          isUnitToLine: true,
                          color: '#555555',
                          lineWidth: 10,
                          dashArray: []
                        });
                        connectionStatusMessage = `接続(U→L): ${getItemDisplayName(unitToConnect)} -> 線(${truncateText(lineToConnectTo.id, 10)})`;
                        newConnectionMade = true;
                      } else {
                        connectionStatusMessage = 'エラー: U→L ユニット境界との交点計算失敗。';
                      }
                    } else {
                      connectionStatusMessage = 'エラー: U→L 接続情報不足';
                      if (unitToConnect && unitToConnect.type === 'text') connectionStatusMessage = 'エラー: U→L テキスト不可';
                    }
                  }
                  // ケースB: 接続元が線、接続先がユニット
                  else if (connectFromItem.id.startsWith('conn-') && targetForItemOrLine && !targetForItemOrLine.id.startsWith('conn-')) {
                    const lineToConnectFrom = connectFromItem;
                    const unitToConnectTo = targetForItemOrLine;
                    const lineMidpoint = getLineMidpoint(lineToConnectFrom.id);
                    if (lineMidpoint && unitToConnectTo && unitToConnectTo.type !== 'text') {
                      const unitBoundaryPoint = getIntersectionPointWithUnitBoundary(unitToConnectTo, lineMidpoint);

                      if (unitBoundaryPoint) {
                        const newConnectionId = `conn-${nextItemId++}`;
                        connections.push({
                          id: newConnectionId,
                          fromId: lineToConnectFrom.id,
                          toId: unitToConnectTo.id,
                          isLineToUnit: true,
                          color: '#555555',
                          lineWidth: 10,
                          dashArray: []
                        });
                        connectionStatusMessage = `接続(L→U): 線(${truncateText(lineToConnectFrom.id, 10)}) -> ${getItemDisplayName(unitToConnectTo)}`;
                        newConnectionMade = true;
                      } else {
                        connectionStatusMessage = 'エラー: L→U ユニット境界との交点計算失敗。';
                      }
                    } else {
                      connectionStatusMessage = 'エラー: L→U 接続情報不足';
                      if (unitToConnectTo && unitToConnectTo.type === 'text') connectionStatusMessage = 'エラー: L→U テキスト不可';
                    }
                  }
                  // ケースC: 接続元がユニット、接続先もユニット (従来)
                  else if (!connectFromItem.id.startsWith('conn-') && targetForItemOrLine && !targetForItemOrLine.id.startsWith('conn-')) {
                    const unitFrom = connectFromItem;
                    const unitTo = targetForItemOrLine;
                    if (unitFrom.type !== 'text' && unitTo.type !== 'text' && unitFrom.type && unitTo.type) {
                      const newConnectionId = `conn-${nextItemId++}`;
                      connections.push({
                        id: newConnectionId,
                        fromId: unitFrom.id,
                        toId: unitTo.id,
                        color: '#555555',
                        lineWidth: 10,
                        dashArray: []
                      });
                      connectionStatusMessage = `接続(U→U): ${getItemDisplayName(unitFrom)} -> ${getItemDisplayName(unitTo)}`;
                      newConnectionMade = true;
                    } else {
                      connectionStatusMessage = "エラー: U→U 不明なアイテムタイプです。";
                    }
                  } else {
                    connectionStatusMessage = "無効な接続の組み合わせです。";
                    console.warn("Invalid connection combination attempt:", connectFromItem, targetForItemOrLine);
                  }

                  if (newConnectionMade) {
                    showStatusBar(connectionStatusMessage, connectButton);
                    saveState();
                    connectFromItem = null;
                  } else {
                    if (connectionStatusMessage) {
                      showStatusBar(connectionStatusMessage, connectButton);
                    } else {
                      showStatusBar("接続できませんでした。対象を確認してください。", connectButton);
                    }
                  }
                }
              } else {
                if (connectFromItem) {
                  const fromType = connectFromItem.id.startsWith('conn-') ? `線(${truncateText(connectFromItem.id, 10)})` : getItemDisplayName(connectFromItem);
                  showStatusBar(`接続元(${fromType})の選択を解除。再度選択してください。`, connectButton);
                  connectFromItem = null;
                }
              }
            }
            drawCanvas();
            return;
          }


          if (targetForItemOrLine) {
            selectedItem = targetForItemOrLine;

            if (!currentMode) {
              if (clickedItem) {
                draggingItem = clickedItem;
                dragOffsetX = coords.x - clickedItem.x;
                dragOffsetY = coords.y - clickedItem.y;
                canvas.classList.add('dragging');
                canvas.style.cursor = 'grabbing';
              }
            } else if (currentMode === 'edit-item') {
              if (clickedItem && clickedItem.type === 'unit') openUnitEditModal(clickedItem);
              else if (clickedItem && clickedItem.type === 'group') openGroupEditModal(clickedItem);
              else if (clickedItem && clickedItem.type === 'text') openTextEditModal(clickedItem);
              else if (clickedItem && clickedItem.type === 'image-collection') openImageCollectionEditModal(clickedItem);
              else if (clickedLine) {
                openLineStyleEditModal(clickedLine);
              }
            } else if (currentMode === 'grouping') {
              if (clickedItem && (clickedItem.type === 'unit' || clickedItem.type === 'image-collection' || clickedItem.type === 'text') &&
                !itemsToGroup.find(item => item.id === clickedItem.id)) {
                itemsToGroup.push(clickedItem);
                clickedItem.isBeingGrouped = true;
                showStatusBar(`${itemsToGroup.length}個選択中。2個以上でグループ作成。`, groupButton);
                if (itemsToGroup.length >= 2) {
                  createGroupFromSelection();
                  itemsToGroup.forEach(it => it.isBeingGrouped = false);
                  itemsToGroup = [];
                }
              } else if (clickedItem && clickedItem.type !== 'unit' && clickedItem.type !== 'image-collection' && clickedItem.type !== 'text') {
                showStatusBar("グループ化対象外です。ユニット、画像集合、またはテキストを選択してください。", groupButton);
              }
            }
          } else {
            if (currentMode) {
              if (currentMode === 'grouping') {
                itemsToGroup.forEach(it => it.isBeingGrouped = false);
                itemsToGroup = [];
                showStatusBar(modeMessages[currentMode], groupButton);
              }
            } else {
              selectedItem = null;
              isPanning = true;
              lastPanX = event.touches ? event.touches[0].clientX : event.clientX;
              lastPanY = event.touches ? event.touches[0].clientY : event.clientY;
              canvas.style.cursor = 'grabbing';
            }
          }
        }
        drawCanvas();
      }

      function handleInteractionMove(event) {

        if (currentMode === 'draw-path') {
          if (!isDrawing) {
            return;
          }
          event.preventDefault();

          const coords = getCanvasCoordinates(event);

          if (currentDrawingPath.length > 0) {
            const currentPathObject = currentDrawingPath[0];
            if (currentPathObject && currentPathObject.points) {

              if (currentPathObject.type === 'line' || currentPathObject.type === 'eraser' || currentPathObject.type === 'arrow') {
                currentPathObject.points.push([coords.x, coords.y]);
              } else if (currentPathObject.type === 'rectangle' || currentPathObject.type === 'circle') {
                if (currentPathObject.points.length === 1) {
                  currentPathObject.points.push([coords.x, coords.y]);
                } else if (currentPathObject.points.length === 2) {
                  currentPathObject.points[1] = [coords.x, coords.y];
                }
              }
            }
          }
          drawCanvas();
          return;
        }

        event.preventDefault();
        const coords = getCanvasCoordinates(event);

        if (resizingItem && resizeHandle) {
          const dx = coords.x - dragOffsetX; const dy = coords.y - dragOffsetY;
          let minWidth, minHeight; const textPadding = TEXT_ITEM_PADDING;
          if (resizingItem.type === 'text') { minWidth = MIN_TEXT_ITEM_WIDTH; minHeight = MIN_TEXT_ITEM_HEIGHT; }
          else if (resizingItem.type === 'unit') { minWidth = UNIT_WIDTH_ONE_SLOT; minHeight = calculateUnitHeight(resizingItem.slots); }
          else if (resizingItem.type === 'image-collection') { const minSize = calculateImageCollectionUnitSize(resizingItem.images || [], resizingItem.layoutSettings); minWidth = minSize.width; minHeight = minSize.height; }
          else { minWidth = 50; minHeight = 50; } // group
          let newWidth = resizingItem.width, newHeight = resizingItem.height, newX = resizingItem.x, newY = resizingItem.y;
          switch (resizeHandle) {
            case 'bottom-right': newWidth = Math.max(resizingItem.width + dx, minWidth); newHeight = Math.max(resizingItem.height + dy, minHeight); break;
            case 'right': newWidth = Math.max(resizingItem.width + dx, minWidth); break;
            case 'left': const pLW = resizingItem.width - dx; if (pLW >= minWidth) { newWidth = pLW; newX = resizingItem.x + dx; } else { newWidth = minWidth; newX = resizingItem.x + (resizingItem.width - minWidth); } break;
            case 'bottom': newHeight = Math.max(resizingItem.height + dy, minHeight); break;
            case 'top': const pTH = resizingItem.height - dy; if (pTH >= minHeight) { newHeight = pTH; newY = resizingItem.y + dy; } else { newHeight = minHeight; newY = resizingItem.y + (resizingItem.height - minHeight); } break;
            case 'top-left': const ptlW = resizingItem.width - dx, ptlH = resizingItem.height - dy; if (ptlW >= minWidth) { newWidth = ptlW; newX = resizingItem.x + dx; } else { newWidth = minWidth; newX = resizingItem.x + (resizingItem.width - minWidth); } if (ptlH >= minHeight) { newHeight = ptlH; newY = resizingItem.y + dy; } else { newHeight = minHeight; newY = resizingItem.y + (resizingItem.height - minHeight); } break;
            case 'top-right': newWidth = Math.max(resizingItem.width + dx, minWidth); const ptrH = resizingItem.height - dy; if (ptrH >= minHeight) { newHeight = ptrH; newY = resizingItem.y + dy; } else { newHeight = minHeight; newY = resizingItem.y + (resizingItem.height - minHeight); } break;
            case 'bottom-left': const pblW = resizingItem.width - dx; newHeight = Math.max(resizingItem.height + dy, minHeight); if (pblW >= minWidth) { newWidth = pblW; newX = resizingItem.x + dx; } else { newWidth = minWidth; newX = resizingItem.x + (resizingItem.width - minWidth); } break;
          }
          if (resizingItem.type === 'group') {
            let cMinX = Infinity, cMinY = Infinity, cMaxX = -Infinity, cMaxY = -Infinity; let hUIG = false;
            resizingItem.itemIds.forEach(id => { const uIG = findItemById(id); if (uIG) { hUIG = true; cMinX = Math.min(cMinX, uIG.x); cMinY = Math.min(cMinY, uIG.y); cMaxX = Math.max(cMaxX, uIG.x + uIG.width); cMaxY = Math.max(cMaxY, uIG.y + uIG.height); } });
            if (hUIG) { const rCW = cMaxX - cMinX; const rCH = cMaxY - cMinY; const mGW = rCW + GROUP_PADDING * 2; const mGH = rCH + GROUP_PADDING * 2; newWidth = Math.max(newWidth, mGW); newHeight = Math.max(newHeight, mGH); if (resizeHandle.includes('left')) { newX = Math.min(newX, cMinX - GROUP_PADDING); if (newX + newWidth < cMaxX + GROUP_PADDING) newWidth = cMaxX + GROUP_PADDING - newX; } else { if (newX + newWidth < cMaxX + GROUP_PADDING) newWidth = cMaxX + GROUP_PADDING - newX; } if (resizeHandle.includes('top')) { newY = Math.min(newY, cMinY - GROUP_PADDING); if (newY + newHeight < cMaxY + GROUP_PADDING) newHeight = cMaxY + GROUP_PADDING - newY; } else { if (newY + newHeight < cMaxY + GROUP_PADDING) newHeight = cMaxY + GROUP_PADDING - newY; } newWidth = Math.max(newWidth, mGW); newHeight = Math.max(newHeight, mGH); }
          } else if (resizingItem.type === 'unit') {
            const pG = groups.find(g => g.itemIds.includes(resizingItem.id));
            if (pG) { const gIL = pG.x + GROUP_PADDING, gIT = pG.y + GROUP_PADDING, gIR = pG.x + pG.width - GROUP_PADDING, gIB = pG.y + pG.height - GROUP_PADDING; if (newX < gIL) { newWidth = resizingItem.x + resizingItem.width - gIL; newX = gIL; } if (newY < gIT) { newHeight = resizingItem.y + resizingItem.height - gIT; newY = gIT; } if (newX + newWidth > gIR) newWidth = gIR - newX; if (newY + newHeight > gIB) newHeight = gIB - newY; newWidth = Math.max(newWidth, minWidth); newHeight = Math.max(newHeight, minHeight); if (newX + newWidth > gIR) newX = gIR - newWidth; if (newY + newHeight > gIB) newY = gIB - newHeight; if (newX < gIL) newX = gIL; if (newY < gIT) newY = gIT; }
          } else if (resizingItem.type === 'image-collection') {
            const newCalculatedSize = calculateImageCollectionUnitSize(resizingItem.images, resizingItem.layoutSettings);
            if (resizeHandle.includes('right') || resizeHandle.includes('left')) newHeight = newCalculatedSize.height;
            else if (resizeHandle.includes('top') || resizeHandle.includes('bottom')) newWidth = newCalculatedSize.width;
            else { newWidth = Math.max(newWidth, newCalculatedSize.width); newHeight = newCalculatedSize.height; }
          }
          resizingItem.width = newWidth; resizingItem.height = newHeight; resizingItem.x = newX; resizingItem.y = newY;
          if (resizingItem.type === 'text' && ['left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right'].includes(resizeHandle)) { const cMW = resizingItem.width - (textPadding * 2); if (cMW > 0) { const m = wrapTextAndMeasure(resizingItem.text, cMW, resizingItem.fontSize, resizingItem.font || DEFAULT_FONT, TEXT_LINE_HEIGHT_MULTIPLIER); const nCH = m.calculatedHeight + (textPadding * 2); resizingItem.height = Math.max(minHeight, nCH); } else { resizingItem.height = minHeight; } }
          dragOffsetX = coords.x; dragOffsetY = coords.y; drawCanvas();
        } else if (draggingItem && !currentMode) {
          const targetX = coords.x - dragOffsetX; const targetY = coords.y - dragOffsetY;
          let snappedX = targetX; let snappedY = targetY;
          if (draggingItem.type === 'unit' || draggingItem.type === 'image-collection') {
            const itemConnections = connections.filter(c => c.fromId === draggingItem.id || c.toId === draggingItem.id);
            if (itemConnections.length > 0) {
              const conn = itemConnections[0]; const otherItemId = conn.fromId === draggingItem.id ? conn.toId : conn.fromId;
              const otherItem = findItemById(otherItemId);
              if (otherItem) {
                const dC = { x: targetX + draggingItem.width / 2, y: targetY + draggingItem.height / 2 }; const oC = { x: otherItem.x + otherItem.width / 2, y: otherItem.y + otherItem.height / 2 };
                const dXAbs = Math.abs(dC.x - oC.x); const dYAbs = Math.abs(dC.y - oC.y);
                const currentSnapThreshold = SNAP_THRESHOLD / scale;
                if (dYAbs < currentSnapThreshold && dXAbs > dYAbs * SNAP_RATIO) snappedY = oC.y - draggingItem.height / 2;
                else if (dXAbs < currentSnapThreshold && dYAbs > dXAbs * SNAP_RATIO) snappedX = oC.x - draggingItem.width / 2;
              }
            }
          }
          const finalDeltaX = snappedX - draggingItem.x; const finalDeltaY = snappedY - draggingItem.y;
          if (draggingItem.type === 'unit' || draggingItem.type === 'image-collection' || draggingItem.type === 'text') {
            const parentGroup = groups.find(g => g.itemIds.includes(draggingItem.id));
            if (parentGroup) {
              snappedX = Math.max(parentGroup.x + GROUP_PADDING, Math.min(snappedX, parentGroup.x + parentGroup.width - GROUP_PADDING - draggingItem.width));
              snappedY = Math.max(parentGroup.y + GROUP_PADDING, Math.min(snappedY, parentGroup.y + parentGroup.height - GROUP_PADDING - draggingItem.height));
            }
          }
          draggingItem.x = snappedX; draggingItem.y = snappedY;
          if (draggingItem.type === 'group') { draggingItem.itemIds.forEach(unitId => { const uIG = findItemById(unitId); if (uIG) { uIG.x += finalDeltaX; uIG.y += finalDeltaY; } }); }
          drawCanvas();
        }
        else if (isPanning) { const cX = event.touches ? event.touches[0].clientX : event.clientX; const cY = event.touches ? event.touches[0].clientY : event.clientY; originX += cX - lastPanX; originY += cY - lastPanY; lastPanX = cX; lastPanY = cY; drawCanvas(); }
        else if (selectedItem && !currentMode) { const hT = getResizeHandle(selectedItem, coords.x, coords.y); if (hT) { canvas.style.cursor = getResizeCursor(hT); canvas.classList.add('resize-handle-hover'); } else { canvas.style.cursor = 'grab'; canvas.classList.remove('resize-handle-hover'); } }
      }

      function handleInteractionEnd(event) {
        if (isDrawing && currentMode === 'draw-path') {
          isDrawing = false;
          if (currentDrawingPath.length > 0 && currentDrawingPath[0].points.length >= 1) {
            const pathObj = currentDrawingPath[0];
            if ((pathObj.type === 'line' || pathObj.type === 'eraser') && pathObj.points.length < 2) {
              currentDrawingPath = [];
            }
            else if ((pathObj.type === 'rectangle' || pathObj.type === 'circle') &&
              pathObj.points.length === 2 &&
              pathObj.points[0][0] === pathObj.points[1][0] &&
              pathObj.points[0][1] === pathObj.points[1][1]) {
              currentDrawingPath = [];
            }

            if (currentDrawingPath.length > 0) {
              drawnPaths.push(...currentDrawingPath);
              currentDrawingPath = [];
              saveDrawingState();
            }
          } else {
            currentDrawingPath = [];
          }
        } else {
          if (resizingItem && resizingItem.type === 'image-collection') {
            const finalSize = calculateImageCollectionUnitSize(resizingItem.images, resizingItem.layoutSettings);
            resizingItem.width = Math.max(finalSize.width, resizingItem.width);
            resizingItem.height = finalSize.height;
          }
          else if (resizingItem && resizingItem.type === 'text' && ['left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right'].includes(resizeHandle)) {
            const textPaddingForCalc = TEXT_ITEM_PADDING;
            const contentMaxWidth = resizingItem.width - (textPaddingForCalc * 2);
            let minHeight = Math.max(MIN_TEXT_ITEM_HEIGHT, resizingItem.fontSize * TEXT_LINE_HEIGHT_MULTIPLIER + (textPaddingForCalc * 2));
            if (contentMaxWidth > 0) {
              const m = wrapTextAndMeasure(resizingItem.text, contentMaxWidth, resizingItem.fontSize, resizingItem.font || DEFAULT_FONT, TEXT_LINE_HEIGHT_MULTIPLIER);
              const finalHeight = m.calculatedHeight + (textPaddingForCalc * 2);
              resizingItem.height = Math.max(minHeight, finalHeight);
            } else { resizingItem.height = minHeight; }
          }
          else if (resizingItem && resizingItem.type === 'unit') {
            const minRequiredHeight = calculateUnitHeight(resizingItem.slots);
            resizingItem.height = Math.max(resizingItem.height, minRequiredHeight);
            const parentGroup = groups.find(g => g.itemIds.includes(resizingItem.id));
            if (parentGroup) { /* ... (unit in group resize end limits) ... */ }
          }
          else if (resizingItem && resizingItem.type === 'group') {
            let cMinX = Infinity, cMinY = Infinity, cMaxX = -Infinity, cMaxY = -Infinity; let hUIG = false;
            resizingItem.itemIds.forEach(id => { const uIG = findItemById(id); if (uIG) { hUIG = true; cMinX = Math.min(cMinX, uIG.x); cMinY = Math.min(cMinY, uIG.y); cMaxX = Math.max(cMaxX, uIG.x + uIG.width); cMaxY = Math.max(cMaxY, uIG.y + uIG.height); } });
            if (hUIG) { const rCW = cMaxX - cMinX, rCH = cMaxY - cMinY; const mGW = rCW + GROUP_PADDING * 2, mGH = rCH + GROUP_PADDING * 2; resizingItem.width = Math.max(resizingItem.width, mGW); resizingItem.height = Math.max(resizingItem.height, mGH); if (resizingItem.x + GROUP_PADDING > cMinX) resizingItem.x = cMinX - GROUP_PADDING; if (resizingItem.y + GROUP_PADDING > cMinY) resizingItem.y = cMinY - GROUP_PADDING; if (resizingItem.x + resizingItem.width - GROUP_PADDING < cMaxX) resizingItem.x = cMaxX + GROUP_PADDING - resizingItem.width; if (resizingItem.y + resizingItem.height - GROUP_PADDING < cMaxY) resizingItem.y = cMaxY + GROUP_PADDING - resizingItem.height; resizingItem.width = Math.max(resizingItem.width, mGW); resizingItem.height = Math.max(resizingItem.height, mGH); }
          }

          if ((draggingItem || resizingItem) && !currentMode) {
            saveState();
          }
        }

        isDrawing = false;
        if (draggingItem) canvas.classList.remove('dragging');
        if (resizingItem) canvas.classList.remove('resizing');
        draggingItem = null; resizingItem = null; resizeHandle = null;
        if (isPanning) isPanning = false;
        canvas.classList.remove('resize-handle-hover');
        canvas.style.cursor = currentMode ? (currentMode === 'edit-item' ? 'pointer' : (currentMode === 'draw-path' ? 'crosshair' : 'crosshair')) : 'grab';
        drawCanvas();
      }

      function toggleMode(newMode, buttonElement) {
        const unifySizeButton = document.getElementById('unify-size-button');
        const unifySizeCompleteSelectionBtn = document.getElementById('unify-size-complete-selection-btn');
        const unifyOptionsModal = document.getElementById('unify-size-options-modal');

        if (currentModeButtonElement) {
          if (currentModeButtonElement.dataset.originalText) {
            currentModeButtonElement.textContent = currentModeButtonElement.dataset.originalText;
          } else if (currentModeButtonElement.title) {
            currentModeButtonElement.textContent = currentModeButtonElement.title.split('(')[0].trim();
          } else {
            let originalText = "ボタン";
            const btnId = currentModeButtonElement.id;
            if (btnId === 'connect-button') originalText = "接続";
            else if (btnId === 'edit-unit-button') originalText = "編集";
            else if (btnId === 'group-button') originalText = "まとめる";
            else if (btnId === 'unify-size-button') originalText = "サイズ統一";
            else if (btnId === 'draw-mode-button') originalText = "描画";
            currentModeButtonElement.textContent = originalText;
          }
          currentModeButtonElement.classList.remove('active-mode-button');
        }

        if (currentMode && currentMode.startsWith('unify-size') && (!newMode || !newMode.startsWith('unify-size'))) {
          unifySizeModeSubState = null;
          unifySizeBaseUnit = null;
          unifySizeTargetUnits.forEach(u => u.isTargetSelectedForUnify = false);
          unifySizeTargetUnits = [];
          if (unifySizeCompleteSelectionBtn) unifySizeCompleteSelectionBtn.style.display = 'none';
          if (unifyOptionsModal && unifyOptionsModal.style.display !== 'none') closeModal(unifyOptionsModal);
        }

        canvas.classList.remove('mode-active', 'connect-mode-active', 'edit-mode', 'grouping');
        if (drawingToolsPanel && (!newMode || newMode !== 'draw-path')) {
          drawingToolsPanel.style.display = 'none';
        }

        if (currentMode === newMode || newMode === null) {
          currentMode = null;
          currentModeButtonElement = null;
          connectFromItem = null;
          itemsToGroup = [];
          hideStatusBar();
          canvas.style.cursor = 'grab';
        } else {
          currentMode = newMode;
          currentModeButtonElement = buttonElement;

          if (buttonElement) {
            if (!buttonElement.dataset.originalText) {
              buttonElement.dataset.originalText = buttonElement.textContent;
            }
            buttonElement.textContent = 'キャンセル';
            buttonElement.classList.add('active-mode-button');
          }

          showStatusBar(modeMessages[currentMode] || `モード: ${currentMode}`, buttonElement);
          canvas.classList.add('mode-active');

          if (newMode === 'draw-path') {
            if (drawingToolsPanel) drawingToolsPanel.style.display = 'block';
            canvas.style.cursor = 'crosshair';
            updateFillOptionVisibility();
            resetDrawingHistory();
          } else if (newMode === 'edit-item') {
            canvas.classList.add('edit-mode');
            canvas.style.cursor = 'pointer';
          } else if (newMode === 'grouping') {
            canvas.classList.add('grouping');
            canvas.style.cursor = 'cell';
          } else if (newMode.startsWith('unify-size')) {
            canvas.style.cursor = 'pointer';
            if (newMode === 'unify-size-select-base') {
              unifySizeModeSubState = 'select-base';
            }
            if (unifySizeCompleteSelectionBtn) {
              if (newMode === 'unify-size-select-targets') {
                unifySizeCompleteSelectionBtn.style.display = 'inline-block';
              } else {
                unifySizeCompleteSelectionBtn.style.display = 'none';
              }
            }
          } else {
            canvas.style.cursor = 'crosshair';
          }
        }
        drawCanvas();
      }

      function showStatusBar(message, buttonElement) {
        statusBar.textContent = message;
        if (buttonElement) {
          const buttonStyle = window.getComputedStyle(buttonElement);
          statusBar.style.backgroundColor = buttonStyle.backgroundColor;
          const bgColor = buttonStyle.backgroundColor;
          if (bgColor.includes('rgb')) {
            try { const rgb = bgColor.match(/\d+/g).map(Number); const luminance = 0.299 * rgb[0] + 0.587 * rgb[1] + 0.114 * rgb[2]; statusBar.style.color = luminance > 128 ? '#333' : '#fff'; }
            catch (e) { statusBar.style.color = '#fff'; }
          } else { statusBar.style.color = '#fff'; }
        } else { statusBar.style.backgroundColor = 'rgba(0,123,255,0.9)'; statusBar.style.color = '#fff'; }
        statusBar.style.display = 'block'; infoButtonContainer.style.top = `${statusBar.offsetHeight + 10}px`;
      }
      function hideStatusBar() { statusBar.style.display = 'none'; infoButtonContainer.style.top = '10px'; }

      function drawUnitForSave(targetContext, unit) {
        targetContext.save(); targetContext.translate(unit.x, unit.y);
        targetContext.fillStyle = '#fff'; drawRoundedRect(targetContext, 0, 0, unit.width, unit.height, 8); targetContext.fill();
        if (unit.borderVisible) { targetContext.strokeStyle = '#333'; targetContext.lineWidth = 2; drawRoundedRect(targetContext, 0, 0, unit.width, unit.height, 8); targetContext.stroke(); }
        const cSP = SLOT_PADDING_BASE, cIP = UNIT_INTERNAL_PADDING_BASE, fS = 11 * BASE_SCALE_FACTOR, tLH = SLOT_TEXT_LINE_HEIGHT_BASE * TEXT_LINE_HEIGHT_MULTIPLIER, bIH = SLOT_IMAGE_HEIGHT_BASE, qIMSH = SLOT_QR_IMAGE_SIZE_BASE;
        let hI = Object.values(unit.slots).some(s => s && s.img), hTI = Object.entries(unit.slots).some(([k, s]) => s && (s.name || (s.food && s.food !== '未選択') || ((k === 'qr1' || k === 'qr2') && s.order)));
        let tSY = cSP; if (hI) { tSY += Math.max(bIH, qIMSH) + (hTI ? IMAGE_TEXT_PADDING : 0); } else if (hTI) { tSY += cSP / 2; }
        const aSK = unit.activeSlotKeys || [], iC = aSK.length; let sW, sSX = cSP; const dSK = [];
        if (iC === 1) { sW = SLOT_WIDTH_BASE; sSX = (unit.width - sW) / 2; if (aSK.length > 0) dSK.push(aSK[0]); }
        else if (iC === 2) { sW = SLOT_WIDTH_BASE; const p = ['qr1', 'birth', 'qr2']; const srtK = [...aSK].sort((a, b) => p.indexOf(a) - p.indexOf(b)); if (srtK.length >= 2) { dSK.push(srtK[0]); dSK.push(srtK[1]); sSX = (unit.width - (sW * 2 + cIP)) / 2; } else if (srtK.length === 1) { dSK.push(srtK[0]); sSX = (unit.width - sW) / 2; } }
        else { sW = SLOT_WIDTH_BASE; const p = ['qr1', 'birth', 'qr2']; dSK.push(...p.filter(k => activeSlotKeys.includes(k))); p.forEach(k => { if (dSK.length < 3 && !dSK.includes(k) && unit.slots[k] && (unit.slots[k].img || unit.slots[k].name || (unit.slots[k].food && unit.slots[k].food !== '未選択') || unit.slots[k].order)) dSK.push(k); }); if (unit.width !== UNIT_WIDTH_THREE_SLOTS && dSK.length > 0 && dSK.length < 3) { const nTD = dSK.length; const tIPN = nTD > 1 ? cIP * (nTD - 1) : 0; const tPN = cSP * 2 + tIPN; sW = nTD > 0 ? (unit.width - tPN) / nTD : SLOT_WIDTH_BASE; sSX = cSP; } else if (dSK.length === 0 && hTI) { sW = unit.width - cSP * 2; sSX = cSP; const fTSlot = p.find(k => unit.slots[k] && (unit.slots[k].name || (unit.slots[k].food && unit.slots[k].food !== '未選択') || ((k === 'qr1' || k === 'qr2') && unit.slots[k].order))); if (fTSlot) dSK.push(fTSlot); } else { sSX = cSP; const nSTC = Math.max(dSK.length, 3); const tP3C = cSP * 2 + cIP * (nSTC - 1); sW = (UNIT_WIDTH_THREE_SLOTS - tP3C) / nSTC; if (dSK.length < 3 && unit.width !== UNIT_WIDTH_THREE_SLOTS) { const nTD = dSK.length; const tIPN = nTD > 1 ? cIP * (nTD - 1) : 0; const tPN = cSP * 2 + tIPN; sW = nTD > 0 ? (unit.width - tPN) / nTD : SLOT_WIDTH_BASE; } } }
        let cSX = sSX; const sOForD = ['qr1', 'birth', 'qr2']; let dCnt = 0;
        for (const sK of sOForD) {
          if (!dSK.includes(sK) && dCnt >= iC && iC > 0) continue; if (!unit.slots[sK]) continue;
          const sD = unit.slots[sK]; targetContext.save(); targetContext.translate(cSX, cSP);
          const iTD = sD?.img; const sAvH = (sK === 'birth') ? bIH : qIMSH; const sAvW = sW;
          if (iTD && iTD.complete && iTD.naturalWidth > 0) { try { const ar = iTD.naturalWidth / iTD.naturalHeight; let dW, dH; if (sK === 'birth') { dW = sAvW; dH = dW / ar; if (dH > sAvH) { dH = sAvH; dW = dH * ar; } } else { if (sAvW / ar <= sAvH) { dW = sAvW; dH = dW / ar; } else { dH = sAvH; dW = dH * ar; } } dW = Math.min(dW, sW); const iX = (sW - dW) / 2, iY = (sAvH - dH) / 2; targetContext.drawImage(iTD, iX, iY, dW, dH); } catch (e) { console.error("Error drawing image for save:", e); } }
          if (hTI && sD) { targetContext.font = `${fS}px ${DEFAULT_FONT}`; targetContext.textAlign = 'center'; let cTLY = tSY; const tAvH = unit.height - tSY - cSP; const tSSt = 'rgba(255,255,255,0.8)'; const tSWi = 3; const dTWOF = (t, y) => { if (y - tSY + tLH <= tAvH + 1) { targetContext.strokeStyle = tSSt; targetContext.lineWidth = tSWi; targetContext.strokeText(t, sW / 2, y - cSP, sW); targetContext.fillStyle = '#333'; targetContext.fillText(t, sW / 2, y - cSP, sW); return true; } return false; }; if (sD.name) { if (dTWOF(truncateText(sD.name, 12), cTLY)) cTLY += tLH; } if (sD.food && sD.food !== '未選択') { if (dTWOF(truncateText('好物:' + sD.food, 15), cTLY)) cTLY += tLH; } if (sD.order && (sK === 'qr1' || sK === 'qr2')) { dTWOF(sD.order, cTLY); } }
          targetContext.restore(); dCnt++; if (dCnt < dSK.length || (dSK.length < 3 && dCnt < 3)) cSX += sW + cIP;
        }
        targetContext.restore();
      }

      function updateZoom() { scale = Math.pow(1.2, zoomLevel); zoomLevelIndicator.textContent = zoomLevel; drawCanvas(); }
      function openModal(modalElement) { modalOverlay.style.display = 'block'; modalElement.style.display = 'block'; if (modalElement === cropperModal && (currentEditingUnitContext === 'unit-edit-modal' || currentEditingUnitContext === 'collection-edit-modal')) modalOverlay.style.zIndex = '1055'; else modalOverlay.style.zIndex = '1040'; }
      function closeModal(modalElement) { modalElement.style.display = 'none'; const anyOtherOpen = Array.from(document.querySelectorAll('.modal')).some(m => m !== modalElement && (m.style.display === 'block' || m.style.display === 'flex')); if (!anyOtherOpen) modalOverlay.style.display = 'none'; else if (unitEditModal.style.display === 'block' || unitEditModal.style.display === 'flex' || collectionEditModal.style.display === 'block' || collectionEditModal.style.display === 'flex') modalOverlay.style.zIndex = '1040'; }

      function openUnitEditModal(unit) {
        editingUnit = unit;
        editingLine = null;
        editingGroup = null;
        editingTextItem = null;
        editingCollectionUnit = null;
        unitEditModalTitle.textContent = `ユニット編集: ${truncateText(getItemDisplayName(unit), 20)}`;
        unitEditModalBody.innerHTML = '';

        function setupModalQrOrderLogic() {
          console.log("setupModalQrOrderLogic called");
          const qr1Saki = document.getElementById('unit-edit-qr1-order-先');
          const qr1Ato = document.getElementById('unit-edit-qr1-order-後');
          const qr2Saki = document.getElementById('unit-edit-qr2-order-先');
          const qr2Ato = document.getElementById('unit-edit-qr2-order-後');

          console.log("Checkboxes in setupModalQrOrderLogic:", qr1Saki, qr1Ato, qr2Saki, qr2Ato);

          if (!qr1Saki || !qr1Ato || !qr2Saki || !qr2Ato) {
            console.warn("Modal QR order checkboxes not found for logic setup.");
            return;
          }

          const updateChecks = (changedSlot, changedValue, isChecked) => {
            if (isChecked) {
              if (changedSlot === 'qr1' && changedValue === '先') {
                qr1Ato.checked = false;
                qr2Saki.checked = false;
                if (!qr2Ato.checked) qr2Ato.checked = true;
              } else if (changedSlot === 'qr1' && changedValue === '後') {
                qr1Saki.checked = false;
                qr2Ato.checked = false;
                if (!qr2Saki.checked) qr2Saki.checked = true;
              } else if (changedSlot === 'qr2' && changedValue === '先') {
                qr2Ato.checked = false;
                qr1Saki.checked = false;
                if (!qr1Ato.checked) qr1Ato.checked = true;
              } else if (changedSlot === 'qr2' && changedValue === '後') {
                qr2Saki.checked = false;
                qr1Ato.checked = false;
                if (!qr1Saki.checked) qr1Saki.checked = true;
              }
            } else {
              if (changedSlot === 'qr1' && changedValue === '先') {
                qr2Ato.checked = false;
              } else if (changedSlot === 'qr1' && changedValue === '後') {
                qr2Saki.checked = false;
              } else if (changedSlot === 'qr2' && changedValue === '先') {
                qr1Ato.checked = false;
              } else if (changedSlot === 'qr2' && changedValue === '後') {
                qr1Saki.checked = false;
              }
            }
          };

          qr1Saki.addEventListener('change', (e) => updateChecks('qr1', '先', e.target.checked));
          qr1Ato.addEventListener('change', (e) => updateChecks('qr1', '後', e.target.checked));
          qr2Saki.addEventListener('change', (e) => updateChecks('qr2', '先', e.target.checked));
          qr2Ato.addEventListener('change', (e) => updateChecks('qr2', '後', e.target.checked));
        }

        const checkboxesRowContainer = document.createElement('div');
        checkboxesRowContainer.className = 'checkbox-row-container';

        const borderItemContainer = document.createElement('div');
        borderItemContainer.className = 'checkbox-item-container';
        const borderCheckboxInput = document.createElement('input');
        borderCheckboxInput.type = 'checkbox';
        borderCheckboxInput.id = 'unit-edit-border-visible';
        borderCheckboxInput.checked = unit.borderVisible !== undefined ? unit.borderVisible : true;
        const borderLabel = document.createElement('label');
        borderLabel.htmlFor = 'unit-edit-border-visible';
        borderLabel.textContent = '枠表示';
        borderItemContainer.appendChild(borderCheckboxInput);
        borderItemContainer.appendChild(borderLabel);
        checkboxesRowContainer.appendChild(borderItemContainer);

        const monocolorItemContainer = document.createElement('div');
        monocolorItemContainer.className = 'checkbox-item-container';
        const monocolorCheckboxInput = document.createElement('input');
        monocolorCheckboxInput.type = 'checkbox';
        monocolorCheckboxInput.id = 'unit-edit-is-monocolor';
        monocolorCheckboxInput.checked = unit.isMonocolor === true;
        const monocolorLabel = document.createElement('label');
        monocolorLabel.htmlFor = 'unit-edit-is-monocolor';
        monocolorLabel.textContent = '単色(SP化リスクあり)';
        monocolorItemContainer.appendChild(monocolorCheckboxInput);
        monocolorItemContainer.appendChild(monocolorLabel);
        checkboxesRowContainer.appendChild(monocolorItemContainer);

        const targetItemContainer = document.createElement('div');
        targetItemContainer.className = 'checkbox-item-container';
        const targetIndividualCheckboxInput = document.createElement('input');
        targetIndividualCheckboxInput.type = 'checkbox';
        targetIndividualCheckboxInput.id = 'unit-edit-is-target-individual';
        targetIndividualCheckboxInput.checked = unit.isTargetIndividual === true;
        const targetIndividualLabel = document.createElement('label');
        targetIndividualLabel.htmlFor = 'unit-edit-is-target-individual';
        targetIndividualLabel.textContent = '最終目標個体';

        const imageCount = unit.activeSlotKeys ? unit.activeSlotKeys.length : 0;
        if (unit.type === 'unit' && imageCount === 1) {
          targetIndividualCheckboxInput.disabled = false;
          targetIndividualLabel.title = 'このユニットを推奨捕獲順の最終目標に設定します。';
        } else {
          targetIndividualCheckboxInput.disabled = true;
          targetIndividualCheckboxInput.checked = false;
          targetIndividualLabel.title = '推奨捕獲順の最終目標は、画像が1枚含まれるユニットのみ設定できます。';
        }
        targetItemContainer.appendChild(targetIndividualCheckboxInput);
        targetItemContainer.appendChild(targetIndividualLabel);
        checkboxesRowContainer.appendChild(targetItemContainer);

        unitEditModalBody.appendChild(checkboxesRowContainer);
        unitEditModalBody.appendChild(document.createElement('hr'));

        Object.keys(unit.slots).forEach(sK => {
          const sD = unit.slots[sK];
          const sDv = document.createElement('div');
          sDv.className = 'slot-edit-section';

          const titleH5 = document.createElement('h5');
          titleH5.textContent = `${sK === 'birth' ? '出生' : sK.toUpperCase()}スロット`;
          sDv.appendChild(titleH5);

          const previewImg = document.createElement('img');
          previewImg.id = `unit-edit-preview-${sK}`;
          previewImg.src = sD?.imgDataUrl || 'https://placehold.co/100x50/eee/ccc?text=No+Image';
          previewImg.style.cssText = 'max-width:100px;max-height:50px;display:block;margin-bottom:5px; background-color: #fff; border: 1px solid #ddd;';
          sDv.appendChild(previewImg);

          const currentSlotEditImageButton = document.createElement('button');
          currentSlotEditImageButton.textContent = '画像を編集';
          currentSlotEditImageButton.id = `unit-edit-edit-image-btn-${sK}`;
          currentSlotEditImageButton.style.marginBottom = '5px';
          currentSlotEditImageButton.onclick = () => {
            currentImageSlotKeyForEditing = sK;
            currentEditingUnitContext = 'unit-edit-modal';
            const urlToEdit = editingUnit.slots[sK]?.originalDataUrl || editingUnit.slots[sK]?.imgDataUrl;
            if (urlToEdit) {
              imageToCrop.src = urlToEdit;
              openModal(cropperModal);
              if (cropper) cropper.destroy();
              const aspectRatio = (sK === 'birth') ? NaN : 1;
              aspectRatioSelect.value = isNaN(aspectRatio) ? "NaN" : aspectRatio.toString();
              cropper = new Cropper(imageToCrop, {
                aspectRatio: aspectRatio, viewMode: 1, dragMode: 'move', background: false,
                responsive: true, restore: true, checkCrossOrigin: true, checkOrientation: true,
                modal: true, guides: true, center: true, highlight: true,
                cropBoxMovable: true, cropBoxResizable: true, toggleDragModeOnDblclick: false,
              });
              currentCropFinalizeCallback = (croppedDataUrl) => {
                const img = new Image();
                img.onload = () => {
                  if (!editingUnit.slots[currentImageSlotKeyForEditing]) {
                    editingUnit.slots[currentImageSlotKeyForEditing] = {};
                  }
                  const targetSlot = editingUnit.slots[currentImageSlotKeyForEditing];
                  targetSlot.img = img;
                  targetSlot.imgDataUrl = croppedDataUrl;
                  if (!targetSlot.originalDataUrl || targetSlot.originalDataUrl !== croppedDataUrl) {
                    targetSlot.originalDataUrl = croppedDataUrl;
                  }
                  const modalPreviewImage = document.getElementById(`unit-edit-preview-${currentImageSlotKeyForEditing}`);
                  if (modalPreviewImage) modalPreviewImage.src = croppedDataUrl;
                };
                img.onerror = () => { console.error("モーダル内での切り抜き後画像読み込みエラー:", currentImageSlotKeyForEditing); };
                img.src = croppedDataUrl;
                closeCropperModal();
              };
            } else {
              alert('このスロットに編集可能な元画像データがありません。先に「画像を変更」で画像をアップロードするか、既存の画像があることを確認してください。');
            }
          };
          sDv.appendChild(currentSlotEditImageButton);

          const currentSlotChangeNewImageButton = document.createElement('button');
          currentSlotChangeNewImageButton.textContent = '画像を変更';
          currentSlotChangeNewImageButton.id = `unit-edit-change-new-image-btn-${sK}`;
          currentSlotChangeNewImageButton.style.marginBottom = '10px';
          currentSlotChangeNewImageButton.onclick = () => {
            currentImageSlotKeyForEditing = sK;
            currentEditingUnitContext = 'unit-edit-modal';

            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'image/*';
            fileInput.onchange = (event) => {
              const file = event.target.files[0];
              if (file) {
                const reader = new FileReader();
                reader.onload = (e_reader) => {
                  const newImageDataUrl = e_reader.target.result;
                  const img = new Image();
                  img.onload = () => {
                    if (!editingUnit.slots[currentImageSlotKeyForEditing]) {
                      editingUnit.slots[currentImageSlotKeyForEditing] = { name: '', food: '未選択', order: null, img: null, imgDataUrl: null, originalDataUrl: null, fileName: null };
                    }
                    const targetSlot = editingUnit.slots[currentImageSlotKeyForEditing];
                    targetSlot.img = img;
                    targetSlot.imgDataUrl = newImageDataUrl;
                    targetSlot.originalDataUrl = newImageDataUrl;
                    targetSlot.fileName = file.name;

                    const modalPreviewImage = document.getElementById(`unit-edit-preview-${currentImageSlotKeyForEditing}`);
                    if (modalPreviewImage) modalPreviewImage.src = newImageDataUrl;
                  };
                  img.onerror = () => {
                    console.error("モーダル内での「画像を変更」時の新しい画像読み込みエラー:", currentImageSlotKeyForEditing);
                    alert("画像の読み込みに失敗しました。");
                  };
                  img.src = newImageDataUrl;
                };
                reader.readAsDataURL(file);
              }
            };
            fileInput.click();
          };
          sDv.appendChild(currentSlotChangeNewImageButton);

          // 名前入力
          const nameGroup = document.createElement('div'); nameGroup.className = 'form-group';
          const nameLabel = document.createElement('label'); nameLabel.htmlFor = `unit-edit-name-${sK}`; nameLabel.textContent = '名前:';
          const nameInput = document.createElement('input'); nameInput.type = 'text'; nameInput.id = `unit-edit-name-${sK}`; nameInput.value = sD?.name || ''; nameInput.maxLength = 10; nameInput.dataset.slotKey = sK; nameInput.className = 'unit-edit-slot-name';
          nameGroup.appendChild(nameLabel); nameGroup.appendChild(nameInput); sDv.appendChild(nameGroup);

          // 好物選択
          const foodGroup = document.createElement('div'); foodGroup.className = 'form-group';
          const foodLabel = document.createElement('label'); foodLabel.htmlFor = `unit-edit-food-${sK}`; foodLabel.textContent = '好物:';
          const foodSelect = document.createElement('select'); foodSelect.id = `unit-edit-food-${sK}`; foodSelect.dataset.slotKey = sK; foodSelect.className = 'unit-edit-slot-food';
          ['未選択', 'いちご', 'にがうり', 'とうがらし', 'バナナ', 'レモン', 'ぶどう', 'かき'].forEach(food => {
            const option = document.createElement('option'); option.value = food; option.textContent = food === '未選択' ? '選択(任意)' : food; foodSelect.appendChild(option);
          });
          foodSelect.value = sD?.food || '未選択';
          foodGroup.appendChild(foodLabel); foodGroup.appendChild(foodSelect); sDv.appendChild(foodGroup);

          // 入居順 (QR1, QR2スロットのみ)
          if (sK === 'qr1' || sK === 'qr2') {
            const orderGroup = document.createElement('div');
            orderGroup.className = 'order-checkbox-group';
            const orderMainLabel = document.createElement('label');
            orderMainLabel.textContent = '入居順(任意):';
            orderMainLabel.className = 'order-label';
            orderGroup.appendChild(orderMainLabel);

            const sakiCheckId = `unit-edit-${sK}-order-先`;
            const sakiOrderCheck = document.createElement('input');
            sakiOrderCheck.type = 'checkbox';
            sakiOrderCheck.name = `unit-edit-${sK}-order`;
            sakiOrderCheck.value = '先';
            sakiOrderCheck.id = sakiCheckId;
            sakiOrderCheck.checked = sD?.order === '先';
            sakiOrderCheck.dataset.slotKey = sK;
            sakiOrderCheck.className = 'unit-edit-slot-order';

            const atoCheckId = `unit-edit-${sK}-order-後`;
            const atoOrderCheck = document.createElement('input');
            atoOrderCheck.type = 'checkbox';
            atoOrderCheck.name = `unit-edit-${sK}-order`;
            atoOrderCheck.value = '後';
            atoOrderCheck.id = atoCheckId;
            atoOrderCheck.checked = sD?.order === '後';
            atoOrderCheck.dataset.slotKey = sK;
            atoOrderCheck.className = 'unit-edit-slot-order';

            sakiOrderCheck.addEventListener('change', (e) => {
              if (e.target.checked) {
                atoOrderCheck.checked = false;
                const otherSlotKey = sK === 'qr1' ? 'qr2' : 'qr1';
                const otherSlotSaki = document.getElementById(`unit-edit-${otherSlotKey}-order-先`);
                const otherSlotAto = document.getElementById(`unit-edit-${otherSlotKey}-order-後`);
                if (otherSlotSaki && otherSlotAto) {
                  otherSlotSaki.checked = false;
                  if (!otherSlotAto.checked) otherSlotAto.checked = true;
                }
              }
            });
            atoOrderCheck.addEventListener('change', (e) => {
              if (e.target.checked) {
                sakiOrderCheck.checked = false;
                const otherSlotKey = sK === 'qr1' ? 'qr2' : 'qr1';
                const otherSlotSaki = document.getElementById(`unit-edit-${otherSlotKey}-order-先`);
                const otherSlotAto = document.getElementById(`unit-edit-${otherSlotKey}-order-後`);
                if (otherSlotSaki && otherSlotAto) {
                  otherSlotAto.checked = false;
                  if (!otherSlotSaki.checked) otherSlotSaki.checked = true;
                }
              }
            });

            const sakiLabelElement = document.createElement('label');
            sakiLabelElement.htmlFor = sakiCheckId;
            sakiLabelElement.textContent = '先';
            sakiLabelElement.style.fontWeight = 'normal';

            const atoLabelElement = document.createElement('label');
            atoLabelElement.htmlFor = atoCheckId;
            atoLabelElement.textContent = '後';
            atoLabelElement.style.fontWeight = 'normal';

            orderGroup.appendChild(sakiOrderCheck);
            orderGroup.appendChild(sakiLabelElement);
            orderGroup.appendChild(atoOrderCheck);
            orderGroup.appendChild(atoLabelElement);
            sDv.appendChild(orderGroup);
          }
          unitEditModalBody.appendChild(sDv);
        });
        setupModalQrOrderLogic();

        const duplicateButton = document.getElementById('unit-edit-duplicate-button');
        const deleteButton = document.getElementById('unit-edit-delete-button');
        const applyButton = document.getElementById('unit-edit-apply-button');
        const cancelButton = document.getElementById('unit-edit-cancel-button');

        if (duplicateButton) {
          duplicateButton.style.display = 'inline-block';
        }
        if (deleteButton) {
          deleteButton.style.display = 'inline-block';
          deleteButton.textContent = 'ユニット削除';
        }
        if (applyButton) {
          applyButton.style.display = 'inline-block';
        }
        if (cancelButton) {
          cancelButton.style.display = 'inline-block';
        }

        openModal(unitEditModal);
      }

      function openGroupEditModal(group) {
        editingGroup = group; groupEditModalTitle.textContent = `グループ編集: ${truncateText(group.name || '無名グループ', 20)}`;
        groupEditNameInput.value = group.name || '';
        groupEditBorderVisibleCheckbox.checked = group.borderVisible !== undefined ? group.borderVisible : true;
        openModal(groupEditModal);
      }

      function openTextEditModal(textItem) {
        editingTextItem = textItem; textEditModalTitle.textContent = `テキスト編集: ${truncateText(textItem.text, 15)}`;
        textEditModalBody.innerHTML = `<div class="form-group"><label for="modal-text-content">内容:</label><textarea id="modal-text-content" rows="3">${textItem.text}</textarea></div><div class="form-group"><label for="modal-text-color">文字色:</label><input type="color" id="modal-text-color" value="${textItem.color}"></div><div class="form-group"><label for="modal-text-bgcolor">背景色:</label><input type="color" id="modal-text-bgcolor" value="${textItem.backgroundColor}"></div><div class="form-group"><label for="modal-text-size">サイズ:</label><input type="number" id="modal-text-size" value="${textItem.fontSize}" min="8"></div><div class="form-group-checkbox"><label for="modal-text-border-visible">枠を表示:</label><input type="checkbox" id="modal-text-border-visible"></div><div class="form-group"><label for="modal-text-rotation">回転角度:</label><input type="number" id="modal-text-rotation" value="${textItem.rotation || 0}" step="1" min="-360" max="360"></div>`;
        document.getElementById('modal-text-border-visible').checked = textItem.borderVisible !== undefined ? textItem.borderVisible : true;
        openModal(textEditModal);
      }
      function openLineStyleEditModal(line) {
        editingLine = line;
        editingUnit = null;
        editingGroup = null;
        editingTextItem = null;
        editingCollectionUnit = null;

        const modal = document.getElementById('unit-edit-modal');
        const modalTitle = document.getElementById('unit-edit-modal-title');
        const modalBody = document.getElementById('unit-edit-modal-body');
        const applyButton = document.getElementById('unit-edit-apply-button');
        const cancelButton = document.getElementById('unit-edit-cancel-button');
        const deleteButton = document.getElementById('unit-edit-delete-button');
        const duplicateButton = document.getElementById('unit-edit-duplicate-button');

        modalTitle.textContent = `接続線スタイル編集 (ID: ${truncateText(line.id, 15)})`;
        modalBody.innerHTML = '';

        // 色選択UI
        const colorGroup = document.createElement('div');
        colorGroup.className = 'form-group';
        const colorLabel = document.createElement('label');
        colorLabel.htmlFor = 'line-edit-color';
        colorLabel.textContent = '線の色:';
        const colorInput = document.createElement('input');
        colorInput.type = 'color';
        colorInput.id = 'line-edit-color';
        colorInput.value = line.color || '#555555'; // 現在の色をセット
        colorGroup.appendChild(colorLabel);
        colorGroup.appendChild(colorInput);
        modalBody.appendChild(colorGroup);

        // 太さ選択UI
        const lineWidthGroup = document.createElement('div');
        lineWidthGroup.className = 'form-group';
        const lineWidthLabel = document.createElement('label');
        lineWidthLabel.htmlFor = 'line-edit-lineWidth';
        lineWidthLabel.textContent = '線の太さ:';
        const lineWidthInput = document.createElement('input');
        lineWidthInput.type = 'number';
        lineWidthInput.id = 'line-edit-lineWidth';
        lineWidthInput.value = line.lineWidth || 10;
        lineWidthInput.min = '1';   // 最小値
        lineWidthInput.max = '50';  // 最大値 (適宜調整)
        lineWidthInput.step = '1';
        lineWidthGroup.appendChild(lineWidthLabel);
        lineWidthGroup.appendChild(lineWidthInput);
        modalBody.appendChild(lineWidthGroup);
        const lineDashGroup = document.createElement('div');
        lineDashGroup.className = 'form-group';
        const lineDashLabel = document.createElement('label');
        lineDashLabel.htmlFor = 'line-edit-dashType';
        lineDashLabel.textContent = '線の種類:';
        const lineDashSelect = document.createElement('select');
        lineDashSelect.id = 'line-edit-dashType';

        const lineTypes = [
          { name: '実線', value: '[]' },
          { name: '破線 (標準)', value: '[15, 10]' },
          { name: '破線 (短め)', value: '[8, 6]' },
          { name: '点線 (標準)', value: '[2, 5]' },
          { name: '点線 (細かめ)', value: '[1, 3]' }
        ];

        lineTypes.forEach(type => {
          const option = document.createElement('option');
          option.value = type.value;
          option.textContent = type.name;
          lineDashSelect.appendChild(option);
        });

        const currentDashArrayString = JSON.stringify(line.dashArray || []);
        lineDashSelect.value = currentDashArrayString;
        if (!lineTypes.some(type => type.value === currentDashArrayString)) {
          lineDashSelect.value = '[]';
        }

        lineDashGroup.appendChild(lineDashLabel);
        lineDashGroup.appendChild(lineDashSelect);
        modalBody.appendChild(lineDashGroup);

        if (duplicateButton) {
          duplicateButton.style.display = 'none';
        }
        if (deleteButton) {
          deleteButton.style.display = 'inline-block';
          deleteButton.textContent = '接続線削除';
        }
        if (applyButton) applyButton.style.display = 'inline-block';
        if (cancelButton) cancelButton.style.display = 'inline-block';


        openModal(modal);
      }

      function createGroupFromSelection() {
        if (itemsToGroup.length < 2) return; let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        const groupUnitIds = []; let canGroup = true; let firstItemGroupId = null; let allFromSameGroup = true;
        for (const item of itemsToGroup) {
          if (item.type !== 'unit' && item.type !== 'image-collection' && item.type !== 'text') { showStatusBar("グループ化はユニット系のみ", currentModeButtonElement); canGroup = false; break; }
          const containingGroup = groups.find(g => g.itemIds.includes(item.id));
          if (itemsToGroup.length > 1) { if (firstItemGroupId === null && containingGroup) firstItemGroupId = containingGroup.id; else if (containingGroup?.id !== firstItemGroupId) allFromSameGroup = false; else if (!containingGroup && firstItemGroupId !== null) allFromSameGroup = false; }
          groupUnitIds.push(item.id); minX = Math.min(minX, item.x); minY = Math.min(minY, item.y); maxX = Math.max(maxX, item.x + item.width); maxY = Math.max(maxY, item.y + item.height);
        }
        if (!canGroup) { itemsToGroup = []; drawCanvas(); return; }
        const selectedUnitsAreAllUngrouped = itemsToGroup.every(item => !groups.some(g => g.itemIds.includes(item.id)));
        const selectedUnitsAreAllFromTheSameExistingGroup = firstItemGroupId !== null && allFromSameGroup && itemsToGroup.every(item => groups.find(g => g.itemIds.includes(item.id))?.id === firstItemGroupId);
        if (!selectedUnitsAreAllUngrouped && !selectedUnitsAreAllFromTheSameExistingGroup) { showStatusBar("異なるグループや内外混在は不可", currentModeButtonElement); itemsToGroup = []; drawCanvas(); return; }
        if (selectedUnitsAreAllFromTheSameExistingGroup) { showStatusBar("既に同じグループ", currentModeButtonElement); itemsToGroup = []; drawCanvas(); return; }
        const groupX = minX - GROUP_PADDING; const groupY = minY - GROUP_PADDING;
        const groupWidth = (maxX - minX) + GROUP_PADDING * 2; const groupHeight = (maxY - minY) + GROUP_PADDING * 2;
        const newGroup = { id: `item-${nextItemId++}`, type: 'group', itemIds: groupUnitIds, x: groupX, y: groupY, width: groupWidth, height: groupHeight, name: '', isSelected: false, borderVisible: true };
        groups.push(newGroup); itemsToGroup = []; saveState(); drawCanvas(); showStatusBar("グループ作成完了", currentModeButtonElement);
      }

      function updateInfoModal() {
        const cropCounts = {
          'いちご': 0, 'にがうり': 0, 'とうがらし': 0,
          'バナナ': 0, 'レモン': 0, 'ぶどう': 0, 'かき': 0
        };
        let totalUnitImagesWithFoodSlot = 0; // 好物スロットを持つ可能性のあるユニット内の総画像数
        let birthImagesCount = 0;
        let baseUnitCountWithoutFavFood = 0;

        units.forEach(unit => {
          let isBaseUnitForThisUnit = false;
          let unitHasAnyFavoriteFoodActuallySet = false;

          if (unit.type === 'image-collection') {
            if (unit.images) {
              unit.images.forEach(imgInfo => {
                totalUnitImagesWithFoodSlot++;
                if (imgInfo.food && imgInfo.food !== '未選択' && cropCounts.hasOwnProperty(imgInfo.food)) {
                  cropCounts[imgInfo.food]++;
                  unitHasAnyFavoriteFoodActuallySet = true;
                }
              });
            }
          } else if (unit.type === 'unit') {
            const parents = getDirectParentsStrictRule(unit.id);
            if (parents.length === 0 && unit.activeSlotKeys && unit.activeSlotKeys.length > 0) {
              isBaseUnitForThisUnit = true;
            }

            Object.entries(unit.slots).forEach(([slotKey, slotData]) => {
              if (slotData) {
                if (slotData.img || slotData.imgDataUrl) {
                  totalUnitImagesWithFoodSlot++;
                  if (slotKey === 'birth') birthImagesCount++;
                }
                if (slotData.food && slotData.food !== '未選択' && cropCounts.hasOwnProperty(slotData.food)) {
                  cropCounts[slotData.food]++;
                  unitHasAnyFavoriteFoodActuallySet = true;
                }
              }
            });

            if (isBaseUnitForThisUnit && !unitHasAnyFavoriteFoodActuallySet) {
              baseUnitCountWithoutFavFood++;
              console.log(`[InfoModal] Base unit ${getItemDisplayName(unit)} has no favorite food set. Counting for default seed cost.`);
            }
          }
        });

        requiredCropsList.innerHTML = '';
        let hasAnyCropRequirement = false;
        Object.entries(cropCounts).forEach(([food, count]) => {
          if (count > 0) {
            hasAnyCropRequirement = true;
            const li = document.createElement('li');
            li.className = 'crop-list-item';
            const dot = document.createElement('span');
            dot.className = 'crop-color-dot';
            dot.style.backgroundColor = cropColors[food] || '#ccc';
            li.appendChild(dot);
            li.appendChild(document.createTextNode(`${food}: ${count}個`));
            requiredCropsList.appendChild(li);
          }
        });
        if (!hasAnyCropRequirement) {
          requiredCropsList.innerHTML = '<li><small>好物は設定されていません。</small></li>';
        }
        // --- ここまで「必要作物」リスト表示 ---


        // --- ゴールド計算 ---
        let totalSetFavoriteFoodItems = 0;
        for (const food in cropCounts) {
          totalSetFavoriteFoodItems += cropCounts[food];
        }

        // 1. 実際に好物が設定されている分の必要種数とコスト
        const seedsForSetFavorites = totalSetFavoriteFoodItems * 7; // 各7個必要
        const seedPricePerOne = 150; // 1個あたりの種の値段
        const costForSetFavoritesSeeds = seedsForSetFavorites * seedPricePerOne;

        // 2. 好物未設定の基本ユニット分のデフォルト種コスト (各ユニットにつき7個 * 150G)
        const costForDefaultBaseUnitSeeds = baseUnitCountWithoutFavFood * 7 * seedPricePerOne;

        // 総作物の種コスト
        const totalCropSeedCost = costForSetFavoritesSeeds + costForDefaultBaseUnitSeeds;
        const totalSeedsCalculated = seedsForSetFavorites + (baseUnitCountWithoutFavFood * 7);
        const limitBreakCost = totalUnitImagesWithFoodSlot * 300;
        const birthEventCost = birthImagesCount * 1000; // 出生スロットを持つ画像数に基づく

        const totalGold = limitBreakCost + birthEventCost + totalCropSeedCost;

        document.getElementById('total-gold-cost').textContent = `${totalGold.toLocaleString()} G`;

        updateRecommendedCaptureOrder();
      }

      function calculateImageCollectionUnitSize(images, layoutSettings = null) {
        console.log("[CalcSize] 開始", "画像数:", images?.length, "渡されたLayoutSettings:", layoutSettings);
        const imageCount = images?.length || 0;

        const defaultLayout = {
          maxSize: COLLECTION_IMAGE_MAX_SIZE, margin: COLLECTION_IMAGE_MARGIN, padding: COLLECTION_PADDING,
          textGap: minTextGapLogical, perRow: COLLECTION_IMAGES_PER_ROW, fontSize: textFontSizeLogical
        };
        // settings オブジェクトの各プロパティが数値であることを保証する
        const getSetting = (key, defaultValue) => {
          let val = (layoutSettings && layoutSettings[key] !== undefined) ? layoutSettings[key] :
            (editingCollectionUnit && editingCollectionUnit.layoutSettings && editingCollectionUnit.layoutSettings[key] !== undefined) ? editingCollectionUnit.layoutSettings[key] :
              defaultValue;
          const numVal = parseInt(val, 10); // 必ず数値に変換
          return isNaN(numVal) ? defaultValue : numVal; // NaNならデフォルト
        };

        const settings = {
          maxSize: getSetting('maxSize', COLLECTION_IMAGE_MAX_SIZE),
          margin: getSetting('margin', COLLECTION_IMAGE_MARGIN),
          padding: getSetting('padding', COLLECTION_PADDING),
          textGap: getSetting('textGap', minTextGapLogical),
          perRow: getSetting('perRow', COLLECTION_IMAGES_PER_ROW),
          fontSize: getSetting('fontSize', textFontSizeLogical)
        };
        console.log("[CalcSize] 使用するSettings:", JSON.parse(JSON.stringify(settings)));


        const logicalPadding = settings.padding;
        const logicalImageMaxSize = settings.maxSize;
        const baseLogicalImageMargin = settings.margin;
        let logicalImagesPerRow = settings.perRow;
        const textFontSizeLogicalValue = settings.fontSize;
        const minTextGapLogicalValue = settings.textGap;
        const textLineHeightLogical = SLOT_TEXT_LINE_HEIGHT_BASE * TEXT_LINE_HEIGHT_MULTIPLIER;
        const imageTextPaddingLogical = IMAGE_TEXT_PADDING;

        if (imageCount === 0) {
          console.log("[CalcSize] 画像0枚 -> デフォルト最小サイズ返却");
          return { width: logicalPadding * 2 + logicalImageMaxSize, height: logicalPadding * 2 + logicalImageMaxSize };
        }

        if (isNaN(logicalImagesPerRow) || logicalImagesPerRow <= 0) {
          console.warn(`[CalcSize] 不正な logicalImagesPerRow (${settings.perRow}) -> デフォルト ${COLLECTION_IMAGES_PER_ROW} 使用`);
          logicalImagesPerRow = COLLECTION_IMAGES_PER_ROW;
        }
        if (logicalImagesPerRow === 0) { // 0除算を避ける
          console.error("[CalcSize] logicalImagesPerRow が0です。デフォルト1を使用します。");
          logicalImagesPerRow = 1;
        }


        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        if (!tempCtx) {
          console.error("[CalcSize] 一時Canvasコンテキスト作成失敗。固定サイズ返却。");
          return { width: 200, height: 150 };
        }
        const fontForMeasure = `${textFontSizeLogicalValue}px ${DEFAULT_FONT}`;
        tempCtx.font = fontForMeasure;
        console.log("[CalcSize] テキスト幅測定用フォント:", fontForMeasure);

        const imageTextWidths = images.map((imgData, idx) => {
          let maxWidth = 0;
          if (imgData.name) {
            const nameWidth = tempCtx.measureText(imgData.name).width;
            maxWidth = Math.max(maxWidth, isNaN(nameWidth) ? 0 : nameWidth);
          }
          if (imgData.food && imgData.food !== '未選択') {
            const foodWidth = tempCtx.measureText('好物:' + imgData.food).width;
            maxWidth = Math.max(maxWidth, isNaN(foodWidth) ? 0 : foodWidth);
          }
          return maxWidth;
        });
        console.log("[CalcSize] 計算された全テキスト幅:", imageTextWidths);


        const hasTextInfo = imageTextWidths.some(width => width > 0);
        const textHeightPerImage = hasTextInfo ? (textLineHeightLogical * 2) + imageTextPaddingLogical : 0;
        const numRows = Math.ceil(imageCount / logicalImagesPerRow);
        console.log(`[CalcSize] 計算された行数 (numRows): ${numRows}`);


        let maxRowOccupiedWidthLogical = 0;
        for (let r = 0; r < numRows; r++) {
          let currentRowContentWidthLogical = 0;
          let currentRowMarginWidthLogical = 0;
          const startIndex = r * logicalImagesPerRow;
          const endIndex = Math.min(startIndex + logicalImagesPerRow, imageCount);
          const imagesInThisRow = endIndex - startIndex;

          for (let i = 0; i < imagesInThisRow; i++) {
            currentRowContentWidthLogical += logicalImageMaxSize;
            if (i > 0) {
              const prevImageIndex = startIndex + i - 1;
              const currentImageIndex = startIndex + i;
              const prevTextW = imageTextWidths[prevImageIndex] || 0;
              const currentTextW = imageTextWidths[currentImageIndex] || 0;
              const neededSpaceForText = (prevTextW / 2) + (currentTextW / 2) + minTextGapLogicalValue;
              const marginToUse = Math.max(baseLogicalImageMargin, (isNaN(neededSpaceForText) ? 0 : neededSpaceForText));
              currentRowMarginWidthLogical += marginToUse;
            }
          }
          currentRowContentWidthLogical += currentRowMarginWidthLogical;

          let requiredLeftPadding = logicalPadding;
          let requiredRightPadding = logicalPadding;
          if (imagesInThisRow > 0) {
            const firstImageIndex = startIndex;
            const lastImageIndex = endIndex - 1;
            const firstImageTextWidth = imageTextWidths[firstImageIndex] || 0;
            const lastImageTextWidth = imageTextWidths[lastImageIndex] || 0;
            requiredLeftPadding = Math.max(logicalPadding, firstImageTextWidth / 2);
            requiredRightPadding = Math.max(logicalPadding, lastImageTextWidth / 2);
          }
          const currentRowOccupiedWidth = requiredLeftPadding + currentRowContentWidthLogical + requiredRightPadding;
          maxRowOccupiedWidthLogical = Math.max(maxRowOccupiedWidthLogical, currentRowOccupiedWidth);
        }
        console.log("[CalcSize] 最大行占有幅(論理):", maxRowOccupiedWidthLogical);

        const unitWidth = maxRowOccupiedWidthLogical;
        const contentHeight = (numRows * logicalImageMaxSize) + (Math.max(0, numRows - 1) * baseLogicalImageMargin) + (numRows * textHeightPerImage);
        const unitHeight = contentHeight + (logicalPadding * 2);
        const minHeightBase = logicalPadding * 2 + logicalImageMaxSize;
        const minHeightWithText = hasTextInfo ? minHeightBase + textHeightPerImage : minHeightBase;
        const minWidthBase = logicalPadding * 2 + logicalImageMaxSize;

        let finalWidth = Math.max(unitWidth, minWidthBase);
        let finalHeight = Math.max(unitHeight, minHeightWithText);

        if (isNaN(finalWidth) || finalWidth <= 0) {
          console.error(`[CalcSize] finalWidth が不正 (${finalWidth})。デフォルト幅200を使用します。`);
          finalWidth = 200;
        }
        if (isNaN(finalHeight) || finalHeight <= 0) {
          console.error(`[CalcSize] finalHeight が不正 (${finalHeight})。デフォルト高150を使用します。`);
          finalHeight = 150;
        }
        console.log(`[CalcSize] 結果: width=${finalWidth}, height=${finalHeight}`);
        return {
          width: finalWidth,
          height: finalHeight
        };
      }

      function drawImagesInCollectionUnit(targetCtx, unit, currentScale = 1, layoutSettings = null) {
        const images = unit.images || [];
        if (images.length === 0) {
          return;
        }

        // --- 設定値取得 ---
        const settings = layoutSettings || unit.layoutSettings || {
          maxSize: COLLECTION_IMAGE_MAX_SIZE, margin: COLLECTION_IMAGE_MARGIN, padding: COLLECTION_PADDING,
          textGap: minTextGapLogical, perRow: COLLECTION_IMAGES_PER_ROW, fontSize: textFontSizeLogical
        };

        const logicalPadding = settings.padding;
        const logicalImageMaxSize = settings.maxSize;
        const baseLogicalImageMargin = settings.margin;
        let logicalImagesPerRow = settings.perRow;
        const textFontSizeLogicalValue = settings.fontSize;
        const minTextGapLogicalValue = settings.textGap;
        const textLineHeightLogical = SLOT_TEXT_LINE_HEIGHT_BASE * TEXT_LINE_HEIGHT_MULTIPLIER;
        const imageTextPaddingLogical = IMAGE_TEXT_PADDING;

        // logicalImagesPerRow バリデーション
        if (isNaN(logicalImagesPerRow) || logicalImagesPerRow <= 0) {
          logicalImagesPerRow = COLLECTION_IMAGES_PER_ROW;
        }

        // --- テキスト幅測定 (tempCtxを使用) ---
        let textMeasurementCtx = null;
        try {
          const tempCanvas = document.createElement('canvas');
          textMeasurementCtx = tempCanvas.getContext('2d');
        } catch (e) {
          console.error("drawImagesInCollectionUnit: 一時Canvasコンテキストの作成に失敗:", e);
        }

        const imageTextWidthsForDrawing = images.map((imgData, idx) => {
          if (!textMeasurementCtx) return 0;
          let mW = 0;
          try {
            textMeasurementCtx.font = `${textFontSizeLogicalValue}px ${DEFAULT_FONT}`;
            if (imgData.name) mW = Math.max(mW, textMeasurementCtx.measureText(truncateText(imgData.name, 8)).width);
            if (imgData.food && imgData.food !== '未選択') mW = Math.max(mW, textMeasurementCtx.measureText(truncateText('好物:' + imgData.food, 10)).width);
            if (isNaN(mW)) return 0;
          } catch (e) { return 0; } return mW;
        });

        const hasTextInfo = imageTextWidthsForDrawing.some(w => w > 0);
        const textHeightPerImage = hasTextInfo ? (textLineHeightLogical * 2) + imageTextPaddingLogical : 0;
        const numRows = Math.ceil(images.length / logicalImagesPerRow);
        if (isNaN(numRows) || numRows <= 0) { /* console.error("行数不正"); */ return; }

        let currentY_logical = logicalPadding;

        for (let r = 0; r < numRows; r++) {
          const startIndex = r * logicalImagesPerRow;
          const endIndex = Math.min(startIndex + logicalImagesPerRow, images.length);
          const imagesInThisRow = endIndex - startIndex;

          let currentRowContentWidthLogical = 0;
          let requiredMarginsWidthLogical = 0;
          let dynamicMargins = [];
          for (let i = 0; i < imagesInThisRow; i++) {
            currentRowContentWidthLogical += logicalImageMaxSize;
            if (i > 0) {
              const prevImageIndex = startIndex + i - 1;
              const currentImageIndex = startIndex + i;
              const prevW = imageTextWidthsForDrawing[prevImageIndex] === undefined ? 0 : imageTextWidthsForDrawing[prevImageIndex];
              const currW = imageTextWidthsForDrawing[currentImageIndex] === undefined ? 0 : imageTextWidthsForDrawing[currentImageIndex];
              const gap = isNaN(minTextGapLogicalValue) ? 4 : minTextGapLogicalValue;
              const baseM = isNaN(baseLogicalImageMargin) ? 5 : baseLogicalImageMargin;
              const needed = (prevW / 2) + (currW / 2) + gap;
              const margin = Math.max(baseM, (isNaN(needed) ? 0 : needed));
              requiredMarginsWidthLogical += margin;
              dynamicMargins.push(margin);
            }
          }
          currentRowContentWidthLogical += requiredMarginsWidthLogical;

          const logicalDrawableUnitWidth = unit.width - (logicalPadding * 2);
          let startX_L = logicalPadding + (logicalDrawableUnitWidth - currentRowContentWidthLogical) / 2;
          if (startX_L < logicalPadding) startX_L = logicalPadding;

          let currentX_L = startX_L;
          for (let i = 0; i < imagesInThisRow; i++) {
            const currentImageDrawIndex = startIndex + i;

            const imgData = images[currentImageDrawIndex];
            const imgObject = imgData.img;

            if (imgObject && imgObject.complete && imgObject.naturalWidth > 0) {
              try {
                let dWL, dHL; const ar = imgObject.naturalWidth / imgObject.naturalHeight;
                if (ar >= 1) { dWL = logicalImageMaxSize; dHL = dWL / ar; } else { dHL = logicalImageMaxSize; dWL = dHL * ar; }
                if (dHL > logicalImageMaxSize) { dHL = logicalImageMaxSize; dWL = dHL * ar; }
                if (dWL > logicalImageMaxSize) { dWL = logicalImageMaxSize; dHL = dWL / ar; }
                const offX = (logicalImageMaxSize - dWL) / 2, offY = (logicalImageMaxSize - dHL) / 2;
                targetCtx.drawImage(imgObject, currentX_L + offX, currentY_logical + offY, dWL, dHL);
              } catch (e) {
                const errBoxSizeL = logicalImageMaxSize; targetCtx.strokeStyle = 'red';
                targetCtx.lineWidth = 1 / currentScale; targetCtx.strokeRect(currentX_L, currentY_logical, errBoxSizeL, errBoxSizeL);
                console.error(`drawImagesInCollectionUnit 画像 ${currentImageDrawIndex}: drawImage中にエラー`, e);
              }
            } else {
              const pSizeL = logicalImageMaxSize; targetCtx.fillStyle = '#e0e0e0';
              targetCtx.fillRect(currentX_L, currentY_logical, pSizeL, pSizeL);
              targetCtx.fillStyle = '#a0a0a0'; targetCtx.font = `${textFontSizeLogicalValue / currentScale}px ${DEFAULT_FONT}`;
              targetCtx.textAlign = 'center'; targetCtx.textBaseline = 'middle';
              targetCtx.fillText('N/A', currentX_L + pSizeL / 2, currentY_logical + pSizeL / 2);
            }

            if (imgData.name || (imgData.food && imgData.food !== '未選択')) {
              targetCtx.fillStyle = '#333'; targetCtx.font = `${textFontSizeLogicalValue / currentScale}px ${DEFAULT_FONT}`;
              targetCtx.textAlign = 'center'; targetCtx.textBaseline = 'top';
              const tStartX_L = currentX_L + logicalImageMaxSize / 2; let tStartY_L = currentY_logical + logicalImageMaxSize + imageTextPaddingLogical;
              const uBY = unit.height - logicalPadding;
              if (imgData.name) { if ((tStartY_L + textLineHeightLogical) <= uBY) targetCtx.fillText(truncateText(imgData.name, 8), tStartX_L, tStartY_L); tStartY_L += textLineHeightLogical; }
              if (imgData.food && imgData.food !== '未選択') { if ((tStartY_L + textLineHeightLogical) <= uBY) targetCtx.fillText(truncateText('好物:' + imgData.food, 10), tStartX_L, tStartY_L); }
            }

            if (i < imagesInThisRow - 1) {
              const mTU = dynamicMargins[i];
              if (isNaN(mTU)) currentX_L += logicalImageMaxSize + baseLogicalImageMargin;
              else currentX_L += logicalImageMaxSize + mTU;
            } else {
              // console.log(`      行 ${r} の最後の画像 (${currentImageDrawIndex})`); // デバッグ用
            }
          }

          currentY_logical += logicalImageMaxSize + textHeightPerImage + baseLogicalImageMargin;
        }
      }

      function drawImageCollectionForSave(targetContext, unit) {
        targetContext.save();
        targetContext.translate(unit.x, unit.y);
        if (unit.borderVisible) {
          targetContext.strokeStyle = '#4caf50'; targetContext.lineWidth = 2;
          targetContext.fillStyle = 'rgba(240, 240, 240, 0.8)';
          drawRoundedRect(targetContext, 0, 0, unit.width, unit.height, 8);
          targetContext.fill(); targetContext.stroke();
        }
        drawImagesInCollectionUnit(targetContext, unit, 1, unit.layoutSettings);
        targetContext.restore();
      }
      function getItemDisplayName(item) {
        if (!item) return 'アイテム';
        if (item.type === 'unit') return item.slots.birth?.name || item.slots.qr1?.name || item.slots.qr2?.name || 'ユニット';
        if (item.type === 'group') return item.name || 'グループ';
        if (item.type === 'text') return truncateText(item.text, 10) || 'テキスト';
        if (item.type === 'image-collection') return item.name || `画像集合 (${item.images?.length || 0}枚)`;
        return 'アイテム';
      }

      function openImageCollectionEditModal(unit) {
        editingCollectionUnit = unit;
        collectionEditModalTitle.textContent = `画像集合編集: ${truncateText(getItemDisplayName(unit), 20)}`;
        collectionEditNameInput.value = unit.name || '';
        collectionEditBorderCheckbox.checked = unit.borderVisible !== undefined ? unit.borderVisible : true;
        collectionEditImageCount.textContent = unit.images?.length || 0;
        if (!unit.layoutSettings) {
          unit.layoutSettings = {
            maxSize: COLLECTION_IMAGE_MAX_SIZE, margin: COLLECTION_IMAGE_MARGIN, padding: COLLECTION_PADDING,
            textGap: minTextGapLogical, perRow: COLLECTION_IMAGES_PER_ROW, fontSize: textFontSizeLogical
          };
        }
        document.getElementById('collection-edit-max-size').value = unit.layoutSettings.maxSize;
        document.getElementById('collection-edit-margin').value = unit.layoutSettings.margin;
        document.getElementById('collection-edit-padding').value = unit.layoutSettings.padding;
        document.getElementById('collection-edit-text-gap').value = unit.layoutSettings.textGap;
        document.getElementById('collection-edit-per-row').value = unit.layoutSettings.perRow;
        document.getElementById('collection-edit-font-size').value = unit.layoutSettings.fontSize;
        const layoutDetails = document.getElementById('collection-layout-settings');
        if (layoutDetails) layoutDetails.open = false;
        collectionEditImageList.innerHTML = '';
        if (unit.images && unit.images.length > 0) {
          unit.images.forEach((imgData, index) => {
            const listItem = document.createElement('li');
            listItem.dataset.originalIndex = index; listItem.draggable = true;
            addDragDropListeners(listItem);
            const imgElement = document.createElement('img'); imgElement.id = `collection-edit-img-${index}`;
            imgElement.src = imgData.imgDataUrl || 'https://placehold.co/40x40/eee/ccc?text=N/A';
            imgElement.alt = imgData.fileName || '画像プレビュー'; listItem.appendChild(imgElement);
            const detailsDiv = document.createElement('div'); detailsDiv.className = 'image-details';
            const fileNameP = document.createElement('p'); fileNameP.textContent = `ファイル: ${truncateText(imgData.fileName || '不明', 25)}`; detailsDiv.appendChild(fileNameP);
            const nameGroup = document.createElement('div'); nameGroup.className = 'detail-form-group';
            const nameLabel = document.createElement('label'); nameLabel.textContent = '名前:';
            const nameInput = document.createElement('input'); nameInput.type = 'text'; nameInput.value = imgData.name || ''; nameInput.maxLength = 10; nameInput.placeholder = '名前(任意)'; nameInput.dataset.field = 'name';
            nameGroup.appendChild(nameLabel); nameGroup.appendChild(nameInput); detailsDiv.appendChild(nameGroup);
            const foodGroup = document.createElement('div'); foodGroup.className = 'detail-form-group';
            const foodLabel = document.createElement('label'); foodLabel.textContent = '好物:';
            const foodSelect = document.createElement('select'); foodSelect.dataset.field = 'food';
            ['未選択', 'いちご', 'にがうり', 'とうがらし', 'バナナ', 'レモン', 'ぶどう', 'かき'].forEach(food => { const opt = document.createElement('option'); opt.value = food; opt.textContent = food === '未選択' ? '選択(任意)' : food; foodSelect.appendChild(opt); });
            foodSelect.value = imgData.food || '未選択';
            foodGroup.appendChild(foodLabel); foodGroup.appendChild(foodSelect); detailsDiv.appendChild(foodGroup);
            listItem.appendChild(detailsDiv);
            const editImageBtn = document.createElement('button'); editImageBtn.textContent = '編集';
            editImageBtn.title = 'この画像を編集'; editImageBtn.style.cssText = 'font-size:0.75em;padding:2px 6px;margin-left:5px;';
            editImageBtn.onclick = () => {
              currentImageSlotKeyForEditing = null; currentEditingUnitContext = 'collection-edit-modal'; editingCollectionImageIndex = index;
              const urlToEdit = imgData.originalDataUrl || imgData.imgDataUrl;
              if (urlToEdit) {
                imageToCrop.src = urlToEdit; openModal(cropperModal); if (cropper) cropper.destroy();
                aspectRatioSelect.value = "NaN";
                cropper = new Cropper(imageToCrop, { aspectRatio: NaN, viewMode: 1, background: false, zoomable: true, movable: true, cropBoxResizable: true, dragMode: 'move' });
                currentCropFinalizeCallback = (croppedDataUrl) => {
                  const targetImageIndex = editingCollectionImageIndex;
                  if (editingCollectionUnit && editingCollectionUnit.images[targetImageIndex]) {
                    const targetImgData = editingCollectionUnit.images[targetImageIndex]; const img = new Image();
                    img.onload = () => {
                      targetImgData.img = img; targetImgData.imgDataUrl = croppedDataUrl;
                      if (!targetImgData.originalDataUrl) targetImgData.originalDataUrl = urlToEdit;
                      const previewInModal = document.getElementById(`collection-edit-img-${targetImageIndex}`);
                      if (previewInModal) previewInModal.src = croppedDataUrl;
                      closeCropperModal();
                    };
                    img.onerror = () => { console.error("編集後画像の読み込みエラー:", targetImageIndex); closeCropperModal(); };
                    img.src = croppedDataUrl;
                  } else { console.error("編集対象の画像データが見つかりません:", targetImageIndex); closeCropperModal(); }
                };
              } else { alert('編集可能な画像データが見つかりません。'); }
            }; listItem.appendChild(editImageBtn);
            const deleteBtn = document.createElement('button'); deleteBtn.innerHTML = '&times;'; deleteBtn.title = 'この画像を削除リストに追加'; deleteBtn.className = 'delete-image-btn';
            deleteBtn.onclick = () => {
              if (listItem.dataset.deleted === 'true') {
                if (confirm(`画像「${imgData.fileName || '選択画像'}」の削除を取り消しますか？`)) {
                  listItem.style.opacity = '1'; listItem.style.textDecoration = 'none'; listItem.dataset.deleted = 'false';
                  const currentCount = parseInt(collectionEditImageCount.textContent, 10) + 1;
                  collectionEditImageCount.textContent = currentCount;
                }
              } else {
                if (confirm(`画像「${imgData.fileName || '選択画像'}」を削除リストに追加しますか？ (適用ボタンで削除)`)) {
                  listItem.style.opacity = '0.5'; listItem.style.textDecoration = 'line-through'; listItem.dataset.deleted = 'true';
                  const currentCount = parseInt(collectionEditImageCount.textContent, 10) - 1;
                  collectionEditImageCount.textContent = Math.max(0, currentCount);
                }
              }
            }; listItem.appendChild(deleteBtn);
            collectionEditImageList.appendChild(listItem);
          });
        } else { collectionEditImageList.innerHTML = '<li>画像がありません。</li>'; }
        openModal(collectionEditModal);
      }

      function addDragDropListeners(item) { item.addEventListener('dragstart', handleDragStart); item.addEventListener('dragover', handleDragOver); item.addEventListener('dragenter', handleDragEnter); item.addEventListener('dragleave', handleDragLeave); item.addEventListener('drop', handleDrop); item.addEventListener('dragend', handleDragEnd); }
      function handleDragStart(e) { draggedItem = this; e.dataTransfer.effectAllowed = 'move'; setTimeout(() => this.classList.add('dragging'), 0); }
      function handleDragOver(e) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; return false; }
      function handleDragEnter(e) { if (draggedItem !== this) this.style.borderTop = '2px dashed blue'; }
      function handleDragLeave(e) { this.style.borderTop = ''; }
      function handleDrop(e) { e.stopPropagation(); if (draggedItem !== this) { const list = collectionEditImageList; const items = Array.from(list.children); const dragIdx = items.indexOf(draggedItem); const dropIdx = items.indexOf(this); if (dragIdx < dropIdx) list.insertBefore(draggedItem, this.nextSibling); else list.insertBefore(draggedItem, this); } this.style.borderTop = ''; return false; }
      function handleDragEnd(e) { collectionEditImageList.querySelectorAll('li').forEach(item => { item.classList.remove('dragging'); item.style.borderTop = ''; }); draggedItem = null; }

      function getResizeCursor(handle) {
        switch (handle) {
          case 'bottom-right': case 'top-left': return 'nwse-resize';
          case 'bottom-left': case 'top-right': return 'nesw-resize';
          case 'right': case 'left': return 'ew-resize';
          case 'bottom': case 'top': return 'ns-resize';
          default: return 'grab'; // デフォルトは掴むカーソル
        }
      }
      function updateFillOptionVisibility() {
        if (drawingFillGroup && drawingShapeSelect) {
          const shape = drawingShapeSelect.value;
          if (shape === 'rectangle' || shape === 'circle') {
            drawingFillGroup.style.display = 'flex';
          } else {
            drawingFillGroup.style.display = 'none';
          }
        }
      }
      function getDirectParents(childId, visitedConnections = new Set()) {
        console.log(`[getDirectParents] Called for childId: ${childId}`);
        const directParentUnits = new Set();

        // 1. childId (ユニット) に直接接続している接続を探す
        for (const conn of connections) {
          if (visitedConnections.has(conn.id)) continue;

          // パターンA: 親ユニット → 子ユニット (通常の接続)
          if (conn.toId === childId && !conn.fromId.startsWith('conn-')) {
            const parentUnit = findItemById(conn.fromId);
            if (parentUnit && (parentUnit.type === 'unit' || parentUnit.type === 'image-collection')) {
              directParentUnits.add(parentUnit);
              console.log(`  [GDP] Found direct parent (U→U): ${getItemDisplayName(parentUnit)} for child ${childId}`);
            }
          }
          // パターンB: 子ユニットが「線からユニットへの接続」の終点になっている
          // (つまり、ある線の中点からこの子ユニットへ線が引かれている)
          // conn = { id: 'conn-幹', fromId: 'conn-枝のID', toId: childId, isLineToUnit: true }
          else if (conn.toId === childId && conn.fromId.startsWith('conn-') && conn.isLineToUnit) {
            const branchLineId = conn.fromId; // T字の「枝」となる元の線のID
            const branchLine = connections.find(c => c.id === branchLineId);
            if (branchLine) {
              const parent1 = findItemById(branchLine.fromId);
              const parent2 = findItemById(branchLine.toId);
              if (parent1 && (parent1.type === 'unit' || parent1.type === 'image-collection')) {
                directParentUnits.add(parent1);
                console.log(`  [GDP] Found parent via T-branch (L→U, branch P1): ${getItemDisplayName(parent1)} for child ${childId}`);
              }
              if (parent2 && (parent2.type === 'unit' || parent2.type === 'image-collection')) {
                directParentUnits.add(parent2);
                console.log(`  [GDP] Found parent via T-branch (L→U, branch P2): ${getItemDisplayName(parent2)} for child ${childId}`);
              }
              visitedConnections.add(branchLine.id);
            } else {
              console.warn(`  [GDP] For L→U connection ${conn.id}, branch line ${branchLineId} not found.`);
            }
          }
          // パターンC: 子ユニットが「ユニットから線への接続」の始点になっている (これは親子関係ではない)
          // if (conn.fromId === childId && conn.toId.startsWith('conn-') && conn.isUnitToLine) {
          //   このユニットはT字の「枝」の一部であり、この接続自体は親を示さない
          // }

          visitedConnections.add(conn.id);
        }

        // 補足：ケース3のような、子が枝の先にあり、別のユニットが幹として接続している場合、
        // その「別のユニット」も親としてカウントするには、さらに複雑な探索が必要。
        // 例えば、子に直接つながる線L1があり、そのL1の中点に別のユニットP2から線L2がつながっている場合。
        // この場合、L1のfromIdであるP1はパターンAで検出される。
        // P2を検出するには、L1 (conn.id) をtoIdとして持つ isUnitToLine の接続を探す。
        for (const conn_L1 of connections.filter(c => c.toId === childId && !c.fromId.startsWith('conn-'))) {
          for (const conn_L2 of connections.filter(c => c.toId === conn_L1.id && c.isUnitToLine && !c.fromId.startsWith('conn-'))) {
            const otherParent = findItemById(conn_L2.fromId);
            if (otherParent && (otherParent.type === 'unit' || otherParent.type === 'image-collection')) {
              directParentUnits.add(otherParent);
              console.log(`  [GDP] Found other T-branch parent (U→L to L1): ${getItemDisplayName(otherParent)} for child ${childId}`);
            }
          }
        }


        const parentObjects = Array.from(directParentUnits);
        console.log(`[getDirectParents] Returning for ${childId}:`, parentObjects.map(p => getItemDisplayName(p)));
        return parentObjects;
      }



      function buildCaptureListRecursive(currentUnit, rolePath, isSakiBranchPrimary, captureList, visitedUnits = new Set(), targetIndividualId = null) {
        if (!currentUnit) {
          console.warn(`[BCR] currentUnit is null for rolePath: ${rolePath}`);
          return;
        }
        if (visitedUnits.has(currentUnit.id)) {
          return;
        }
        if (targetIndividualId && currentUnit.id === targetIndividualId) {
          console.log(`  [BCR] Encountered target individual itself: ${getItemDisplayName(currentUnit)}. Will trace its parents if any.`);
          visitedUnits.add(currentUnit.id);
        } else {
          visitedUnits.add(currentUnit.id);
          console.log(`[buildCaptureListRecursive] Processing: ${getItemDisplayName(currentUnit)}, RolePath: "${rolePath}", isSakiBranchPrimary: ${isSakiBranchPrimary}`);
        }

        const parents = getDirectParentsStrictRule(currentUnit.id);
        console.log(`  Parents of ${getItemDisplayName(currentUnit)}:`, parents.map(p => getItemDisplayName(p)));

        if (parents.length === 0) {
          if (targetIndividualId && currentUnit.id === targetIndividualId) {
            console.log(`  [BCR] Target individual ${getItemDisplayName(currentUnit)} is a base unit. Not adding to capture list.`);
          } else {
            console.log(`  [BCR] ${getItemDisplayName(currentUnit)} is a base unit (to be captured via QR).`);
            const qrSlotKey = currentUnit.activeSlotKeys && currentUnit.activeSlotKeys.length > 0 ? currentUnit.activeSlotKeys[0] : null;
            let qrImageUrl = null;
            if (qrSlotKey && currentUnit.slots[qrSlotKey] && currentUnit.slots[qrSlotKey].imgDataUrl) {
              qrImageUrl = currentUnit.slots[qrSlotKey].imgDataUrl;
            } else {
              const firstPopulatedSlot = Object.values(currentUnit.slots).find(s => s && s.imgDataUrl);
              if (firstPopulatedSlot) {
                qrImageUrl = firstPopulatedSlot.imgDataUrl;
                console.log(`    [BCR] Used fallback QR image from a populated slot for ${getItemDisplayName(currentUnit)}`);
              } else {
                console.warn(`    [BCR] No QR image found for base unit ${getItemDisplayName(currentUnit)}`);
              }
            }

            if (qrImageUrl) {
              console.log(`  [BCR] Adding ${getItemDisplayName(currentUnit)} to capture list.`);
              captureList.push({
                unit: currentUnit,
                rolePath: rolePath,
                isMonocolor: currentUnit.isMonocolor === true,
                isSakiBranchPrimary: isSakiBranchPrimary,
                qrImage: qrImageUrl,
                unitName: getItemDisplayName(currentUnit)
              });
            } else {
              console.warn(`  [BCR] Base unit ${getItemDisplayName(currentUnit)} has no QR image to display.`);
            }
          }
          if (!(targetIndividualId && currentUnit.id === targetIndividualId)) {
            visitedUnits.delete(currentUnit.id);
          }
          return;
        }

        let sakiDescendant, atoDescendant;
        if (parents.length === 1) {
          sakiDescendant = parents[0];
          console.warn(`  [BCR] Unit ${getItemDisplayName(currentUnit)} has only one parent according to rule. Processing as saki.`);
        } else if (parents.length >= 2) {
          const sortedParents = [...parents].sort((a, b) => a.x - b.x); // X座標でソート
          sakiDescendant = sortedParents[0];
          atoDescendant = sortedParents[1];
        }

        if (sakiDescendant) {
          buildCaptureListRecursive(sakiDescendant, rolePath + ` -> [先素材]`, isSakiBranchPrimary, captureList, new Set(visitedUnits), targetIndividualId);
        }
        if (atoDescendant) {
          buildCaptureListRecursive(atoDescendant, rolePath + ` -> [後素材]`, false, captureList, new Set(visitedUnits), targetIndividualId);
        }
        if (!(targetIndividualId && currentUnit.id === targetIndividualId)) {
          visitedUnits.delete(currentUnit.id);
        }
      }


      function updateRecommendedCaptureOrder() {
        const displayContent = document.getElementById('recommended-capture-order-content');
        if (!displayContent) { console.error("recommended-capture-order-content not found."); return; }
        displayContent.innerHTML = '';

        const targetIndividual = units.find(u => u.isTargetIndividual === true);
        if (!targetIndividual || !(targetIndividual.type === 'unit' && targetIndividual.activeSlotKeys?.length === 1)) {
          displayContent.innerHTML = '<p>推奨捕獲順を表示するには、画像1枚のユニットを「最終目標個体」に設定してください。</p>';
          return;
        }

        displayContent.innerHTML = `<h4>目標: ${getItemDisplayName(targetIndividual)}</h4>`;

        const { sakiParent, atoParent, birthPartner, error } = determineTargetParentRoles(targetIndividual);

        if (error) {
          displayContent.innerHTML += `<p style="color:red;">エラー: ${error}</p><p><small>家系図の接続やルールを確認してください。</small></p>`;
          return;
        }
        if (!sakiParent || !atoParent) {
          let missingMsg = "";
          if (!sakiParent && !atoParent) missingMsg = "「先」と「後」の両方の親";
          else if (!sakiParent) missingMsg = "「先」の親";
          else missingMsg = "「後」の親";
          displayContent.innerHTML += `<p style="color:orange;">警告: 目標個体の${missingMsg}を特定できませんでした。接続を確認してください。</p>`;
          return;
        }

        displayContent.innerHTML += `<p><b>先の親(系統):</b> ${getItemDisplayName(sakiParent)}, <b>後の親(系統):</b> ${getItemDisplayName(atoParent)}</p>`;
        if (birthPartner) {
          displayContent.innerHTML += `<p><i>出生の相方(参考): ${getItemDisplayName(birthPartner)} (この個体の系統は下記捕獲順には直接反映されません)</i></p>`;
        }

        let sakiBranchCaptureList = [];
        let atoBranchCaptureList = [];

        // buildCaptureListRecursive の呼び出し (targetIndividual.id を渡す)
        if (sakiParent) {
          buildCaptureListRecursive(sakiParent, `[${getItemDisplayName(sakiParent)}系統]`, true, sakiBranchCaptureList, new Set(), targetIndividual.id);
        }
        if (atoParent) {
          buildCaptureListRecursive(atoParent, `[${getItemDisplayName(atoParent)}系統]`, false, atoBranchCaptureList, new Set(), targetIndividual.id);
        }

        // フェーズ分け
        const phase1_saki_mono = sakiBranchCaptureList.filter(item => item.isMonocolor);
        const phase2_saki_gara = sakiBranchCaptureList.filter(item => !item.isMonocolor);
        const phase3_ato_mono = atoBranchCaptureList.filter(item => item.isMonocolor);
        const phase4_ato_gara = atoBranchCaptureList.filter(item => !item.isMonocolor);

        // リスト表示用ヘルパー関数
        const renderCaptureList = (phaseTitle, listItems, phaseNumber) => {
          let html = `<div class="capture-phase capture-phase-${phaseNumber}"><h5>フェーズ${phaseNumber}: ${phaseTitle}</h5>`;
          if (listItems.length === 0) {
            html += "<p><small>該当なし</small></p>";
          } else {
            html += "<ul>";
            listItems.forEach(item => {
              const roleSegments = item.rolePath.split('->');
              const specificRole = roleSegments.length > 1 ? roleSegments[roleSegments.length - 1].trim() : item.rolePath;

              html += `<li>
                    <img src="${item.qrImage}" alt="${item.unitName}" style="width:40px; height:40px; border:1px solid #ddd; background-color:white; object-fit:contain;">
                    <div style="margin-left: 10px; flex-grow:1;">
                        <strong>${item.unitName}</strong>
                        ${item.isMonocolor ? '<span style="color:#e74c3c; font-weight:bold;"> (単色 - SP化注意!)</span>' : '<span style="color:#2ecc71;"> (柄)</span>'}
                        <small style="color:#7f8c8d; display:block; margin-top:2px;">役割: ${specificRole} (元系統: ${roleSegments[0].trim()})</small>
                    </div>
                 </li>`;
            });
            html += "</ul>";
          }
          html += "</div>";
          return html;
        };

        let displayHtml = "";
        displayHtml += renderCaptureList(`「先の親」系統の単色ユニット (最優先)`, phase1_saki_mono, 1);
        displayHtml += renderCaptureList(`「先の親」系統の柄ユニット`, phase2_saki_gara, 2);
        displayHtml += renderCaptureList(`「後の親」系統の単色ユニット`, phase3_ato_mono, 3);
        displayHtml += renderCaptureList(`「後の親」系統の柄ユニット`, phase4_ato_gara, 4);

        if (sakiBranchCaptureList.length === 0 && atoBranchCaptureList.length === 0 && (sakiParent || atoParent)) {
          displayHtml = "<p>親系統は特定できましたが、その先の捕獲対象ユニット(QR)が見つかりませんでした。家系図が末端まで完成し、各ユニットにQR画像が設定されているか確認してください。</p>";
        } else if (displayHtml.trim() === "") {
          displayHtml = "<p>推奨捕獲順を生成できませんでした。設定や家系図の構成を確認してください。</p>";
        }

        displayContent.innerHTML += displayHtml;
        displayContent.innerHTML += "<hr><p><small><b>注意:</b> 上記はSP化リスクを考慮した一般的な育成順です。特定の固定ルートやゲーム内状況により、最適な順番は異なる場合があります。</small></p>";
      }
      function getIntersectionPointWithUnitBoundary(unit, pointP) {
        const unitCenterX = unit.x + unit.width / 2;
        const unitCenterY = unit.y + unit.height / 2;

        // ユニットの中心から点Pへのベクトル
        const dx = pointP.x - unitCenterX;
        const dy = pointP.y - unitCenterY;

        if (dx === 0 && dy === 0) {
          return { x: unitCenterX, y: unitCenterY };
        }

        let t = Infinity;
        let intersectionX = null, intersectionY = null;

        // 上辺との交差チェック (y = unit.y)
        if (dy !== 0) {
          const tEdge = (unit.y - unitCenterY) / dy;
          if (tEdge > 0) {
            const xEdge = unitCenterX + tEdge * dx;
            if (xEdge >= unit.x && xEdge <= unit.x + unit.width) {
              if (tEdge < t) {
                t = tEdge;
                intersectionX = xEdge;
                intersectionY = unit.y;
              }
            }
          }
        }

        // 下辺との交差チェック (y = unit.y + unit.height)
        if (dy !== 0) {
          const tEdge = (unit.y + unit.height - unitCenterY) / dy;
          if (tEdge > 0) {
            const xEdge = unitCenterX + tEdge * dx;
            if (xEdge >= unit.x && xEdge <= unit.x + unit.width) {
              if (tEdge < t) {
                t = tEdge;
                intersectionX = xEdge;
                intersectionY = unit.y + unit.height;
              }
            }
          }
        }

        // 左辺との交差チェック (x = unit.x)
        if (dx !== 0) {
          const tEdge = (unit.x - unitCenterX) / dx;
          if (tEdge > 0) {
            const yEdge = unitCenterY + tEdge * dy;
            if (yEdge >= unit.y && yEdge <= unit.y + unit.height) {
              if (tEdge < t) {
                t = tEdge;
                intersectionX = unit.x;
                intersectionY = yEdge;
              }
            }
          }
        }

        // 右辺との交差チェック (x = unit.x + unit.width)
        if (dx !== 0) {
          const tEdge = (unit.x + unit.width - unitCenterX) / dx;
          if (tEdge > 0) {
            const yEdge = unitCenterY + tEdge * dy;
            if (yEdge >= unit.y && yEdge <= unit.y + unit.height) {
              if (tEdge < t) {
                t = tEdge;
                intersectionX = unit.x + unit.width;
                intersectionY = yEdge;
              }
            }
          }
        }

        if (intersectionX !== null && intersectionY !== null) {
          return { x: intersectionX, y: intersectionY };
        } else {
          console.warn("getIntersectionPointWithUnitBoundary: No intersection found, returning center.", unit, pointP);
          return { x: unitCenterX, y: unitCenterY };
        }
      }
      function getDirectParentsStrictRule(childUnitId) {
        console.log(`[getDirectParentsStrictRule] Called for child: ${childUnitId}`);
        const childUnit = findItemById(childUnitId);
        if (!childUnit) {
          console.warn(`[GDPSR] Child unit ${childUnitId} not found.`);
          return [];
        }

        let parentDefiningConnection = null;
        let connectionToParentStructureId = null;

        // 子ユニットに接続している「幹」の線を見つける
        // isLineToUnit: 親ペア線の中点(from) -> 子ユニット(to)
        // isUnitToLine: 子ユニット(from) -> 親ペア線の中点(to)  (接続方向による)
        for (const conn of connections) {
          if (conn.toId === childUnitId && conn.isLineToUnit && conn.fromId.startsWith('conn-')) {
            parentDefiningConnection = conn;
            connectionToParentStructureId = conn.fromId;
            break;
          }
          // 逆方向の接続も考慮する場合 (ユーザーが子から親ペア線の中点へ引いた場合)
          if (conn.fromId === childUnitId && conn.isUnitToLine && conn.toId.startsWith('conn-')) {
            parentDefiningConnection = conn;
            connectionToParentStructureId = conn.toId;
            break;
          }
        }

        if (!parentDefiningConnection) {
          console.warn(`[GDPSR] No 'trunk' connection found for child ${childUnitId} according to the strict rule (must be L→U or U→L to a line).`);
          const directUnitConnections = connections.filter(c =>
            (c.toId === childUnitId && !c.fromId.startsWith('conn-')) ||
            (c.fromId === childUnitId && !c.toId.startsWith('conn-'))
          );
          if (directUnitConnections.length === 1) {
            console.warn(`[GDPSR] Child ${childUnitId} is connected directly to a single unit via ${directUnitConnections[0].id}. This might be a rule violation or a special case (e.g., topmost unit, or a partner unit). Returning no parents.`);
          } else if (directUnitConnections.length > 1) {
            console.warn(`[GDPSR] Child ${childUnitId} is connected directly to multiple units. Rule violation.`);
          }
          return [];
        }

        console.log(`[GDPSR] Trunk connection for ${childUnitId} is ${parentDefiningConnection.id}. It connects to parent structure (line) ID: ${connectionToParentStructureId}`);

        // 親ペア線を見つける
        const parentPairLine = connections.find(conn => conn.id === connectionToParentStructureId);

        if (!parentPairLine) {
          console.warn(`[GDPSR] Parent pair line with ID ${connectionToParentStructureId} not found for child ${childUnitId}.`);
          return [];
        }

        // 親ペア線の両端のユニットが親
        const parent1 = findItemById(parentPairLine.fromId);
        const parent2 = findItemById(parentPairLine.toId);

        const parentObjects = [];
        if (parent1 && (parent1.type === 'unit' || parent1.type === 'image-collection')) {
          parentObjects.push(parent1);
        } else {
          console.warn(`[GDPSR] Parent1 (ID: ${parentPairLine.fromId}) of parent pair line ${parentPairLine.id} is not a valid unit.`);
        }
        if (parent2 && (parent2.type === 'unit' || parent2.type === 'image-collection')) {
          parentObjects.push(parent2);
        } else {
          console.warn(`[GDPSR] Parent2 (ID: ${parentPairLine.toId}) of parent pair line ${parentPairLine.id} is not a valid unit.`);
        }

        if (parentObjects.length !== 2 && parentObjects.length !== 0) {
          console.warn(`[GDPSR] Expected 2 parents from parent pair line ${parentPairLine.id}, but found ${parentObjects.length}. (P1: ${parent1 ? getItemDisplayName(parent1) : 'N/A'}, P2: ${parent2 ? getItemDisplayName(parent2) : 'N/A'})`);
        }
        if (parentObjects.length === 0 && (parent1 || parent2)) {
          console.warn(`[GDPSR] Parent pair line ${parentPairLine.id} connects to non-unit items. P1 type: ${parent1?.type}, P2 type: ${parent2?.type}`);
        }


        console.log(`[getDirectParentsStrictRule] Returning for ${childUnitId}:`, parentObjects.map(p => getItemDisplayName(p)));
        return parentObjects;
      }
      function determineTargetParentRoles(targetUnit) {
        let sakiParent = null;
        let atoParent = null;
        let birthPartner = null;
        let error = null;

        console.log(`[DTPR V5 - Simplified] Target: ${getItemDisplayName(targetUnit)}`);

        // 目標個体は画像1枚のユニットのみという前提
        const targetImageCount = targetUnit.activeSlotKeys ? targetUnit.activeSlotKeys.length : 0;
        if (!(targetUnit.type === 'unit' && targetImageCount === 1)) {
          error = "目標個体は画像1枚のユニットである必要があります。";
          console.warn(`[DTPR V5] Error: ${error}`);
          return { sakiParent, atoParent, birthPartner, error };
        }

        // 親の特定には getDirectParentsStrictRule を使用
        const parentsList = getDirectParentsStrictRule(targetUnit.id);
        console.log(`  [DTPR V5] Parents from StrictRule:`, parentsList.map(p => getItemDisplayName(p)));

        if (parentsList.length === 0) {
          error = `推奨捕獲順のルールに従った親ユニットが見つかりませんでした。子ユニットは親ペアを繋ぐ線の中点に接続されていますか？`;
        } else if (parentsList.length === 1) {
          sakiParent = parentsList[0];
          error = `親ユニットが1体のみ見つかりました。ルールでは通常2体の親が必要です。`;
          console.warn(`  [DTPR V5] Only one parent found for 1-image target.`);
        } else if (parentsList.length === 2) {
          const sortedParents = [...parentsList].sort((a, b) => a.x - b.x);
          sakiParent = sortedParents[0];
          atoParent = sortedParents[1];
        } else if (parentsList.length === 3) {
          const sortedByY = [...parentsList].sort((a, b) => a.y - b.y);
          const mainParentsPair = [sortedByY[0], sortedByY[1]].sort((a, b) => a.x - b.x);
          sakiParent = mainParentsPair[0];
          atoParent = mainParentsPair[1];
          birthPartner = sortedByY[2];
          console.log(`    [DTPR V5] Found 2 parents and 1 birth partner.`);
        } else { // parentsList.length > 3
          error = `親ユニットが多すぎます (${parentsList.length}体)。ルール違反の可能性があります。`;
        }

        // 最終チェック: sakiParent と atoParent が揃っているか (birthPartner はオプション)
        if (!error && (!sakiParent || !atoParent)) {
          // sakiParentのみ存在し、birthPartnerもいない場合は、atoParentが見つからないエラー
          if (sakiParent && !atoParent && !birthPartner) {
            error = "「後」の親が見つかりませんでした。";
          } else if (!sakiParent && !atoParent) { // 両方見つからないのは上の parentsList.length === 0 で処理済みのはず
            error = "「先」と「後」の両方の親が見つかりませんでした。";
          }
          // sakiParent と birthPartner がいて atoParent がいない、というケースは通常考えにくい
        }


        if (error) {
          console.warn(`[DTPR V5] Error/Warning after processing: ${error}`);
        }
        console.log(`[DTPR V5] Returning: Saki=${sakiParent ? getItemDisplayName(sakiParent) : 'N/A'}, Ato=${atoParent ? getItemDisplayName(atoParent) : 'N/A'}, Partner=${birthPartner ? getItemDisplayName(birthPartner) : 'N/A'}, Error=${error}`);
        return { sakiParent, atoParent, birthPartner, error };
      }

      // ヘルパー関数: 指定されたユニットに直接接続しているユニットのリストを取得
      // (T字の幹や枝の中間点は考慮せず、ユニット間の物理的な直接接続のみを見る)
      function getDirectlyConnectedUnits(unitId) {
        const connectedUnitIds = new Set();
        connections.forEach(conn => {
          // fromId が unitId で、toId がユニットIDの場合
          if (conn.fromId === unitId && !conn.toId.startsWith('conn-')) {
            const targetUnit = findItemById(conn.toId);
            if (targetUnit && (targetUnit.type === 'unit' || targetUnit.type === 'image-collection')) {
              connectedUnitIds.add(conn.toId);
            }
          }
          // toId が unitId で、fromId がユニットIDの場合
          else if (conn.toId === unitId && !conn.fromId.startsWith('conn-')) {
            const sourceUnit = findItemById(conn.fromId);
            if (sourceUnit && (sourceUnit.type === 'unit' || sourceUnit.type === 'image-collection')) {
              connectedUnitIds.add(conn.fromId);
            }
          }
        });
        return Array.from(connectedUnitIds).map(id => findItemById(id)).filter(Boolean); // filter(Boolean)でnullを除去
      }

      // ヘルパー関数: 指定されたユニットに直接接続しているユニットのリストを取得
      function getDirectlyConnectedUnits(unitId) {
        const connectedUnitIds = new Set();
        connections.forEach(conn => {
          if (conn.fromId === unitId && !conn.toId.startsWith('conn-')) {
            connectedUnitIds.add(conn.toId);
          } else if (conn.toId === unitId && !conn.fromId.startsWith('conn-')) {
            connectedUnitIds.add(conn.fromId);
          }
          // T字の幹がこのユニットに接続している場合、その幹の元の線(枝)の端点ユニットは含めない
          // (この関数は「直接物理的に線で繋がっているユニット」のみを対象とするため)
        });
        return Array.from(connectedUnitIds).map(id => findItemById(id)).filter(u => u && (u.type === 'unit' || u.type === 'image-collection'));
      }
      function drawAllElementsOnContext(targetContext, targetCanvasElement, items, currentDrawingSettings, isTransparentBackground = false) {
        const drawScale = currentDrawingSettings.scale;
        const currentSelectedItem = (targetCanvasElement === canvas) ? items.selectedItem : null;
        const currentConnectFromItem = (targetCanvasElement === canvas) ? items.connectFromItem : null;
        const currentItemsToGroup = (targetCanvasElement === canvas) ? items.itemsToGroup : [];

        targetContext.save();
        targetContext.clearRect(0, 0, targetCanvasElement.width, targetCanvasElement.height);

        // ★★★ 背景描画の制御 ★★★
        if (!isTransparentBackground) {
          // メインキャンバスの場合は、メインキャンバスの背景色を取得して塗る
          // 保存用のtreeLayerCanvasの場合は、このブロックは実行されない（isTransparentBackgroundがtrueのため）
          let bgColorToFill = '#fdfdfd';
          if (targetCanvasElement === canvas) {
            bgColorToFill = window.getComputedStyle(canvas).backgroundColor || '#fdfdfd';
          }
          targetContext.fillStyle = bgColorToFill;
          targetContext.fillRect(0, 0, targetCanvasElement.width, targetCanvasElement.height);
        }
        targetContext.translate(currentDrawingSettings.originX, currentDrawingSettings.originY);
        targetContext.scale(drawScale, drawScale);

        // 1. 接続線の描画
        items.connections.forEach(conn => {
          let p1 = null, p2 = null;
          const fromItemOriginal = findItemById(conn.fromId);
          const toItemOriginal = findItemById(conn.toId);

          if (!fromItemOriginal) { return; }
          if (!conn.fromId.startsWith('conn-') && !conn.toId.startsWith('conn-') && !toItemOriginal) { return; }

          let counterpartForP1Calculation = null;
          let counterpartForP2Calculation = null;

          if (conn.isUnitToLine) {
            const targetLineMidpoint = getLineMidpoint(conn.toId);
            if (!targetLineMidpoint) { return; }
            counterpartForP1Calculation = targetLineMidpoint;
            p2 = targetLineMidpoint;
          } else if (conn.isLineToUnit) {
            const sourceLineMidpoint = getLineMidpoint(conn.fromId);
            if (!sourceLineMidpoint || !toItemOriginal) { return; }
            p1 = sourceLineMidpoint;
            counterpartForP2Calculation = sourceLineMidpoint;
          } else {
            if (!toItemOriginal) return;
            counterpartForP1Calculation = { x: toItemOriginal.x + toItemOriginal.width / 2, y: toItemOriginal.y + toItemOriginal.height / 2 };
            counterpartForP2Calculation = { x: fromItemOriginal.x + fromItemOriginal.width / 2, y: fromItemOriginal.y + fromItemOriginal.height / 2 };
          }

          if (!conn.fromId.startsWith('conn-')) {
            if (fromItemOriginal && counterpartForP1Calculation) {
              p1 = getIntersectionPointWithUnitBoundary(fromItemOriginal, counterpartForP1Calculation);
            } else if (!p1) { return; }
          } else if (!p1) { return; }

          if (!conn.toId.startsWith('conn-')) {
            if (toItemOriginal && counterpartForP2Calculation) {
              p2 = getIntersectionPointWithUnitBoundary(toItemOriginal, counterpartForP2Calculation);
            } else if (!p2) { return; }
          } else if (!p2) { return; }

          if (p1 && p2) {
            const snapThreshold = 12 / drawScale;
            let correctedP1x = p1.x; let correctedP1y = p1.y;
            let correctedP2x = p2.x; let correctedP2y = p2.y;
            const dxAbs = Math.abs(p1.x - p2.x); const dyAbs = Math.abs(p1.y - p2.y);

            if (dyAbs < snapThreshold) {
              if (conn.isUnitToLine) { correctedP2y = correctedP1y; }
              else if (conn.isLineToUnit) { correctedP1y = correctedP2y; }
              else { correctedP2y = correctedP1y; }
            }
            if (dxAbs < snapThreshold) {
              if (conn.isUnitToLine) { correctedP2x = correctedP1x; }
              else if (conn.isLineToUnit) { correctedP1x = correctedP2x; }
              else { correctedP2x = correctedP1x; }
            }
            if (Math.abs(correctedP1y - correctedP2y) < 0.1 / drawScale && dxAbs > snapThreshold / 2) {
              correctedP1y = (correctedP1y + correctedP2y) / 2; correctedP2y = correctedP1y;
            }
            if (Math.abs(correctedP1x - correctedP2x) < 0.1 / drawScale && dyAbs > snapThreshold / 2) {
              correctedP1x = (correctedP1x + correctedP2x) / 2; correctedP2x = correctedP1x;
            }

            targetContext.beginPath();
            targetContext.moveTo(correctedP1x, correctedP1y);
            targetContext.lineTo(correctedP2x, correctedP2y);
            const isSelectedConn = currentSelectedItem && currentSelectedItem.id === conn.id && targetCanvasElement === canvas;
            const baseLineWidth = conn.lineWidth || 10;
            const dashArray = conn.dashArray || [];

            if (isSelectedConn) {
              targetContext.strokeStyle = '#007bff';
              targetContext.lineWidth = (baseLineWidth + 2) / drawScale;
            } else {
              targetContext.strokeStyle = conn.color || '#555555';
              targetContext.lineWidth = baseLineWidth / drawScale;
            }
            targetContext.setLineDash(dashArray.map(d => d / drawScale));
            targetContext.stroke();
            targetContext.setLineDash([]);
          }
        });

        // 2. 手書き描画 (保存済みパス)
        (items.drawnPaths || []).forEach(pathObj => {
          if (!pathObj || !pathObj.points || pathObj.points.length < 1) return;
          targetContext.strokeStyle = pathObj.color;
          targetContext.lineWidth = pathObj.lineWidth / drawScale;
          targetContext.lineCap = 'round';
          targetContext.lineJoin = 'round';
          if (pathObj.type === 'eraser') {
            // 保存時は、メインキャンバスの背景色と同じ色で消しゴムを表現
            const mainCanvasBgColor = (targetCanvasElement === canvas) ?
              (window.getComputedStyle(canvas).backgroundColor || '#fdfdfd') :
              (window.getComputedStyle(document.getElementById('family-tree-canvas')).backgroundColor || '#fdfdfd');
            targetContext.strokeStyle = mainCanvasBgColor;
          }
          targetContext.beginPath();
          if (pathObj.type === 'line' || pathObj.type === 'eraser') {
            targetContext.moveTo(pathObj.points[0][0], pathObj.points[0][1]);
            for (let i = 1; i < pathObj.points.length; i++) {
              targetContext.lineTo(pathObj.points[i][0], pathObj.points[i][1]);
            }
            targetContext.stroke();
          } else if (pathObj.type === 'arrow' && pathObj.points.length >= 2) {
            const points = pathObj.points;
            const endX = points[points.length - 1][0]; const endY = points[points.length - 1][1];
            const prevX = points.length > 1 ? points[points.length - 2][0] : points[0][0];
            const prevY = points.length > 1 ? points[points.length - 2][1] : points[0][1];
            targetContext.moveTo(points[0][0], points[0][1]);
            for (let i = 1; i < points.length; i++) { targetContext.lineTo(points[i][0], points[i][1]); }
            targetContext.stroke();
            drawArrowhead(targetContext, prevX, prevY, endX, endY, pathObj.lineWidth / drawScale);
          } else if (pathObj.type === 'rectangle' && pathObj.points.length >= 2 && pathObj.startX !== undefined) {
            const startX = pathObj.startX; const startY = pathObj.startY;
            const endX = pathObj.points[1][0]; const endY = pathObj.points[1][1];
            const rectX = Math.min(startX, endX); const rectY = Math.min(startY, endY);
            const rectW = Math.abs(startX - endX); const rectH = Math.abs(startY - endY);
            if (pathObj.isFilled) { targetContext.fillStyle = pathObj.color; targetContext.fillRect(rectX, rectY, rectW, rectH); }
            targetContext.strokeRect(rectX, rectY, rectW, rectH);
          } else if (pathObj.type === 'circle' && pathObj.points.length >= 2 && pathObj.startX !== undefined) {
            const startX = pathObj.startX; const startY = pathObj.startY;
            const endX = pathObj.points[1][0]; const endY = pathObj.points[1][1];
            const radiusX = Math.abs(startX - endX) / 2; const radiusY = Math.abs(startY - endY) / 2;
            const centerX = Math.min(startX, endX) + radiusX; const centerY = Math.min(startY, endY) + radiusY;
            targetContext.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
            if (pathObj.isFilled) { targetContext.fillStyle = pathObj.color; targetContext.fill(); }
            targetContext.stroke();
          }
        });

        // 3. 手書き描画 (現在描画中パス - メインキャンバスのみ)
        if (targetCanvasElement === canvas && items.isDrawing && items.drawnPathsInProgress && items.drawnPathsInProgress.length > 0) {
          const pathObj = items.drawnPathsInProgress[0];
          if (pathObj && pathObj.points && pathObj.points.length >= 1) {
            targetContext.strokeStyle = pathObj.color;
            targetContext.lineWidth = pathObj.lineWidth / drawScale;
            targetContext.lineCap = 'round'; targetContext.lineJoin = 'round';
            if (pathObj.type === 'eraser') {
              targetContext.strokeStyle = window.getComputedStyle(canvas).backgroundColor || '#fdfdfd';
            }
            targetContext.beginPath();
            if (pathObj.type === 'line' || pathObj.type === 'eraser') {
              if (pathObj.points.length > 0) {
                targetContext.moveTo(pathObj.points[0][0], pathObj.points[0][1]);
                for (let i = 1; i < pathObj.points.length; i++) {
                  targetContext.lineTo(pathObj.points[i][0], pathObj.points[i][1]);
                }
                targetContext.stroke();
              }
            } else if (pathObj.type === 'arrow' && pathObj.points.length >= 2) {
              const points = pathObj.points;
              const endX = points[points.length - 1][0]; const endY = points[points.length - 1][1];
              const prevX = points.length > 1 ? points[points.length - 2][0] : points[0][0];
              const prevY = points.length > 1 ? points[points.length - 2][1] : points[0][1];
              targetContext.moveTo(points[0][0], points[0][1]);
              for (let i = 1; i < points.length; i++) { targetContext.lineTo(points[i][0], points[i][1]); }
              targetContext.stroke();
              drawArrowhead(targetContext, prevX, prevY, endX, endY, pathObj.lineWidth / drawScale);
            } else if (pathObj.type === 'rectangle' && pathObj.points.length >= 2 && pathObj.startX !== undefined) {
              const startX = pathObj.startX; const startY = pathObj.startY;
              const endX = pathObj.points[1][0]; const endY = pathObj.points[1][1];
              const rectX = Math.min(startX, endX); const rectY = Math.min(startY, endY);
              const rectW = Math.abs(startX - endX); const rectH = Math.abs(startY - endY);
              if (pathObj.isFilled) { targetContext.fillStyle = pathObj.color; targetContext.fillRect(rectX, rectY, rectW, rectH); }
              targetContext.strokeRect(rectX, rectY, rectW, rectH);
            } else if (pathObj.type === 'circle' && pathObj.points.length >= 2 && pathObj.startX !== undefined) {
              const startX = pathObj.startX; const startY = pathObj.startY;
              const endX = pathObj.points[1][0]; const endY = pathObj.points[1][1];
              const radiusX = Math.abs(startX - endX) / 2; const radiusY = Math.abs(startY - endY) / 2;
              const centerX = Math.min(startX, endX) + radiusX; const centerY = Math.min(startY, endY) + radiusY;
              targetContext.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
              if (pathObj.isFilled) { targetContext.fillStyle = pathObj.color; targetContext.fill(); }
              targetContext.stroke();
            }
          }
        }

        // 4. グループの描画
        items.groups.forEach(group => {
          targetContext.save();
          targetContext.translate(group.x, group.y);
          const isSelectedForDisplay = currentSelectedItem && currentSelectedItem.id === group.id && targetCanvasElement === canvas;

          if (group.borderVisible) {
            targetContext.strokeStyle = isSelectedForDisplay ? '#007bff' : '#6f42c1';
            targetContext.lineWidth = (isSelectedForDisplay ? 6 : 4) / drawScale;
            targetContext.fillStyle = 'rgba(111, 66, 193, 0.05)'; // グループの背景色
            drawRoundedRect(targetContext, 0, 0, group.width, group.height, 15);
            targetContext.fill();
            targetContext.stroke();
          } else if (isSelectedForDisplay) { // 枠非表示でも選択時は枠表示 (メインキャンバスのみ)
            targetContext.strokeStyle = '#007bff';
            targetContext.lineWidth = 6 / drawScale;
            drawRoundedRect(targetContext, 0, 0, group.width, group.height, 15);
            targetContext.stroke();
          }
          if (group.name) {
            targetContext.fillStyle = '#6f42c1';
            targetContext.font = `${14 / drawScale}px ${DEFAULT_FONT}`;
            targetContext.textAlign = 'center';
            targetContext.strokeStyle = 'rgba(255,255,255,0.7)';
            targetContext.lineWidth = 3 / drawScale;
            targetContext.strokeText(truncateText(group.name, 20), group.width / 2, -(5 / drawScale));
            targetContext.fillText(truncateText(group.name, 20), group.width / 2, -(5 / drawScale));
          }
          targetContext.restore();
        });

        // 5. ユニットの描画
        items.units.forEach(unit => {
          targetContext.save();
          targetContext.translate(unit.x, unit.y);

          const isNormallySelected = currentSelectedItem && currentSelectedItem.id === unit.id && targetCanvasElement === canvas;
          const isUnitConnectFrom = currentConnectFromItem && currentConnectFromItem.id === unit.id && targetCanvasElement === canvas;
          const isUnitInGroupSelection = currentItemsToGroup.find(item => item.id === unit.id) && targetCanvasElement === canvas;
          const isUnitUnifyTarget = unit.isTargetSelectedForUnify === true && targetCanvasElement === canvas;

          let currentUnitLineWidth = 2 / drawScale;
          // 保存時は常に黒系の枠線色、メインキャンバスではタイプに応じたデフォルト色
          let defaultStrokeColor = (targetCanvasElement === canvas) ?
            (unit.type === 'image-collection' ? '#4caf50' : '#333') :
            '#000000'; // 保存時は黒枠
          let currentUnitStrokeStyle = defaultStrokeColor;
          let currentUnitFillStyle = unit.type === 'image-collection' ? 'rgba(240, 240, 240, 0.8)' : '#fff';

          if (targetCanvasElement === canvas) { // メインキャンバス表示時のみ選択状態によるスタイル変更
            if (isUnitUnifyTarget) { currentUnitLineWidth = 5 / drawScale; currentUnitStrokeStyle = '#20c997'; }
            else if (isNormallySelected) { currentUnitLineWidth = 4 / drawScale; currentUnitStrokeStyle = '#007bff'; }
            else if (isUnitConnectFrom) { currentUnitLineWidth = 4 / drawScale; currentUnitStrokeStyle = '#ffc107'; }
            else if (isUnitInGroupSelection) { currentUnitLineWidth = 4 / drawScale; currentUnitStrokeStyle = '#28a745'; }
          }

          if (unit.borderVisible) {
            targetContext.lineWidth = currentUnitLineWidth;
            targetContext.strokeStyle = currentUnitStrokeStyle; // ここで設定された色を使用
            targetContext.fillStyle = currentUnitFillStyle;
            drawRoundedRect(targetContext, 0, 0, unit.width, unit.height, 8);
            targetContext.fill();
            targetContext.stroke();
          } else if (targetCanvasElement === canvas && (isUnitUnifyTarget || isNormallySelected || isUnitConnectFrom || isUnitInGroupSelection)) {
            targetContext.lineWidth = currentUnitLineWidth;
            targetContext.strokeStyle = currentUnitStrokeStyle;
            drawRoundedRect(targetContext, 0, 0, unit.width, unit.height, 8);
            targetContext.stroke();
          }


          if (unit.type === 'image-collection') {
            drawImagesInCollectionUnit(targetContext, unit, drawScale, unit.layoutSettings);
            if (unit.images?.length === 0) {
              targetContext.fillStyle = '#000000'; // 保存時も黒
              targetContext.font = `${14 / drawScale}px ${DEFAULT_FONT}`;
              targetContext.textAlign = 'center'; targetContext.textBaseline = 'middle';
              targetContext.fillText(`画像なし`, unit.width / 2, unit.height / 2);
            }
          } else { // 通常ユニット
            const cSP = SLOT_PADDING_BASE; const cIP = UNIT_INTERNAL_PADDING_BASE;
            const fS_logical = 11 * BASE_SCALE_FACTOR;
            const fS_display = fS_logical / drawScale; // 描画時のフォントサイズ
            const tLH_logical = SLOT_TEXT_LINE_HEIGHT_BASE * TEXT_LINE_HEIGHT_MULTIPLIER;
            const tLH_display = tLH_logical / drawScale; // 描画時の行の高さ
            const bIH = SLOT_IMAGE_HEIGHT_BASE; const qIMSH = SLOT_QR_IMAGE_SIZE_BASE;
            let hasImg = Object.values(unit.slots).some(s => s && (s.img || s.imgDataUrl));
            let hasTxtInfo = Object.entries(unit.slots).some(([k, s]) => s && (s.name || (s.food && s.food !== '未選択') || ((k === 'qr1' || k === 'qr2') && s.order)));
            let txtStartY_logical = cSP; // テキスト描画開始Y座標 (論理値)
            if (hasImg) txtStartY_logical += Math.max(bIH, qIMSH) + (hasTxtInfo ? IMAGE_TEXT_PADDING : 0);
            else if (hasTxtInfo) txtStartY_logical += cSP / 2;

            const activeSKs = unit.activeSlotKeys || [];
            const imgCnt = activeSKs.length;
            let slW, slStartX = cSP, dispSKs = [];

            // スロット幅と開始X座標の計算 (drawCanvasのロジックをほぼそのまま使用)
            if (imgCnt === 1) { slW = SLOT_WIDTH_BASE; slStartX = (unit.width - slW) / 2; if (activeSKs.length > 0) dispSKs.push(activeSKs[0]); }
            else if (imgCnt === 2) {
              slW = SLOT_WIDTH_BASE; const p_order = ['qr1', 'birth', 'qr2']; const srtK = [...activeSKs].sort((a, b) => p_order.indexOf(a) - p_order.indexOf(b));
              if (srtK.length >= 2) { dispSKs.push(srtK[0]); dispSKs.push(srtK[1]); slStartX = (unit.width - (slW * 2 + cIP)) / 2; }
              else if (srtK.length === 1) { dispSKs.push(srtK[0]); slStartX = (unit.width - slW) / 2; }
            } else { // 0枚または3枚
              slW = SLOT_WIDTH_BASE;
              const p_order = ['qr1', 'birth', 'qr2'];
              // 表示するスロットキーを決定 (画像があるもの優先、なければテキストがあるもの)
              p_order.forEach(k => {
                if (unit.slots[k] && (unit.slots[k].img || unit.slots[k].imgDataUrl)) {
                  if (!dispSKs.includes(k)) dispSKs.push(k);
                }
              });
              // 画像がなくてもテキスト情報があれば表示対象とする
              if (dispSKs.length === 0 && hasTxtInfo) {
                p_order.forEach(k => {
                  if (unit.slots[k] && (unit.slots[k].name || (unit.slots[k].food && unit.slots[k].food !== '未選択') || ((k === 'qr1' || k === 'qr2') && unit.slots[k].order))) {
                    if (!dispSKs.includes(k)) dispSKs.push(k);
                  }
                });
              }
              // 実際に表示するスロット数に基づいて幅と開始位置を再計算
              const numSlotsToDraw = dispSKs.length > 0 ? dispSKs.length : (unit.width === UNIT_WIDTH_THREE_SLOTS ? 3 : 1); // 最低1スロット
              const totalInternalPaddingForDisplay = numSlotsToDraw > 1 ? cIP * (numSlotsToDraw - 1) : 0;
              const totalPaddingForDisplay = cSP * 2 + totalInternalPaddingForDisplay;
              slW = numSlotsToDraw > 0 ? (unit.width - totalPaddingForDisplay) / numSlotsToDraw : SLOT_WIDTH_BASE;
              slStartX = cSP;
              if (numSlotsToDraw === 1 && unit.width > UNIT_WIDTH_ONE_SLOT) { // 1スロットだが幅が広い場合中央揃え
                slStartX = (unit.width - slW) / 2;
              }
            }


            let curSlX = slStartX; const slOrder = ['qr1', 'birth', 'qr2']; let slDrawn = 0;

            for (const slK of slOrder) {
              const shouldDisplayThisSlot = dispSKs.includes(slK);
              if (!shouldDisplayThisSlot && imgCnt > 0) continue; // 画像があるのに表示対象でないならスキップ
              if (!shouldDisplayThisSlot && imgCnt === 0 && !hasTxtInfo) continue; // 画像もテキストもなければスキップ

              const slData = unit.slots[slK];
              // スロットデータ自体がない、または画像もテキスト情報もなければ描画しない (ただしdispSKsに含まれていれば描画試行)
              if (!slData && !dispSKs.includes(slK)) continue;
              if (slData && !slData.img && !slData.imgDataUrl && !slData.name && !(slData.food && slData.food !== '未選択') && !slData.order && !dispSKs.includes(slK)) continue;


              targetContext.save();
              targetContext.translate(curSlX, cSP);
              const sAH = (slK === 'birth') ? bIH : qIMSH; // スロットの高さ (論理値)
              const sAW = slW; // スロットの幅 (論理値)

              const imgToDraw = slData?.img;
              if (imgToDraw && imgToDraw.complete && imgToDraw.naturalWidth > 0) {
                try {
                  const ar = imgToDraw.naturalWidth / imgToDraw.naturalHeight; let dW, dH;
                  // 画像サイズ計算 (論理ピクセルベース)
                  if (slK === 'birth') {
                    dH = sAH; dW = dH * ar; if (dW > sAW) { dW = sAW; dH = dW / ar; }
                  } else { if (sAW / ar <= sAH) { dW = sAW; dH = dW / ar; } else { dH = sAH; dW = dH * ar; } }
                  dW = Math.min(dW, sAW); dH = Math.min(dH, sAH); // スロット内に収める
                  const iX = (sAW - dW) / 2; const iY = (sAH - dH) / 2; // 中央揃え
                  targetContext.drawImage(imgToDraw, iX, iY, dW, dH);
                } catch (e) { console.error("Error drawing unit slot image:", e); }
              }

              if (slData && (slData.name || (slData.food && slData.food !== '未選択') || slData.order)) {
                targetContext.font = `${fS_display}px ${DEFAULT_FONT}`;
                targetContext.textAlign = 'center';
                let currentTextLineY_InSlot_display = txtStartY_logical; // 表示用Y座標 (スケーリングはここで不要、上位で済)

                const textShadowStyle = 'rgba(255,255,255,0.8)';
                const textShadowWidth = 3 / drawScale;

                const drawTextLineInSlot_ForRender = (text, yOffsetLogical, isFoodItem = false, foodColor = '#ccc') => {
                  const actualYInSlotLocal_display = yOffsetLogical - cSP; // スロットローカルY (論理値)
                  targetContext.strokeStyle = textShadowStyle;
                  targetContext.lineWidth = textShadowWidth;
                  if (isFoodItem) {
                    const textMetrics = targetContext.measureText(text); // 描画時フォントで測定
                    const textActualWidth_display = textMetrics.width;
                    const circleRadius_display = (fS_logical / 2.8) / drawScale; // 円の半径 (表示ピクセル)
                    const circleX_display = (sAW / 2) - (textActualWidth_display / 2) - circleRadius_display - (2 / drawScale);
                    const textRenderX_display = sAW / 2;
                    targetContext.beginPath();
                    targetContext.arc(circleX_display, actualYInSlotLocal_display - (fS_display / 2) + (circleRadius_display / 2), circleRadius_display, 0, 2 * Math.PI);
                    targetContext.fillStyle = foodColor;
                    targetContext.fill();
                    targetContext.strokeText(text, textRenderX_display, actualYInSlotLocal_display, sAW - circleRadius_display * 2 - (4 / drawScale));
                    targetContext.fillStyle = '#000000'; // 文字色は黒
                    targetContext.fillText(text, textRenderX_display, actualYInSlotLocal_display, sAW - circleRadius_display * 2 - (4 / drawScale));
                  } else {
                    targetContext.strokeText(text, sAW / 2, actualYInSlotLocal_display, sAW);
                    targetContext.fillStyle = '#000000'; // 文字色は黒
                    targetContext.fillText(text, sAW / 2, actualYInSlotLocal_display, sAW);
                  }
                };
                if (slData.name) { drawTextLineInSlot_ForRender(truncateText(slData.name, 12), currentTextLineY_InSlot_display); currentTextLineY_InSlot_display += tLH_logical; }
                if (slData.food && slData.food !== '未選択') { const foodColorForDisplay = cropColors[slData.food] || '#888'; drawTextLineInSlot_ForRender(truncateText('好物:' + slData.food, 15), currentTextLineY_InSlot_display, true, foodColorForDisplay); currentTextLineY_InSlot_display += tLH_logical; }
                if (slData.order && (slK === 'qr1' || slK === 'qr2')) { drawTextLineInSlot_ForRender(slData.order, currentTextLineY_InSlot_display); }
              }
              targetContext.restore();
              slDrawn++;
              // 表示スロット数に基づいて次の描画位置を決定
              if (slDrawn < (dispSKs.length > 0 ? dispSKs.length : 1)) {
                curSlX += slW + cIP;
              }
            }
          }
          targetContext.restore();
        });

        // 6. テキストアイテムの描画
        items.textItems.forEach(textItem => {
          targetContext.save();
          targetContext.translate(textItem.x + textItem.width / 2, textItem.y + textItem.height / 2);
          if (textItem.rotation) targetContext.rotate(textItem.rotation * Math.PI / 180);
          const dX = -textItem.width / 2, dY = -textItem.height / 2;

          const isSelectedForTextDisplay = currentSelectedItem && currentSelectedItem.id === textItem.id && targetCanvasElement === canvas;

          targetContext.fillStyle = textItem.backgroundColor;
          drawRoundedRect(targetContext, dX, dY, textItem.width, textItem.height, 5);
          targetContext.fill();

          if (textItem.borderVisible) {
            targetContext.lineWidth = (isSelectedForTextDisplay ? 4 : 2) / drawScale;
            targetContext.strokeStyle = isSelectedForTextDisplay ? '#007bff' : '#555';
            drawRoundedRect(targetContext, dX, dY, textItem.width, textItem.height, 5);
            targetContext.stroke();
          } else if (isSelectedForTextDisplay) { // 枠非表示でも選択時は枠表示 (メインキャンバスのみ)
            targetContext.lineWidth = 4 / drawScale;
            targetContext.strokeStyle = '#007bff';
            drawRoundedRect(targetContext, dX, dY, textItem.width, textItem.height, 5);
            targetContext.stroke();
          }
          targetContext.fillStyle = textItem.color;
          targetContext.font = `${textItem.fontSize / drawScale}px ${textItem.font || DEFAULT_FONT}`;
          targetContext.textAlign = 'left';
          targetContext.textBaseline = 'top';
          const textPaddingForRender_logical = TEXT_ITEM_PADDING; // 論理パディング
          const contentMaxWidth_logical = textItem.width - (textPaddingForRender_logical * 2);

          if (contentMaxWidth_logical > 0) {
            // wrapTextAndMeasure は論理サイズで計算
            const measured = wrapTextAndMeasure(textItem.text, contentMaxWidth_logical, textItem.fontSize, textItem.font || DEFAULT_FONT, TEXT_LINE_HEIGHT_MULTIPLIER);
            const linesToDraw = measured.linesArray;
            const lineHeightForRender_display = (textItem.fontSize * TEXT_LINE_HEIGHT_MULTIPLIER) / drawScale; // 表示上の行の高さ
            let currentY_render_display = dY + textPaddingForRender_logical; // 開始Yは論理パディング

            for (let i = 0; i < linesToDraw.length; i++) {
              const lineText = linesToDraw[i];
              // 描画領域チェックも論理サイズで行う
              if (currentY_render_display + lineHeightForRender_display > dY + textItem.height - textPaddingForRender_logical && i < linesToDraw.length) {
                if (currentY_render_display + (textItem.fontSize / drawScale) <= dY + textItem.height - textPaddingForRender_logical) {
                  let visiblePortion = '';
                  for (let charIdx = 0; charIdx < lineText.length; charIdx++) {
                    const testPortion = visiblePortion + lineText[charIdx];
                    // measureText は現在のコンテキストのフォント設定で行われる
                    if (targetContext.measureText(testPortion + "...").width > contentMaxWidth_logical) break;
                    visiblePortion = testPortion;
                  }
                  targetContext.fillText(visiblePortion + "...", dX + textPaddingForRender_logical, currentY_render_display, contentMaxWidth_logical);
                }
                break;
              }
              if (currentY_render_display + (textItem.fontSize / drawScale) <= dY + textItem.height - textPaddingForRender_logical) {
                targetContext.fillText(lineText, dX + textPaddingForRender_logical, currentY_render_display, contentMaxWidth_logical);
              }
              currentY_render_display += lineHeightForRender_display;
            }
          }
          targetContext.restore();
        });
        targetContext.restore();
      }
      function saveDrawingState() {
        drawnPathsHistory = drawnPathsHistory.slice(0, drawnPathsHistoryIndex + 1);
        drawnPathsHistory.push(JSON.parse(JSON.stringify(drawnPaths)));
        drawnPathsHistoryIndex++;
        updateDrawingUndoRedoButtons();
      }

      function undoDrawing() {
        if (drawnPathsHistoryIndex <= 0) return;

        drawnPathsHistoryIndex--;
        drawnPaths = JSON.parse(JSON.stringify(drawnPathsHistory[drawnPathsHistoryIndex]));
        drawCanvas();
        updateDrawingUndoRedoButtons();
      }

      function redoDrawing() {
        if (drawnPathsHistoryIndex >= drawnPathsHistory.length - 1) return;

        drawnPathsHistoryIndex++;
        drawnPaths = JSON.parse(JSON.stringify(drawnPathsHistory[drawnPathsHistoryIndex])); // 履歴から復元
        drawCanvas();
        updateDrawingUndoRedoButtons();
      }

      function updateDrawingUndoRedoButtons() {
        if (drawingUndoButton) {
          drawingUndoButton.disabled = drawnPathsHistoryIndex <= 0;
        }
        if (drawingRedoButton) {
          drawingRedoButton.disabled = drawnPathsHistoryIndex >= drawnPathsHistory.length - 1;
        }
      }

      function resetDrawingHistory() {
        drawnPathsHistory = [JSON.parse(JSON.stringify(drawnPaths))]; // 現在の描画状態を初期履歴とする
        drawnPathsHistoryIndex = 0;
        updateDrawingUndoRedoButtons();
      }



      // ========================================
      // 5. イベントリスナー設定 (...addEventListener(...))
      // ========================================
      leftPanelToggleButton.addEventListener('click', () => {
        leftPanel.classList.toggle('collapsed');

        if (leftPanel.classList.contains('collapsed')) {
          leftPanelToggleButton.innerHTML = '＞';
          leftPanelToggleButton.title = "左パネルを展開";
          leftPanelToggleButton.classList.remove('panel-is-open');
          leftPanelToggleButton.classList.add('panel-is-closed');
        } else {
          leftPanelToggleButton.innerHTML = '＜';
          leftPanelToggleButton.title = "左パネルを収納";
          leftPanelToggleButton.style.left = `${leftPanel.offsetWidth}px`;
          leftPanelToggleButton.classList.add('panel-is-open');
          leftPanelToggleButton.classList.remove('panel-is-closed');
        }
      });

      window.addEventListener('resize', () => { if (!leftPanel.classList.contains('collapsed')) leftPanelToggleButton.style.left = `${leftPanel.offsetWidth}px`; resizeCanvas(); });
      undoButton.addEventListener('click', () => {
        if (historyIndex < 0) {
          return;
        }

        const modeBeforeRestore = currentMode;

        historyIndex--;

        if (historyIndex < 0) {
          units = [];
          groups = [];
          textItems = [];
          connections = [];
          drawnPaths = [];
          nextItemId = 0;
          selectedItem = null;
          draggingItem = null;
          resizingItem = null;
          resizeHandle = null;
          connectFromItem = null;
          itemsToGroup = [];
          currentDrawingPath = [];

          if (modeBeforeRestore) {
            toggleMode(null);
          }

          // ズームやパンも初期化する場合 (必要に応じてコメント解除)
          // scale = 1.0;
          // zoomLevel = 0;
          // originX = 0;
          // originY = 0;
          // if (zoomLevelIndicator) zoomLevelIndicator.textContent = zoomLevel;
          resetDrawingHistory();
          drawCanvas();
          updateInfoModal();
        } else {
          restoreState(history[historyIndex]);
        }
        if (modeBeforeRestore === 'draw-path') {
          if (drawModeButton) {
            toggleMode('draw-path', drawModeButton);
          } else {
            currentMode = 'draw-path';
            if (drawingToolsPanel) drawingToolsPanel.style.display = 'block';
            canvas.style.cursor = 'crosshair';
            resetDrawingHistory();
          }
        } else if (currentMode === 'draw-path' && modeBeforeRestore !== 'draw-path') {
        }
        updateUndoRedoButtons();
      });
      redoButton.addEventListener('click', () => {
        if (historyIndex >= history.length - 1) return;

        const modeBeforeRestore = currentMode;

        historyIndex++;
        restoreState(history[historyIndex]);

        if (modeBeforeRestore === 'draw-path') {
          if (drawModeButton) {
            toggleMode('draw-path', drawModeButton);
          } else {
            currentMode = 'draw-path';
            if (drawingToolsPanel) drawingToolsPanel.style.display = 'block';
            canvas.style.cursor = 'crosshair';
            resetDrawingHistory();
          }
        } else if (currentMode === 'draw-path' && modeBeforeRestore !== 'draw-path') {
        }
        updateUndoRedoButtons();
      });
      imageSlots.qr1.orderSakiCheckbox.addEventListener('change', (e) => handleQrOrderChange('qr1', '先', 'left-panel'));
      imageSlots.qr1.orderAtoCheckbox.addEventListener('change', (e) => handleQrOrderChange('qr1', '後', 'left-panel'));
      imageSlots.qr2.orderSakiCheckbox.addEventListener('change', (e) => handleQrOrderChange('qr2', '先', 'left-panel'));
      imageSlots.qr2.orderAtoCheckbox.addEventListener('change', (e) => handleQrOrderChange('qr2', '後', 'left-panel'));
      Object.keys(imageSlots).forEach(slotKey => {
        const slotUI = imageSlots[slotKey];
        if (slotUI.orderSakiCheckbox) {
          slotUI.orderSakiCheckbox.addEventListener('change', (e) => { if (e.target.checked) slotUI.orderAtoCheckbox.checked = false; });
          slotUI.orderAtoCheckbox.addEventListener('change', (e) => { if (e.target.checked) slotUI.orderSakiCheckbox.checked = false; });
        }
        slotUI.uploadInput.addEventListener('change', (event) => {
          const file = event.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (e_reader) => {
              const originalDataUrl = e_reader.target.result;
              slotUI.previewImg.src = originalDataUrl; slotUI.previewImg.style.display = 'block';
              slotUI.editBtn.disabled = false; slotUI.clearBtn.classList.remove('hidden');
              const img = new Image();
              img.onload = () => { imageSlots[slotKey].data = { img: img, fileName: file.name, originalDataUrl: originalDataUrl, imgDataUrl: originalDataUrl }; checkAddUnitButtonState(); };
              img.onerror = () => { console.error("Orig img load err for slot:", slotKey); imageSlots[slotKey].data = null; slotUI.editBtn.disabled = true; slotUI.clearBtn.classList.add('hidden'); checkAddUnitButtonState(); };
              img.src = originalDataUrl;
            };
            reader.readAsDataURL(file);
          } else { slotUI.previewImg.style.display = 'none'; slotUI.previewImg.src = '#'; slotUI.editBtn.disabled = true; slotUI.clearBtn.classList.add('hidden'); imageSlots[slotKey].data = null; checkAddUnitButtonState(); }
        });
        slotUI.editBtn.addEventListener('click', () => {
          if (imageSlots[slotKey].data && imageSlots[slotKey].data.originalDataUrl) {
            currentImageSlotKeyForEditing = slotKey; currentEditingUnitContext = 'left-panel';
            imageToCrop.src = imageSlots[slotKey].data.originalDataUrl; openModal(cropperModal);
            if (cropper) cropper.destroy();
            const aspRatio = (slotKey === 'birth') ? NaN : 1; aspectRatioSelect.value = isNaN(aspRatio) ? "NaN" : aspRatio.toString();
            cropper = new Cropper(imageToCrop, { aspectRatio: aspRatio, viewMode: 1, background: false, zoomable: true, movable: true, cropBoxResizable: true, dragMode: 'move' });
            currentCropFinalizeCallback = (croppedDataUrl) => {
              const targetSlotUI = imageSlots[currentImageSlotKeyForEditing]; const targetSlotData = targetSlotUI.data;
              targetSlotUI.previewImg.src = croppedDataUrl; const img = new Image();
              img.onload = () => { targetSlotData.img = img; targetSlotData.imgDataUrl = croppedDataUrl; checkAddUnitButtonState(); };
              img.onerror = () => { console.error("Cropped img load err for slot:", currentImageSlotKeyForEditing); checkAddUnitButtonState(); };
              img.src = croppedDataUrl; closeCropperModal();
            };
          } else { alert("編集する画像がアップロードされていません。"); }
        });
        slotUI.clearBtn.addEventListener('click', () => { slotUI.previewImg.style.display = 'none'; slotUI.previewImg.src = '#'; slotUI.uploadInput.value = ''; slotUI.editBtn.disabled = true; slotUI.clearBtn.classList.add('hidden'); imageSlots[slotKey].data = null; checkAddUnitButtonState(); });
      });
      imageCollectionUploadInput.addEventListener('change', async (event) => {
        const files = event.target.files;
        if (!files || files.length === 0) { uploadedCollectionImages = []; imageCollectionPreviewsDiv.innerHTML = ''; imageCollectionDetailsDiv.innerHTML = ''; checkAddImageCollectionButtonState(); if (clearImageCollectionButton) clearImageCollectionButton.classList.add('hidden'); return; }
        if (clearImageCollectionButton) clearImageCollectionButton.classList.remove('hidden');
        if (files.length > 20) { alert('画像は最大20枚まで'); imageCollectionUploadInput.value = ''; return; }
        uploadedCollectionImages = []; imageCollectionPreviewsDiv.innerHTML = ''; imageCollectionDetailsDiv.innerHTML = ''; addImageCollectionButton.disabled = true;
        const loadImage = async (file) => { return new Promise((resolve) => { const reader = new FileReader(); reader.onload = (e_r) => { const iDU = e_r.target.result; const img = new Image(); img.onload = () => resolve({ img, imgDataUrl: iDU, originalDataUrl: iDU, fileName: file.name, name: '', food: '未選択' }); img.onerror = () => resolve(null); img.src = iDU; }; reader.onerror = () => resolve(null); reader.readAsDataURL(file); }); };
        try {
          const results = await Promise.all(Array.from(files).map(loadImage));
          uploadedCollectionImages = results.filter(r => r !== null);
          imageCollectionPreviewsDiv.innerHTML = '';
          uploadedCollectionImages.forEach((imgD, idx) => { imgD.originalIndex = idx; const pIE = document.createElement('img'); pIE.src = imgD.imgDataUrl; pIE.title = imgD.fileName; pIE.dataset.index = idx; pIE.onclick = () => selectCollectionImageForDetail(idx); imageCollectionPreviewsDiv.appendChild(pIE); });
          renderImageCollectionDetails(); checkAddImageCollectionButtonState();
        } catch (error) { console.error("Err loading collection imgs:", error); alert("画像読込エラー"); checkAddImageCollectionButtonState(); }
      });
      addImageCollectionButton.addEventListener('click', () => {
        if (addImageCollectionButton.disabled || uploadedCollectionImages.length === 0) return;
        const newCollectionImages = uploadedCollectionImages.map(imgData => ({ img: imgData.img, imgDataUrl: imgData.imgDataUrl, originalDataUrl: imgData.originalDataUrl, fileName: imgData.fileName, name: imgData.name, food: imgData.food }));
        const { width: unitWidth, height: unitHeight } = calculateImageCollectionUnitSize(newCollectionImages); // 初回はデフォルト設定
        const borderVisible = imageCollectionBorderCheckbox.checked;
        const newImageCollectionUnit = {
          id: `item-${nextItemId++}`, type: 'image-collection', images: newCollectionImages,
          x: (-originX + (mainCanvasArea.clientWidth / 2) - (unitWidth / 2)) / scale, y: (-originY + (mainCanvasArea.clientHeight / 2) - (unitHeight / 2)) / scale,
          width: unitWidth, height: unitHeight, isSelected: false, borderVisible: borderVisible, layoutSettings: null
        };
        units.push(newImageCollectionUnit); saveState(); drawCanvas(); updateInfoModal();
        resetImageUploadsAndInputs();
      });
      cropperZoomControls.addEventListener('click', (e) => { if (!cropper) return; const t = e.target; if (t.tagName === 'BUTTON') { if (t.dataset.zoom) cropper.zoomTo(parseFloat(t.dataset.zoom)); else if (t.dataset.zoomIn) cropper.zoom(0.1); else if (t.dataset.zoomOut) cropper.zoom(-0.1); } });
      aspectRatioSelect.addEventListener('change', () => { if (cropper) cropper.setAspectRatio(parseFloat(aspectRatioSelect.value)); });
      cropImageButton.addEventListener('click', () => { if (cropper && currentCropFinalizeCallback) { const cDU = cropper.getCroppedCanvas({ imageSmoothingEnabled: true, imageSmoothingQuality: 'high' }).toDataURL(); currentCropFinalizeCallback(cDU); } });
      cancelCropButton.addEventListener('click', closeCropperModal);
      cropperModalCloseButtonHeader.addEventListener('click', closeCropperModal);
      addUnitButton.addEventListener('click', () => {
        if (addUnitButton.disabled) return;

        const newUnitSlotsData = {}; // まず空のオブジェクトとして宣言
        const activeSlotKeys = [];
        let imageCount = 0;

        // imageSlots に定義されている各スロットキー (birth, qr1, qr2) でループ
        for (const slotKey of Object.keys(imageSlots)) {
          const slotUI = imageSlots[slotKey];
          const slotLoadedData = slotUI.data;
          let orderValue = null;
          if (slotKey === 'qr1' || slotKey === 'qr2') {
            if (slotUI.orderSakiCheckbox && slotUI.orderSakiCheckbox.checked) orderValue = '先';
            else if (slotUI.orderAtoCheckbox && slotUI.orderAtoCheckbox.checked) orderValue = '後';
          }

          newUnitSlotsData[slotKey] = {
            img: null,
            imgDataUrl: null,
            originalDataUrl: null,
            fileName: null,
            name: slotUI.nameInput.value.trim(),
            food: slotUI.foodSelect.value,
            order: orderValue
          };

          if (slotLoadedData && slotLoadedData.img && slotLoadedData.imgDataUrl) {
            imageCount++;
            activeSlotKeys.push(slotKey);
            newUnitSlotsData[slotKey].img = slotLoadedData.img;
            newUnitSlotsData[slotKey].imgDataUrl = slotLoadedData.imgDataUrl; // 画像があれば上書き
            newUnitSlotsData[slotKey].originalDataUrl = slotLoadedData.originalDataUrl;
            newUnitSlotsData[slotKey].fileName = slotLoadedData.fileName;
          }
        }

        if (imageCount === 0) {
          console.warn("addUnitButton was clicked but imageCount is 0. This shouldn't happen if button is properly disabled.");
          // alert("ユニットを作成するには少なくとも1つの画像を選択してください。"); // 必要ならユーザーに通知
          return;
        }

        let unitWidth;
        if (imageCount === 1) unitWidth = UNIT_WIDTH_ONE_SLOT;
        else if (imageCount === 2) unitWidth = UNIT_WIDTH_TWO_SLOTS;
        else unitWidth = UNIT_WIDTH_THREE_SLOTS;

        const unitHeight = calculateUnitHeight(newUnitSlotsData); // newUnitSlotsData は適切に初期化されているはず
        const borderVisible = addUnitBorderVisibleCheckbox.checked;

        const newUnit = {
          id: `item-${nextItemId++}`,
          type: 'unit',
          slots: newUnitSlotsData,
          x: (-originX + (mainCanvasArea.clientWidth / 2) - (unitWidth / 2)) / scale,
          y: (-originY + (mainCanvasArea.clientHeight / 2) - (unitHeight / 2)) / scale,
          width: unitWidth,
          height: unitHeight,
          isSelected: false,
          borderVisible: borderVisible,
          activeSlotKeys: activeSlotKeys,
          isMonocolor: false,      // 新規追加プロパティのデフォルト値
          isTargetIndividual: false // 新規追加プロパティのデフォルト値
        };
        units.push(newUnit);
        console.log("Newly created unit with slots:", JSON.parse(JSON.stringify(newUnit.slots))); // 作成直後のスロット確認
        resetImageUploadsAndInputs();
        saveState();
        drawCanvas();
        updateInfoModal();
      });
      addTextContentInput.addEventListener('input', checkAddTextButtonState);
      addTextItemButton.addEventListener('click', () => {
        if (addTextItemButton.disabled) return; const textContent = addTextContentInput.value; if (textContent.trim() === '') return;
        const fontSize = parseInt(addTextSizeInput.value, 10); const font = DEFAULT_FONT; const textPadding = TEXT_ITEM_PADDING; const borderVisible = addTextBorderVisibleCheckbox.checked;
        const measureForWidth = wrapTextAndMeasure(textContent, Infinity, fontSize, font, TEXT_LINE_HEIGHT_MULTIPLIER);
        let calculatedWidth = measureForWidth.calculatedWidth + (textPadding * 2); calculatedWidth = Math.max(MIN_TEXT_ITEM_WIDTH, calculatedWidth);
        const finalMaxWidth = calculatedWidth - (textPadding * 2); const finalMeasured = wrapTextAndMeasure(textContent, finalMaxWidth, fontSize, font, TEXT_LINE_HEIGHT_MULTIPLIER);
        let calculatedHeight = finalMeasured.calculatedHeight + (textPadding * 2); calculatedHeight = Math.max(MIN_TEXT_ITEM_HEIGHT, calculatedHeight);
        const newTextItem = { id: `item-${nextItemId++}`, type: 'text', text: textContent, font: font, color: addTextColorInput.value, backgroundColor: addTextBgColorInput.value, fontSize: fontSize, x: (-originX + (mainCanvasArea.clientWidth / 2) - (calculatedWidth / 2)) / scale, y: (-originY + (mainCanvasArea.clientHeight / 2) - (calculatedHeight / 2)) / scale, width: calculatedWidth, height: calculatedHeight, isSelected: false, borderVisible: borderVisible, rotation: 0 };
        textItems.push(newTextItem); saveState(); drawCanvas();
        addTextContentInput.value = ''; addTextColorInput.value = "#000000"; addTextBgColorInput.value = "#ffffff"; addTextSizeInput.value = "20"; addTextBorderVisibleCheckbox.checked = true; checkAddTextButtonState();
      });
      canvas.addEventListener('mousedown', handleInteractionStart);
      canvas.addEventListener('mousemove', handleInteractionMove);
      canvas.addEventListener('mouseup', handleInteractionEnd);
      canvas.addEventListener('mouseup', handleInteractionEnd);
      canvas.addEventListener('mouseleave', handleInteractionEnd);
      canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleInteractionStart(e); }, { passive: false });
      canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleInteractionMove(e); }, { passive: false });
      canvas.addEventListener('touchend', handleInteractionEnd);
      canvas.addEventListener('touchcancel', handleInteractionEnd);
      connectButton.addEventListener('click', () => toggleMode('connect', connectButton));
      editUnitButton.addEventListener('click', () => toggleMode('edit-item', editUnitButton));
      if (drawModeButton) {
        drawModeButton.addEventListener('click', () => toggleMode('draw-path', drawModeButton));
      }
      groupButton.addEventListener('click', () => toggleMode('grouping', groupButton));
      saveCanvasButton.addEventListener('click', async () => {
        console.log("保存ボタンがクリックされました！");

        const mainCanvasElement = document.getElementById('family-tree-canvas');
        if (!mainCanvasElement) {
          console.error("保存処理エラー: メインキャンバス要素が見つかりません。");
          alert("保存処理中にエラーが発生しました。メインキャンバスが見つかりません。");
          return;
        }
        const desiredBackgroundColor = '#fdfdfd'; // ★ 最終的な画像の背景色
        console.log("保存画像の背景色として使用する色:", desiredBackgroundColor);

        // 情報エリアのスタイル定義
        const INFO_AREA_BACKGROUND_COLOR = '#ffffff'; // 必要なら情報エリアだけ別の背景色にもできる
        const INFO_DEFAULT_TEXT_COLOR = '#000000';
        const INFO_HEADER_TEXT_COLOR = '#000000'; // ヘッダーの色
        const INFO_SECONDARY_TEXT_COLOR = '#555555'; // 補足情報の色
        const INFO_ERROR_TEXT_COLOR = '#e74c3c'; // エラーメッセージの色
        const INFO_INDENT_SIZE = 15; // インデント幅 (ピクセル)

        // ... (minX, minY, maxX, maxY, contentExists の計算は変更なし) ...
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        let contentExists = false;
        const itemsToConsiderForBounds = [];
        [...units, ...groups, ...textItems].forEach(item => { itemsToConsiderForBounds.push({ x: item.x, y: item.y, width: item.width || 0, height: item.height || 0 }); });
        drawnPaths.forEach(path => { if (path.points && path.points.length > 0) { path.points.forEach(p => itemsToConsiderForBounds.push({ x: p[0], y: p[1], width: 0, height: 0 })); if (path.startX !== undefined) { itemsToConsiderForBounds.push({ x: path.startX, y: path.startY, width: 0, height: 0 }); } } });
        connections.forEach(conn => { const fromItem = findItemById(conn.fromId); const toItem = findItemById(conn.toId); if (fromItem) { itemsToConsiderForBounds.push({ x: fromItem.x, y: fromItem.y, width: fromItem.width, height: fromItem.height }); } if (toItem) { itemsToConsiderForBounds.push({ x: toItem.x, y: toItem.y, width: toItem.width, height: toItem.height }); } });
        if (itemsToConsiderForBounds.length === 0 && drawnPaths.length === 0 && connections.length === 0) { alert("保存する内容がキャンバスにありません。"); return; }
        itemsToConsiderForBounds.forEach(item => { contentExists = true; minX = Math.min(minX, item.x); minY = Math.min(minY, item.y); maxX = Math.max(maxX, item.x + (item.width || 0)); maxY = Math.max(maxY, item.y + (item.height || 0)); });
        if (!contentExists) { alert("保存する内容がキャンバスにありません。"); return; }
        if (maxX - minX < 1) maxX = minX + 50; if (maxY - minY < 1) maxY = minY + 50;

        const treePadding = 30;
        const treeContentWidth = maxX - minX;
        const treeContentHeight = maxY - minY;
        const treeDrawingAreaWidth = treeContentWidth + treePadding * 2;
        const treeDrawingAreaHeight = treeContentHeight + treePadding * 2;

        // --- 情報エリアコンテンツ構築準備 ---
        const infoAreaMinWidth = 350; // 情報エリアの最小幅
        const infoInternalPadding = 25; // 情報エリア内部の左右パディング
        const infoLineHeight = 24;      // 情報エリアの1行の高さ
        const infoFontSize = 15;        // 情報エリアの基本フォントサイズ
        const infoImageSize = 20;       // 推奨捕獲順の画像サイズ
        const infoImageTextGap = 5;     // 画像とテキストの間隔

        const infoAreaContent = []; // { type: 'text'/'image'/'header'/'separator', content: '...', color: '...', indent: 0, imageUrl?: '...' }
        const captureImagesToLoad = {}; // { url: {img: Image | null, loaded: boolean, error: boolean } }

        // ヘルパー関数: 情報行を追加
        const addInfo = (type, content, options = {}) => {
          infoAreaContent.push({
            type: type,
            content: content,
            color: options.color || INFO_DEFAULT_TEXT_COLOR,
            indent: options.indent || 0,
            imageUrl: options.imageUrl || null,
            isBold: options.isBold || false
          });
          if (options.imageUrl && !captureImagesToLoad[options.imageUrl]) {
            captureImagesToLoad[options.imageUrl] = { img: null, loaded: false, error: false };
          }
        };

        // --- 必要作物 ---
        addInfo('header', "--- 必要作物 ---", { isBold: true, color: INFO_HEADER_TEXT_COLOR });
        const cropListItems = requiredCropsList.querySelectorAll('li.crop-list-item');
        if (cropListItems.length > 0) {
          cropListItems.forEach(item => {
            const foodTextContent = item.textContent ? item.textContent.trim() : "情報なし";
            const foodNameMatch = foodTextContent.match(/^([\u3040-\u309F\u30A0-\u30FF\uFF00-\uFFEF\w]+):/);
            const foodName = foodNameMatch ? foodNameMatch[1] : null;
            const foodColor = foodName && typeof cropColors !== 'undefined' && cropColors[foodName] ? cropColors[foodName] : INFO_DEFAULT_TEXT_COLOR;
            addInfo('bullet', foodTextContent, { indent: 1, color: foodColor });
          });
        } else { addInfo('text', "なし", { indent: 1 }); }
        addInfo('separator', ''); // 区切り線やスペースの代わり

        // --- 必要ゴールド ---
        addInfo('header', "--- 必要ゴールド ---", { isBold: true, color: INFO_HEADER_TEXT_COLOR });
        addInfo('text', document.getElementById('total-gold-cost').textContent, { indent: 1 });
        const goldDetailsNode = document.getElementById('gold-details');
        const plainGoldDetails = goldDetailsNode ? goldDetailsNode.textContent.replace(/\(\s*内訳[^)]*\)/g, '').trim() : "";
        addInfo('text', `(${plainGoldDetails})`, { indent: 1, color: INFO_SECONDARY_TEXT_COLOR });
        addInfo('separator', '');

        // --- 推奨捕獲順 ---
        const targetIndividualForSave = units.find(u => u.isTargetIndividual === true);
        if (targetIndividualForSave && targetIndividualForSave.type === 'unit' && targetIndividualForSave.activeSlotKeys?.length === 1) {
          const { sakiParent, atoParent, birthPartner, error: dtprError } = determineTargetParentRoles(targetIndividualForSave);
          if (!dtprError && sakiParent && atoParent) {
            addInfo('header', "--- 推奨捕獲順 ---", { isBold: true, color: INFO_HEADER_TEXT_COLOR });
            addInfo('text', `目標: ${getItemDisplayName(targetIndividualForSave)}`, { indent: 1 });
            if (sakiParent) addInfo('text', `先の親系統: ${getItemDisplayName(sakiParent)}`, { indent: 2 });
            if (atoParent) addInfo('text', `後の親系統: ${getItemDisplayName(atoParent)}`, { indent: 2 });
            if (birthPartner) addInfo('text', `出生の相方(参考): ${getItemDisplayName(birthPartner)}`, { indent: 2, color: INFO_SECONDARY_TEXT_COLOR });
            addInfo('separator', '');

            const capturePhasesElements = document.getElementById('recommended-capture-order-content')?.querySelectorAll('.capture-phase');
            if (capturePhasesElements && capturePhasesElements.length > 0) {
              capturePhasesElements.forEach(phaseEl => {
                const phaseTitle = phaseEl.querySelector('h5')?.textContent || "フェーズ";
                addInfo('header', phaseTitle, { indent: 1, isBold: true }); // フェーズタイトル
                const phaseItems = phaseEl.querySelectorAll('li');
                if (phaseItems.length > 0) {
                  phaseItems.forEach(li => {
                    const unitName = li.querySelector('strong')?.textContent || "不明";
                    const imgSrc = li.querySelector('img')?.src; // 画像URL取得
                    let attributesText = "";
                    const monoColorSpan = li.querySelector('span[style*="color:#e74c3c"]'); // 単色
                    const garaSpan = li.querySelector('span[style*="color:#2ecc71"]');    // 柄
                    if (monoColorSpan) attributesText = monoColorSpan.textContent.trim();
                    else if (garaSpan) attributesText = garaSpan.textContent.trim();
                    const roleText = li.querySelector('small') ? li.querySelector('small').textContent.trim() : "";

                    // ★ 画像とテキストを1行の情報として追加
                    addInfo('imageText', `${unitName} ${attributesText}`, { indent: 2, imageUrl: imgSrc });
                    if (roleText) addInfo('text', `(${roleText})`, { indent: 3, color: INFO_SECONDARY_TEXT_COLOR });
                  });
                } else { addInfo('text', "(該当なし)", { indent: 2, color: INFO_SECONDARY_TEXT_COLOR }); }
                addInfo('separator', ''); // 各フェーズの後
              });
            } else { addInfo('text', "(表示できる捕獲順がありません)", { indent: 1, color: INFO_SECONDARY_TEXT_COLOR }); }
          } else if (dtprError) {
            addInfo('header', "--- 推奨捕獲順 ---", { isBold: true, color: INFO_HEADER_TEXT_COLOR });
            addInfo('text', `(エラー: ${dtprError})`, { indent: 1, color: INFO_ERROR_TEXT_COLOR });
          }
        } else if (targetIndividualForSave) { // 目標設定はあるが無効な場合
          addInfo('header', "--- 推奨捕獲順 ---", { isBold: true, color: INFO_HEADER_TEXT_COLOR });
          addInfo('text', "(目標個体の設定が無効です)", { indent: 1, color: INFO_ERROR_TEXT_COLOR });
        }
        addInfo('separator', '');
        addInfo('text', "Generated by DenpaKakeizuTool", { color: "#aaaaaa" });


        // --- 情報エリアの幅と高さを計算 ---
        let maxInfoTextWidth = 0;
        let calculatedInfoAreaHeight = infoInternalPadding; // 開始パディング
        const tempMeasureCtx = document.createElement('canvas').getContext('2d');
        if (!tempMeasureCtx) { /* エラー処理 */ return; }

        infoAreaContent.forEach(line => {
          tempMeasureCtx.font = line.isBold ? `bold ${infoFontSize}px ${DEFAULT_FONT}` : `${infoFontSize}px ${DEFAULT_FONT}`;
          let lineContent = "";
          let lineIndentWidth = (line.indent || 0) * INFO_INDENT_SIZE;

          if (line.type === 'imageText' && line.imageUrl) {
            lineContent = line.content || "";
            maxInfoTextWidth = Math.max(maxInfoTextWidth, lineIndentWidth + infoImageSize + infoImageTextGap + tempMeasureCtx.measureText(lineContent).width);
            calculatedInfoAreaHeight += Math.max(infoLineHeight, infoImageSize); // 高さは画像とテキストの高い方
          } else if (line.type === 'bullet') {
            lineContent = line.content || "";
            const bulletIndent = (line.indent || 0) * INFO_INDENT_SIZE;
            const bulletRadius = infoFontSize * 0.28;
            const bulletGap = infoInternalPadding / 4;
            maxInfoTextWidth = Math.max(maxInfoTextWidth, bulletIndent + bulletRadius * 2 + bulletGap + tempMeasureCtx.measureText(lineContent).width);
            calculatedInfoAreaHeight += infoLineHeight;
          } else if (line.type === 'separator') {
            calculatedInfoAreaHeight += infoLineHeight / 2; // 区切り線のスペース
          } else { // text or header
            lineContent = line.content || "";
            maxInfoTextWidth = Math.max(maxInfoTextWidth, lineIndentWidth + tempMeasureCtx.measureText(lineContent).width);
            calculatedInfoAreaHeight += infoLineHeight;
          }
        });
        calculatedInfoAreaHeight += infoInternalPadding; // 終了パディング

        const calculatedInfoAreaWidth = Math.max(infoAreaMinWidth, maxInfoTextWidth + infoInternalPadding * 2);
        const spaceBetweenTreeAndInfo = 25;
        const finalCanvasWidth = treeDrawingAreaWidth + calculatedInfoAreaWidth + spaceBetweenTreeAndInfo;
        const finalCanvasHeight = Math.max(treeDrawingAreaHeight, calculatedInfoAreaHeight);


        // ★ 画像の事前読み込み
        const loadImagePromises = Object.keys(captureImagesToLoad).map(url => {
          return new Promise((resolve) => {
            const img = new Image();
            // CORS問題を回避しようとする試み (効果があるかはサーバー設定次第)
            // img.crossOrigin = "Anonymous"; // 必要に応じてコメント解除
            img.onload = () => {
              captureImagesToLoad[url].img = img;
              captureImagesToLoad[url].loaded = true;
              resolve();
            };
            img.onerror = () => {
              captureImagesToLoad[url].error = true;
              console.warn("推奨捕獲順の画像読み込みエラー(事前):", url);
              resolve();
            };
            img.src = url;
          });
        });
        if (Object.keys(captureImagesToLoad).length > 0) {
          console.log(`推奨捕獲順の画像 ${Object.keys(captureImagesToLoad).length} 個を読み込みます...`);
          await Promise.all(loadImagePromises);
          console.log("画像の事前読み込み完了。");
        }

        // --- 描画処理 ---
        // 1. 家系図レイヤー (透過背景)
        const treeLayerCanvas = document.createElement('canvas');
        treeLayerCanvas.width = treeDrawingAreaWidth;
        treeLayerCanvas.height = treeDrawingAreaHeight;
        const treeLayerCtx = treeLayerCanvas.getContext('2d');
        if (!treeLayerCtx) { /* エラー処理 */ return; }
        try {
          // drawAllElementsOnContext の第5引数に true を渡し、背景を描画しないようにする
          drawAllElementsOnContext(
            treeLayerCtx, treeLayerCanvas,
            { units: units, groups: groups, connections: connections, textItems: textItems, drawnPaths: drawnPaths, drawnPathsInProgress: [], selectedItem: null, connectFromItem: null, itemsToGroup: [], isDrawing: false },
            { scale: 1, originX: -minX + treePadding, originY: -minY + treePadding, mode: null },
            true // isTransparentBackground = true
          );
        } catch (e) { /* エラー処理 */ return; }

        // 2. 最終出力キャンバス
        const finalOutputCanvas = document.createElement('canvas');
        finalOutputCanvas.width = finalCanvasWidth;
        finalOutputCanvas.height = finalCanvasHeight;
        const finalOutputCtx = finalOutputCanvas.getContext('2d');
        if (!finalOutputCtx) { /* エラー処理 */ return; }

        // 背景色で塗りつぶし
        finalOutputCtx.fillStyle = desiredBackgroundColor;
        finalOutputCtx.fillRect(0, 0, finalCanvasWidth, finalCanvasHeight);

        // 家系図レイヤーを描画
        finalOutputCtx.drawImage(treeLayerCanvas, 0, 0);

        // --- 情報エリアのテキストと画像を描画 ---
        finalOutputCtx.textBaseline = 'top'; // baselineをtopにするとY座標計算が楽
        let currentInfoY = infoInternalPadding; // 開始Y座標
        const infoAreaStartX = treeDrawingAreaWidth + spaceBetweenTreeAndInfo + infoInternalPadding; // 情報エリアの描画開始X

        infoAreaContent.forEach(line => {
          let currentLineHeight = infoLineHeight; // デフォルトの行高
          finalOutputCtx.font = line.isBold ? `bold ${infoFontSize}px ${DEFAULT_FONT}` : `${infoFontSize}px ${DEFAULT_FONT}`;
          finalOutputCtx.fillStyle = line.color;
          const indentWidth = (line.indent || 0) * INFO_INDENT_SIZE;
          let drawX = infoAreaStartX + indentWidth;

          if (line.type === 'header' || line.type === 'text') {
            finalOutputCtx.fillText(line.content, drawX, currentInfoY);
          } else if (line.type === 'bullet') {
            const bulletRadius = infoFontSize * 0.28;
            const bulletX = drawX + bulletRadius;
            const bulletY = currentInfoY + infoLineHeight / 2; // 行の中央に描画
            const textX = bulletX + bulletRadius + infoInternalPadding / 4;
            finalOutputCtx.beginPath();
            finalOutputCtx.arc(bulletX, bulletY, bulletRadius, 0, Math.PI * 2);
            finalOutputCtx.fillStyle = line.color; // ●の色
            finalOutputCtx.fill();
            finalOutputCtx.fillStyle = INFO_DEFAULT_TEXT_COLOR; // テキストは通常色
            finalOutputCtx.fillText(line.content, textX, currentInfoY);
          } else if (line.type === 'imageText' && line.imageUrl && captureImagesToLoad[line.imageUrl]) {
            const imgInfo = captureImagesToLoad[line.imageUrl];
            let imageDrawn = false;
            if (imgInfo.loaded && imgInfo.img) {
              try {
                const imageDrawY = currentInfoY + (infoLineHeight - infoImageSize) / 2; // 行の中で垂直中央揃え
                finalOutputCtx.drawImage(imgInfo.img, drawX, imageDrawY, infoImageSize, infoImageSize);
                drawX += infoImageSize + infoImageTextGap; // テキスト開始位置をずらす
                imageDrawn = true;
              } catch (e) { /* エラー処理 */ }
            } else if (imgInfo.error) {
              // エラー表示
              finalOutputCtx.fillStyle = INFO_ERROR_TEXT_COLOR;
              finalOutputCtx.fillText('×', drawX + infoImageSize / 2, currentInfoY + infoLineHeight / 2); // 中央揃え
              drawX += infoImageSize + infoImageTextGap;
            }
            // テキストを描画
            finalOutputCtx.fillStyle = line.color; // テキストの色に戻す
            finalOutputCtx.fillText(line.content, drawX, currentInfoY);
            currentLineHeight = Math.max(infoLineHeight, infoImageSize); // 行高を画像に合わせる
          } else if (line.type === 'separator') {
            currentLineHeight = infoLineHeight / 2; // 区切り線の高さ（スペース）
          }
          currentInfoY += currentLineHeight; // 次の行のY座標
        });


        // --- 画像生成とダウンロード ---
        try {
          const dataURL = finalOutputCanvas.toDataURL('image/png');
          const link = document.createElement('a');
          const timestamp = new Date().toISOString().replace(/[:.-]/g, '').slice(0, -4);
          link.download = `DenpaTree_${timestamp}.png`;
          link.href = dataURL;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        } catch (e) {
          console.error("画像のDataURL生成またはダウンロード中にエラー:", e);
          alert("画像の生成またはダウンロード中にエラーが発生しました。コンソールを確認してください。\nTainted canvasの問題かもしれません。");
        }
      }); // ★ saveCanvasButton リスナーの終わり
      document.addEventListener('keydown', (e) => {
        if ((e.key === 'Delete' || e.key === 'Backspace') && selectedItem && !currentMode) {
          if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'SELECT' && document.activeElement.tagName !== 'TEXTAREA') {
            const displayName = getItemDisplayName(selectedItem);
            if (confirm(`「${truncateText(displayName, 15)}」を削除しますか？`)) {
              if (selectedItem.type === 'unit' || selectedItem.type === 'image-collection') { units = units.filter(unit => unit.id !== selectedItem.id); groups.forEach(g => g.itemIds = g.itemIds.filter(id => id !== selectedItem.id)); }
              else if (selectedItem.type === 'group') { const uIG = [...selectedItem.itemIds]; units = units.filter(u => !uIG.includes(u.id)); connections = connections.filter(c => !uIG.includes(c.fromId) && !uIG.includes(c.toId)); groups = groups.filter(g => g.id !== selectedItem.id); }
              else if (selectedItem.type === 'text') { textItems = textItems.filter(t => t.id !== selectedItem.id); }
              connections = connections.filter(conn => conn.fromId !== selectedItem.id && conn.toId !== selectedItem.id);
              if (connectFromItem && connectFromItem.id === selectedItem.id) connectFromItem = null;
              selectedItem = null; saveState(); drawCanvas(); updateInfoModal();
            }
          }
        }
      });
      zoomInButton.addEventListener('click', () => { zoomLevel++; updateZoom(); });
      zoomOutButton.addEventListener('click', () => { zoomLevel--; updateZoom(); });
      canvas.addEventListener('wheel', (event) => { event.preventDefault(); const d = event.deltaY > 0 ? -1 : 1; const oS = scale; zoomLevel += d; scale = Math.pow(1.2, zoomLevel); zoomLevelIndicator.textContent = zoomLevel; const r = canvas.getBoundingClientRect(); const mX = event.clientX - r.left, mY = event.clientY - r.top; const mCXB = (mX - originX) / oS, mCYB = (mY - originY) / oS; originX = mX - mCXB * scale; originY = mY - mCYB * scale; drawCanvas(); }, { passive: false });
      unitEditModalCloseButton.addEventListener('click', () => {
        closeModal(unitEditModal);
        editingUnit = null;
        editingGroup = null;
        editingTextItem = null;
        editingCollectionUnit = null;
        editingLine = null;
        currentEditingUnitContext = null;
      });
      unitEditCancelButton.addEventListener('click', () => {
        closeModal(unitEditModal);
        editingUnit = null;
        editingGroup = null;
        editingTextItem = null;
        editingCollectionUnit = null;
        editingLine = null;
        currentEditingUnitContext = null;
        if (currentMode === 'edit-item') toggleMode(null);
      });
      unitEditApplyButton.addEventListener('click', () => {
        if (editingUnit) {
          const borderCheckbox = document.getElementById('unit-edit-border-visible');
          if (borderCheckbox) {
            editingUnit.borderVisible = borderCheckbox.checked;
          }

          const monocolorCheckbox = document.getElementById('unit-edit-is-monocolor');
          if (monocolorCheckbox) {
            editingUnit.isMonocolor = monocolorCheckbox.checked;
          }

          const targetIndividualCheckbox = document.getElementById('unit-edit-is-target-individual');
          if (targetIndividualCheckbox) {
            const newTargetState = targetIndividualCheckbox.checked;
            if (!targetIndividualCheckbox.disabled) {
              if (newTargetState && editingUnit.isTargetIndividual !== true) {
                units.forEach(u => {
                  if (u.id !== editingUnit.id) {
                    u.isTargetIndividual = false;
                  }
                });
              }
              editingUnit.isTargetIndividual = newTargetState;
            }
          }

          document.querySelectorAll('#unit-edit-modal-body .unit-edit-slot-name').forEach(input => {
            const slotKey = input.dataset.slotKey;
            if (!editingUnit.slots[slotKey] && input.value.trim()) {
              editingUnit.slots[slotKey] = { name: input.value.trim(), food: '未選択', order: null, img: null, imgDataUrl: null, originalDataUrl: null, fileName: null };
            } else if (editingUnit.slots[slotKey]) {
              editingUnit.slots[slotKey].name = input.value.trim();
            } else if (!input.value.trim() && editingUnit.slots[slotKey]) {
              editingUnit.slots[slotKey].name = '';
            }
          });
          document.querySelectorAll('#unit-edit-modal-body .unit-edit-slot-food').forEach(select => {
            const slotKey = select.dataset.slotKey;
            const selectedFood = select.value;
            if (!editingUnit.slots[slotKey]) {
              if (selectedFood !== '未選択') {
                editingUnit.slots[slotKey] = { name: '', food: selectedFood, order: null, img: null, imgDataUrl: null, originalDataUrl: null, fileName: null };
              }
            } else {
              editingUnit.slots[slotKey].food = selectedFood;
            }
          });
          ['qr1', 'qr2'].forEach(sk => {
            if (editingUnit.slots[sk]) {
              const sakiChk = document.getElementById(`unit-edit-${sk}-order-先`);
              const atoChk = document.getElementById(`unit-edit-${sk}-order-後`);
              if (sakiChk && sakiChk.checked) {
                editingUnit.slots[sk].order = '先';
              } else if (atoChk && atoChk.checked) {
                editingUnit.slots[sk].order = '後';
              } else {
                editingUnit.slots[sk].order = null;
              }
            }
          });

          editingUnit.height = calculateUnitHeight(editingUnit.slots);
          editingUnit.activeSlotKeys = Object.keys(editingUnit.slots).filter(k => editingUnit.slots[k]?.img || editingUnit.slots[k]?.imgDataUrl);
          const imageCount = editingUnit.activeSlotKeys.length;
          if (imageCount === 1) editingUnit.width = UNIT_WIDTH_ONE_SLOT;
          else if (imageCount === 2) editingUnit.width = UNIT_WIDTH_TWO_SLOTS;
          else editingUnit.width = UNIT_WIDTH_THREE_SLOTS;

          saveState();
          drawCanvas();
          updateInfoModal();
          closeModal(unitEditModal);
          editingUnit = null;
          currentEditingUnitContext = null;
          if (currentMode === 'edit-item') toggleMode(null);

        } else if (editingLine) {
          const colorInput = document.getElementById('line-edit-color');
          const lineWidthInput = document.getElementById('line-edit-lineWidth');
          const lineDashSelect = document.getElementById('line-edit-dashType');

          if (colorInput) {
            editingLine.color = colorInput.value;
          }
          if (lineWidthInput) {
            const newWidth = parseInt(lineWidthInput.value, 10);
            if (!isNaN(newWidth) && newWidth >= 1 && newWidth <= 50) {
              editingLine.lineWidth = newWidth;
            } else {
              alert("線の太さの値が不正です。1から50の間で入力してください。");
              return;
            }
          }
          if (lineDashSelect) {
            try {
              editingLine.dashArray = JSON.parse(lineDashSelect.value);
            } catch (e) {
              console.error("線の種類の値のパースに失敗しました:", e);
              editingLine.dashArray = [];
            }
          }

          saveState();
          drawCanvas();
          closeModal(unitEditModal);
          editingLine = null;
          if (currentMode === 'edit-item') toggleMode(null);
        }
      });
      unitEditDuplicateButton.addEventListener('click', () => {
        if (editingUnit) {
          const newUnitData = JSON.parse(JSON.stringify({
            ...editingUnit,
            slots: Object.fromEntries(
              Object.entries(editingUnit.slots).map(([key, slot]) => [
                key,
                slot ? { ...slot, img: null } : null
              ])
            )
          }));

          newUnitData.id = `item-${nextItemId++}`;
          newUnitData.x += 30 / scale;
          newUnitData.y += 30 / scale;
          newUnitData.isSelected = false;

          const imageLoadPromises = Object.keys(newUnitData.slots).map(async slotKey => {
            const slot = newUnitData.slots[slotKey];
            if (slot && slot.imgDataUrl) {
              const img = new Image();
              img.src = slot.imgDataUrl;
              try {
                await img.decode();
                slot.img = img;
              } catch (e) {
                console.error(`複製時エラー: 画像 ${slot.fileName} の読み込みに失敗`, e);
                slot.img = null; // 読み込み失敗時はnull
              }
            }
          });

          Promise.all(imageLoadPromises).then(() => {
            newUnitData.activeSlotKeys = Object.keys(newUnitData.slots).filter(k => newUnitData.slots[k]?.img || newUnitData.slots[k]?.imgDataUrl);
            const imageCount = newUnitData.activeSlotKeys.length;
            if (imageCount === 1) newUnitData.width = UNIT_WIDTH_ONE_SLOT;
            else if (imageCount === 2) newUnitData.width = UNIT_WIDTH_TWO_SLOTS;
            else newUnitData.width = UNIT_WIDTH_THREE_SLOTS;
            newUnitData.height = calculateUnitHeight(newUnitData.slots);

            units.push(newUnitData);
            saveState();
            drawCanvas();
            closeModal(unitEditModal);
            editingUnit = null;
            currentEditingUnitContext = null;
            if (currentMode === 'edit-item') toggleMode(null);
            alert("ユニットを複製しました。");
          }).catch(err => {
            console.error("複製時の画像読み込みでエラーが発生しました:", err);
            alert("ユニットの複製中にエラーが発生しました。");
          });
        }
      });
      unitEditDeleteButton.addEventListener('click', () => {
        if (editingUnit) {
          if (confirm(`ユニット「${getItemDisplayName(editingUnit)}」を削除しますか？`)) {
            units = units.filter(u => u.id !== editingUnit.id);
            connections = connections.filter(c => c.fromId !== editingUnit.id && c.toId !== editingUnit.id);
            groups.forEach(g => g.itemIds = g.itemIds.filter(id => id !== editingUnit.id));
            if (selectedItem && selectedItem.id === editingUnit.id) selectedItem = null;

            saveState();
            drawCanvas();
            updateInfoModal();
            closeModal(unitEditModal);
            editingUnit = null;
            currentEditingUnitContext = null;
            if (currentMode === 'edit-item') toggleMode(null);
          }
        } else if (editingLine) {
          if (confirm(`選択されている接続線 (ID: ${truncateText(editingLine.id, 15)}) を削除しますか？`)) {
            connections = connections.filter(conn => conn.id !== editingLine.id);
            if (selectedItem && selectedItem.id === editingLine.id) selectedItem = null;

            saveState();
            drawCanvas();
            closeModal(unitEditModal);
            editingLine = null;
            if (currentMode === 'edit-item') toggleMode(null);
          }
        }
      });
      groupEditModalCloseButton.addEventListener('click', () => { closeModal(groupEditModal); editingGroup = null; });
      groupEditCancelButton.addEventListener('click', () => { closeModal(groupEditModal); editingGroup = null; if (currentMode === 'edit-item') toggleMode(null); });
      groupEditApplyButton.addEventListener('click', () => {
        if (editingGroup) {
          editingGroup.name = groupEditNameInput.value.trim();
          editingGroup.borderVisible = groupEditBorderVisibleCheckbox.checked;
          saveState();
          drawCanvas();
          closeModal(groupEditModal);
          editingGroup = null;
          if (currentMode === 'edit-item') toggleMode(null); // 編集モードを解除
        }
      });
      groupEditUngroupButton.addEventListener('click', () => {
        if (editingGroup && confirm(`グループ「${editingGroup.name || '選択グループ'}」のグループ化を解除しますか？ (中のユニットは残ります)`)) {
          connections = connections.filter(c => c.fromId !== editingGroup.id && c.toId !== editingGroup.id);
          groups = groups.filter(g => g.id !== editingGroup.id);
          if (selectedItem && selectedItem.id === editingGroup.id) selectedItem = null;
          saveState();
          drawCanvas();
          closeModal(groupEditModal);
          editingGroup = null;
          if (currentMode === 'edit-item') toggleMode(null);
        }
      });
      if (groupEditDuplicateButton) {
        groupEditDuplicateButton.addEventListener('click', async () => {
          if (editingGroup) {
            const newGroupData = JSON.parse(JSON.stringify({
              ...editingGroup,
              id: `item-${nextItemId++}`,
              name: editingGroup.name ? `${editingGroup.name}_コピー` : "コピーされたグループ",
              x: editingGroup.x + 30 / scale,
              y: editingGroup.y + 30 / scale,
              isSelected: false,
              itemIds: []
            }));

            const newUnitPromises = [];
            const oldToNewIdMap = {};

            // 2. グループ内の各ユニットを複製
            for (const oldUnitId of editingGroup.itemIds) {
              const originalUnit = findItemById(oldUnitId);
              if (originalUnit) {
                const newUnitCopy = JSON.parse(JSON.stringify({
                  ...originalUnit,
                  slots: Object.fromEntries(
                    Object.entries(originalUnit.slots || {}).map(([key, slot]) => [
                      key,
                      slot ? { ...slot, img: null } : null
                    ])
                  )
                }));

                const newUnitId = `item-${nextItemId++}`;
                oldToNewIdMap[oldUnitId] = newUnitId;
                newUnitCopy.id = newUnitId;
                newUnitCopy.x = newGroupData.x + (originalUnit.x - editingGroup.x);
                newUnitCopy.y = newGroupData.y + (originalUnit.y - editingGroup.y);
                newUnitCopy.isSelected = false;

                newGroupData.itemIds.push(newUnitId);
                const imageLoadPromises = Object.keys(newUnitCopy.slots || {}).map(async slotKey => {
                  const slot = newUnitCopy.slots[slotKey];
                  if (slot && slot.imgDataUrl) {
                    const img = new Image();
                    img.src = slot.imgDataUrl;
                    try {
                      await img.decode();
                      slot.img = img;
                    } catch (e) {
                      console.error(`複製時エラー(グループ内ユニット): 画像 ${slot.fileName} 読込失敗`, e);
                      slot.img = null;
                    }
                  }
                });
                newUnitPromises.push(Promise.all(imageLoadPromises).then(() => units.push(newUnitCopy)));
              }
            }

            await Promise.all(newUnitPromises);

            groups.push(newGroupData);
            saveState();
            drawCanvas();
            closeModal(groupEditModal);
            editingGroup = null;
            if (currentMode === 'edit-item') toggleMode(null);
            alert("グループを複製しました。");
          }
        });
      }
      groupEditDeleteButton.addEventListener('click', () => {
        if (editingGroup && confirm(`グループ「${editingGroup.name || '選択グループ'}」と、内部の全てのユニットを削除しますか？`)) {
          const unitIdsInGroup = [...editingGroup.itemIds];
          units = units.filter(u => !unitIdsInGroup.includes(u.id));
          connections = connections.filter(c =>
            c.fromId !== editingGroup.id && c.toId !== editingGroup.id &&
            !unitIdsInGroup.includes(c.fromId) && !unitIdsInGroup.includes(c.toId)
          );
          groups = groups.filter(g => g.id !== editingGroup.id);
          if (selectedItem && (selectedItem.id === editingGroup.id || unitIdsInGroup.includes(selectedItem.id))) {
            selectedItem = null;
          }
          saveState();
          drawCanvas();
          updateInfoModal();
          closeModal(groupEditModal);
          editingGroup = null;
          if (currentMode === 'edit-item') toggleMode(null);
        }
      });
      textEditModalCloseButton.addEventListener('click', () => { closeModal(textEditModal); editingTextItem = null; });
      textEditCancelButton.addEventListener('click', () => { closeModal(textEditModal); editingTextItem = null; if (currentMode === 'edit-item') toggleMode(null); });
      textEditApplyButton.addEventListener('click', () => {
        if (editingTextItem) {
          editingTextItem.text = document.getElementById('modal-text-content').value;
          editingTextItem.font = DEFAULT_FONT;
          editingTextItem.color = document.getElementById('modal-text-color').value;
          editingTextItem.backgroundColor = document.getElementById('modal-text-bgcolor').value;
          editingTextItem.fontSize = parseInt(document.getElementById('modal-text-size').value, 10);
          editingTextItem.borderVisible = document.getElementById('modal-text-border-visible').checked;
          editingTextItem.rotation = parseFloat(document.getElementById('modal-text-rotation').value) || 0;

          const textPaddingForCalc = TEXT_ITEM_PADDING;
          const measureForWidth = wrapTextAndMeasure(editingTextItem.text, Infinity, editingTextItem.fontSize, editingTextItem.font || DEFAULT_FONT, TEXT_LINE_HEIGHT_MULTIPLIER);
          editingTextItem.width = Math.max(MIN_TEXT_ITEM_WIDTH, measureForWidth.calculatedWidth + (textPaddingForCalc * 2));

          const finalMaxWidth = editingTextItem.width - (textPaddingForCalc * 2);
          let minHeight = Math.max(MIN_TEXT_ITEM_HEIGHT, editingTextItem.fontSize * TEXT_LINE_HEIGHT_MULTIPLIER + (textPaddingForCalc * 2));
          if (finalMaxWidth > 0) {
            const finalMeasured = wrapTextAndMeasure(editingTextItem.text, finalMaxWidth, editingTextItem.fontSize, editingTextItem.font || DEFAULT_FONT, TEXT_LINE_HEIGHT_MULTIPLIER);
            const newCalculatedHeight = finalMeasured.calculatedHeight + (textPaddingForCalc * 2);
            editingTextItem.height = Math.max(minHeight, newCalculatedHeight);
          } else {
            editingTextItem.height = minHeight;
          }

          saveState();
          drawCanvas();
          closeModal(textEditModal);
          editingTextItem = null;
          if (currentMode === 'edit-item') toggleMode(null);
        }
      });
      textEditDeleteButton.addEventListener('click', () => {
        if (editingTextItem && confirm(`テキスト「${truncateText(editingTextItem.text, 15)}」を削除しますか？`)) {
          textItems = textItems.filter(t => t.id !== editingTextItem.id);
          if (selectedItem && selectedItem.id === editingTextItem.id) selectedItem = null;
          saveState();
          drawCanvas();
          closeModal(textEditModal);
          editingTextItem = null;
          if (currentMode === 'edit-item') toggleMode(null);
        }
      });
      if (textEditDuplicateButton) { // ボタンが存在すればリスナーを設定
        textEditDuplicateButton.addEventListener('click', () => {
          if (editingTextItem) {
            const newTextItem = JSON.parse(JSON.stringify({
              ...editingTextItem,
              id: `item-${nextItemId++}`,
              x: editingTextItem.x + 20 / scale, // 少しずらす
              y: editingTextItem.y + 20 / scale,
              isSelected: false
            }));

            textItems.push(newTextItem);
            saveState();
            drawCanvas();
            closeModal(textEditModal);
            editingTextItem = null;
            if (currentMode === 'edit-item') toggleMode(null);
            alert("テキストを複製しました。");
          }
        });
      }
      showInfoModalButton.addEventListener('click', () => { updateInfoModal(); openModal(infoModal); });
      infoModalCloseButtonHeader.addEventListener('click', () => closeModal(infoModal));
      infoModalCloseButtonFooter.addEventListener('click', () => closeModal(infoModal));

      modalOverlay.addEventListener('click', (e) => {
        if (e.target === modalOverlay) {
          if (cropperModal.style.display === 'block' || cropperModal.style.display === 'flex') {
            if (currentEditingUnitContext === 'unit-edit-modal' || currentEditingUnitContext === 'collection-edit-modal') closeCropperModal(); else closeModal(cropperModal);
          } else if (unitEditModal.style.display === 'block' || unitEditModal.style.display === 'flex') {
            closeModal(unitEditModal);
            editingUnit = null;
            editingGroup = null;
            editingTextItem = null;
            editingCollectionUnit = null;
            editingLine = null;
            currentEditingUnitContext = null;
          } else if (groupEditModal.style.display === 'block' || groupEditModal.style.display === 'flex') {
            closeModal(groupEditModal); editingGroup = null;
          } else if (textEditModal.style.display === 'block' || textEditModal.style.display === 'flex') {
            closeModal(textEditModal); editingTextItem = null;
          } else if (infoModal.style.display === 'block' || infoModal.style.display === 'flex') {
            closeModal(infoModal);
          }
        }
      });

      collectionEditModalCloseButton.addEventListener('click', () => { closeModal(collectionEditModal); editingCollectionUnit = null; });
      collectionEditCancelButton.addEventListener('click', () => { closeModal(collectionEditModal); editingCollectionUnit = null; if (currentMode === 'edit-item') toggleMode(null); });
      collectionEditApplyButton.addEventListener('click', () => {
        if (!editingCollectionUnit) return;

        editingCollectionUnit.name = collectionEditNameInput.value.trim();
        editingCollectionUnit.borderVisible = collectionEditBorderCheckbox.checked;
        editingCollectionUnit.layoutSettings = {
          maxSize: parseInt(document.getElementById('collection-edit-max-size').value, 10) || COLLECTION_IMAGE_MAX_SIZE,
          margin: parseInt(document.getElementById('collection-edit-margin').value, 10) || COLLECTION_IMAGE_MARGIN,
          padding: parseInt(document.getElementById('collection-edit-padding').value, 10) || COLLECTION_PADDING,
          textGap: parseInt(document.getElementById('collection-edit-text-gap').value, 10) || minTextGapLogical,
          perRow: parseInt(document.getElementById('collection-edit-per-row').value, 10) || COLLECTION_IMAGES_PER_ROW,
          fontSize: parseInt(document.getElementById('collection-edit-font-size').value, 10) || textFontSizeLogical
        };
        editingCollectionUnit.layoutSettings.maxSize = Math.max(10, editingCollectionUnit.layoutSettings.maxSize);
        editingCollectionUnit.layoutSettings.margin = Math.max(0, editingCollectionUnit.layoutSettings.margin);
        editingCollectionUnit.layoutSettings.padding = Math.max(0, editingCollectionUnit.layoutSettings.padding);
        editingCollectionUnit.layoutSettings.textGap = Math.max(0, editingCollectionUnit.layoutSettings.textGap);
        editingCollectionUnit.layoutSettings.perRow = Math.max(1, editingCollectionUnit.layoutSettings.perRow);
        editingCollectionUnit.layoutSettings.fontSize = Math.max(6, editingCollectionUnit.layoutSettings.fontSize);


        const updatedImagesData = [];
        const listItems = collectionEditImageList.querySelectorAll('li');

        listItems.forEach(item => {
          if (item.dataset.deleted !== 'true') {
            const originalIndex = parseInt(item.dataset.originalIndex, 10);

            if (isNaN(originalIndex) || !editingCollectionUnit.images[originalIndex]) {
              console.warn("collectionEditApplyButton: データ不整合の可能性。originalIndex:", originalIndex, "アイテム:", item, "現在の画像配列の長さ:", editingCollectionUnit.images.length);
              return;
            }

            const imageDataFromMaster = editingCollectionUnit.images[originalIndex];

            const nameInput = item.querySelector('input[data-field="name"]');
            const foodSelect = item.querySelector('select[data-field="food"]');

            updatedImagesData.push({
              img: imageDataFromMaster.img,
              imgDataUrl: imageDataFromMaster.imgDataUrl,
              originalDataUrl: imageDataFromMaster.originalDataUrl,
              fileName: imageDataFromMaster.fileName,
              name: nameInput ? nameInput.value.trim() : imageDataFromMaster.name,
              food: foodSelect ? foodSelect.value : imageDataFromMaster.food
            });
          }
        });

        editingCollectionUnit.images = updatedImagesData;


        const { width: newWidth, height: newHeight } = calculateImageCollectionUnitSize(editingCollectionUnit.images, editingCollectionUnit.layoutSettings);
        editingCollectionUnit.width = newWidth;
        editingCollectionUnit.height = newHeight;

        // 変更を保存し、UIを更新
        saveState();
        drawCanvas();
        updateInfoModal();
        closeModal(collectionEditModal);
        editingCollectionUnit = null;
        if (currentMode === 'edit-item') toggleMode(null);
      });
      collectionEditDeleteButton.addEventListener('click', () => {
        if (editingCollectionUnit && confirm(`画像集合ユニット「${getItemDisplayName(editingCollectionUnit)}」を削除しますか？ (内部の画像も全て削除されます)`)) {
          units = units.filter(u => u.id !== editingCollectionUnit.id);
          connections = connections.filter(c => c.fromId !== editingCollectionUnit.id && c.toId !== editingCollectionUnit.id);
          groups.forEach(g => g.itemIds = g.itemIds.filter(id => id !== editingCollectionUnit.id));
          if (selectedItem && selectedItem.id === editingCollectionUnit.id) selectedItem = null;
          saveState(); drawCanvas(); updateInfoModal(); closeModal(collectionEditModal);
          editingCollectionUnit = null; if (currentMode === 'edit-item') toggleMode(null);
        }
      });
      if (resetLayoutButton) {
        resetLayoutButton.addEventListener('click', () => {
          if (!editingCollectionUnit) return;
          document.getElementById('collection-edit-max-size').value = COLLECTION_IMAGE_MAX_SIZE;
          document.getElementById('collection-edit-margin').value = COLLECTION_IMAGE_MARGIN;
          document.getElementById('collection-edit-padding').value = COLLECTION_PADDING;
          document.getElementById('collection-edit-text-gap').value = minTextGapLogical;
          document.getElementById('collection-edit-per-row').value = COLLECTION_IMAGES_PER_ROW;
          document.getElementById('collection-edit-font-size').value = textFontSizeLogical;
        });
      }
      clearImageCollectionButton.addEventListener('click', () => {
        imageCollectionUploadInput.value = ''; uploadedCollectionImages = [];
        imageCollectionPreviewsDiv.innerHTML = ''; imageCollectionDetailsDiv.innerHTML = '';
        if (clearImageCollectionButton) clearImageCollectionButton.classList.add('hidden');
        checkAddImageCollectionButtonState();
      });
      if (clearStorageButton) {
        clearStorageButton.addEventListener('click', () => {
          if (confirm("保存されている家系図データを全て削除し、完全に新規の状態から開始します。よろしいですか？")) {
            try {
              localStorage.removeItem('kakeizuToolState');
              console.log("ローカルストレージのデータを削除しました。");
            } catch (e) {
              console.error("ローカルストレージのデータ削除に失敗しました:", e);
            }
            // 状態を完全に初期化
            units = []; groups = []; textItems = []; connections = []; nextItemId = 0;
            selectedItem = null; connectFromItem = null; itemsToGroup = [];
            drawnPaths = [];
            currentDrawingPath = [];
            isDrawing = false;
            if (drawingToolsPanel) drawingToolsPanel.style.display = 'none';
            if (currentMode) toggleMode(null);
            history = []; historyIndex = -1;
            scale = 1.0; zoomLevel = 0; originX = 0; originY = 0;
            zoomLevelIndicator.textContent = zoomLevel;

            drawCanvas();
            updateInfoModal();
            updateUndoRedoButtons();
            alert("データがクリアされました。ページをリロードするか、このまま新規作成を開始してください。");
          }
        });
      }
      if (drawingColorPicker) {
        drawingColorPicker.addEventListener('input', (e) => { drawingColor = e.target.value; });
      }
      if (drawingLineWidthSlider) {
        drawingLineWidthSlider.addEventListener('input', (e) => {
          drawingLineWidth = parseInt(e.target.value, 10);
          if (drawingLineWidthValue) drawingLineWidthValue.textContent = drawingLineWidth;
        });
      }
      if (drawingShapeSelect) {
        drawingShapeSelect.addEventListener('change', (e) => {
          drawingShape = e.target.value;
          updateFillOptionVisibility();
        });
      }
      if (clearAllDrawingsButton) {
        clearAllDrawingsButton.addEventListener('click', () => {
          if (confirm("キャンバス上のすべての手書き描画を消去しますか？")) {
            drawnPaths = [];
            resetDrawingHistory();
            drawCanvas();
          }
        });
      }
      if (drawingUndoButton) {
        drawingUndoButton.addEventListener('click', undoDrawing);
      }
      if (drawingRedoButton) {
        drawingRedoButton.addEventListener('click', redoDrawing);
      }

      if (unifySizeButton) {
        unifySizeButton.addEventListener('click', () => {
          if (currentMode && currentMode.startsWith('unify-size')) {
            toggleMode(null);
            unifySizeModeSubState = null;
            unifySizeBaseUnit = null;
            unifySizeTargetUnits.forEach(u => u.isTargetSelectedForUnify = false);
            unifySizeTargetUnits = [];
            drawCanvas();
            const unifySizeCompleteSelectionBtn = document.getElementById('unify-size-complete-selection-btn');
            if (unifySizeCompleteSelectionBtn) unifySizeCompleteSelectionBtn.style.display = 'none';

          } else {
            toggleMode('unify-size-select-base', unifySizeButton);
          }
        });
      }

      const unifyAllUnitsBtn = document.getElementById('unify-all-units-btn');
      const unifyVisibleUnitsBtn = document.getElementById('unify-visible-units-btn');
      const unifySelectTargetsBtn = document.getElementById('unify-select-targets-btn');
      const unifySizeOptionsModalCancelBtn = document.getElementById('unify-size-options-modal-cancel-btn');
      const unifySizeCompleteSelectionBtn = document.getElementById('unify-size-complete-selection-btn');
      const unifyOptionsModal = document.getElementById('unify-size-options-modal'); // モーダル要素取得

      if (unifyAllUnitsBtn) {
        unifyAllUnitsBtn.addEventListener('click', () => {
          if (!unifySizeBaseUnit) return;
          closeModal(unifyOptionsModal);
          if (confirm(`家系図上の全ての同種ユニットを「${getItemDisplayName(unifySizeBaseUnit)}」のサイズに統一しますか？`)) {
            performUnifySize(unifySizeBaseUnit, 'all');
          }
          toggleMode(null);
        });
      }

      if (unifyVisibleUnitsBtn) {
        unifyVisibleUnitsBtn.addEventListener('click', () => {
          if (!unifySizeBaseUnit) return;
          closeModal(unifyOptionsModal);
          if (confirm(`現在画面に表示されている同種ユニットを「${getItemDisplayName(unifySizeBaseUnit)}」のサイズに統一しますか？`)) {
            performUnifySize(unifySizeBaseUnit, 'visible');
          }
          toggleMode(null);
        });
      }

      if (unifySelectTargetsBtn) {
        unifySelectTargetsBtn.addEventListener('click', () => {
          if (!unifySizeBaseUnit) return;
          closeModal(unifyOptionsModal);
          unifySizeTargetUnits = [];
          units.forEach(u => u.isTargetSelectedForUnify = false);
          textItems.forEach(t => t.isTargetSelectedForUnify = false);
          toggleMode('unify-size-select-targets', unifySizeButton);
        });
      }

      if (unifySizeOptionsModalCancelBtn) {
        unifySizeOptionsModalCancelBtn.addEventListener('click', () => {
          closeModal(unifyOptionsModal);
          toggleMode(null);
        });
      }

      if (unifySizeCompleteSelectionBtn) {
        unifySizeCompleteSelectionBtn.addEventListener('click', () => {
          if (currentMode === 'unify-size-select-targets' && unifySizeBaseUnit) {
            if (unifySizeTargetUnits.length > 0) {
              if (confirm(`${unifySizeTargetUnits.length}個の選択されたユニットを「${getItemDisplayName(unifySizeBaseUnit)}」のサイズに統一しますか？`)) {
                performUnifySize(unifySizeBaseUnit, 'selected', [...unifySizeTargetUnits]);
                toggleMode(null);
              } else {
                showStatusBar(modeMessages['unify-size-select-targets'], unifySizeButton);
              }
            } else {
              alert("サイズを統一する対象ユニットが選択されていません。");
            }
          }
        });
      }
      const exportDataButton = document.getElementById('export-data-button');
      if (exportDataButton) {
        exportDataButton.addEventListener('click', () => {
          if (history.length === 0 || historyIndex < 0) {
            alert("エクスポートするデータがありません。");
            return;
          }

          // 現在の最新の状態を取得 (undoされていない最新の状態)
          const currentState = history[historyIndex]; // undo/redoを考慮してhistoryIndexのものをエクスポート

          if (!currentState) {
            alert("現在の状態を取得できませんでした。");
            return;
          }

          const exportableState = JSON.parse(JSON.stringify(currentState, (key, value) => {
            return value;
          }));

          const jsonString = JSON.stringify(exportableState, null, 2); // null, 2 で整形されたJSON文字列に
          const blob = new Blob([jsonString], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          const timestamp = new Date().toISOString().replace(/[:.-]/g, '').slice(0, -4);
          link.download = `denpa_kakeizu_data_${timestamp}.json`;
          link.href = url;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
          showStatusBar('家系図データをエクスポートしました。', exportDataButton);
        });
      }
      const importDataButton = document.getElementById('import-data-button');
      const importFileInput = document.getElementById('import-file-input');

      if (importDataButton && importFileInput) {
        importDataButton.addEventListener('click', () => {
          if (currentMode) { // 何らかのモードがアクティブな場合はインポートを中止
            alert(`現在のモード (${currentMode}) をキャンセルしてからインポートしてください。`);
            return;
          }
          if (confirm("JSONファイルからデータをインポートします。\n現在の作業内容は上書きされますが、よろしいですか？")) {
            importFileInput.click(); // ファイル選択ダイアログを開く
          }
        });

        importFileInput.addEventListener('change', async (event) => {
          const file = event.target.files[0];
          if (!file) {
            return;
          }

          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const jsonString = e.target.result;
              const importedState = JSON.parse(jsonString);

              if (typeof importedState !== 'object' || importedState === null ||
                (!importedState.units && !importedState.groups && !importedState.textItems && !importedState.connections)) {
                alert("無効なファイル形式か、家系図データが含まれていません。");
                return;
              }


              history = [];
              historyIndex = -1;

              drawnPaths = [];
              currentDrawingPath = [];
              isDrawing = false;
              if (drawingToolsPanel) drawingToolsPanel.style.display = 'none';

              await restoreState(importedState);
              history = [JSON.parse(JSON.stringify(importedState))];
              historyIndex = 0;


              updateUndoRedoButtons();
              updateInfoModal();
              // resizeCanvas(); // restoreStateの最後にdrawCanvasがあるので不要な場合も
              showStatusBar('家系図データをインポートしました。', importDataButton);

            } catch (error) {
              console.error("ファイルのインポート中にエラーが発生しました:", error);
              alert("ファイルのインポートに失敗しました。ファイル形式が正しいか確認してください。");
            } finally {
              importFileInput.value = '';
            }
          };
          reader.onerror = () => {
            console.error("ファイルの読み込み中にエラーが発生しました。");
            alert("ファイルの読み込みに失敗しました。");
            importFileInput.value = '';
          };
          reader.readAsText(file);
        });
      }


      // ========================================
      // 6. 初期化処理呼び出し
      // ========================================
      checkAddUnitButtonState();
      checkAddTextButtonState();
      checkAddImageCollectionButtonState();
      historyIndex = -1;

      async function initializeApp() {
        console.log("アプリケーション初期化開始");
        let restored = false;
        try {
          const savedStateString = localStorage.getItem('kakeizuToolState');
          if (savedStateString) {
            console.log("ローカルストレージから状態を復元します...");
            const savedState = JSON.parse(savedStateString);
            await restoreState(savedState);
            if (savedState.scale !== undefined) scale = savedState.scale;
            if (savedState.originX !== undefined) originX = savedState.originX;
            if (savedState.originY !== undefined) originY = savedState.originY;
            if (savedState.zoomLevel !== undefined) zoomLevel = savedState.zoomLevel;
            zoomLevelIndicator.textContent = zoomLevel;

            history = [savedState];
            historyIndex = 0;

            console.log("状態の復元が完了しました。");
            restored = true;
          } else {
            console.log("保存された状態は見つかりませんでした。新規作成します。");
            history = [];
            historyIndex = -1;
          }
        } catch (e) {
          console.error("ローカルストレージからの状態復元に失敗しました:", e);
          history = [];
          historyIndex = -1;
        }

        updateUndoRedoButtons();

        requestAnimationFrame(() => {
          console.log(restored ? "復元後の初回描画" : "新規作成時の初回描画");
          resizeCanvas();
          updateInfoModal();
          updateFillOptionVisibility();
          resetDrawingHistory();
        });
      }
      initializeApp();
      console.log("最終的なボタン初期表示設定 開始");
      if (leftPanel.classList.contains('collapsed')) {
        leftPanelToggleButton.innerHTML = '＞';
        leftPanelToggleButton.title = "左パネルを展開";
        leftPanelToggleButton.style.left = '0px';
        leftPanelToggleButton.classList.add('panel-is-closed');
        leftPanelToggleButton.classList.remove('panel-is-open');
        console.log("最終初期状態: パネルは収納");
      } else {
        leftPanelToggleButton.innerHTML = '＜';
        leftPanelToggleButton.title = "左パネルを収納";
        leftPanelToggleButton.style.left = `${leftPanel.offsetWidth}px`;
        leftPanelToggleButton.classList.add('panel-is-open');
        leftPanelToggleButton.classList.remove('panel-is-closed');
        console.log("最終初期状態: パネルは展開、ボタンleft:", leftPanelToggleButton.style.left, "パネル幅:", leftPanel.offsetWidth);
      }

    }); // DOMContentLoaded の終わり
  </script>
</body>

</html>
