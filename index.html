<!DOCTYPE html>
<html lang="ja">

<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-12G89V2JF3"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-12G89V2JF3');
  </script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>電波人間 家系図ツール</title>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet">
  <style>
    /* --- Base Styles --- */
    body,
    html {
      margin: 0;
      padding: 0;
      font-family: 'Noto Sans JP', sans-serif;
      /*height: 100%;*/
      background-color: #f4f4f4;
      color: #333;
      touch-action: manipulation;
      -ms-touch-action: manipulation;
    }

    .container {
      display: flex;
      flex-direction: column;
      position: relative;
      overflow: hidden;
    }

    .top-area {
      display: flex;
      flex-grow: 1;
      overflow: hidden;
      position: relative;
    }

    /* --- Left Panel --- */
    #left-panel-toggle-button {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      z-index: 1010;
      color: white;
      border: none;
      padding: 25px 15px;
      cursor: pointer;
      font-size: 1em;
      line-height: 1;
      box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
      transition: left 0.3s ease, background-color 0.3s ease, border-radius 0.3s ease;
      left: 340px;
      background-color: #007bff;
      border-top-left-radius: 5px;
      border-bottom-left-radius: 5px;
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    @media (max-width: 480px) {

      /* 例: 480px以下の画面幅で適用 */
      #left-panel-toggle-button {
        position: fixed;
        left: 0;
        /* 強制的に左端に */
        top: 45%;
        transform: translateY(-50%);
        padding: 30px 18px;
        font-size: 0.9em;
        border-top-left-radius: 0;
        border-bottom-left-radius: 0;
        border-top-right-radius: 5px;
        border-bottom-right-radius: 5px;
      }

      #left-panel-toggle-button:not(.panel-is-closed) {
        left: 0 !important;
      }

      #left-panel-toggle-button.panel-is-closed {
        background-color: #007bff;
      }
    }

    #left-panel-toggle-button.panel-is-closed {
      left: 0px !important;
      background-color: #007bff;
      border-top-right-radius: 5px;
      border-bottom-right-radius: 5px;
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
    }

    .left-panel {
      width: 340px;
      min-width: 340px;
      padding: 15px;
      background-color: #fff;
      border-right: 1px solid #ddd;
      overflow-y: auto;
      box-shadow: 2px 0 5px rgba(0, 0, 0, 0.05);
      display: flex;
      flex-direction: column;
      gap: 15px;
      z-index: 1005;
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      transform: translateX(0%);
      transition: transform 0.3s ease;
    }

    .left-panel.collapsed {
      transform: translateX(-100%);
    }

    .left-panel h2,
    .left-panel h3 {
      margin-top: 0;
      margin-bottom: 10px;
      color: #555;
      border-bottom: 1px solid #eee;
      padding-bottom: 5px;
    }

    .left-panel .panel-section small {
      display: block;
      font-size: 0.75em;
      color: #6c757d;
      margin-bottom: 10px;
      line-height: 1.4;
    }


    .left-panel .panel-section {
      background-color: #f9f9f9;
      padding: 12px;
      border-radius: 8px;
      border: 1px solid #eee;
      margin-bottom: 15px;
    }

    .left-panel .image-slot-group {
      border: 1px solid #e0e0e0;
      padding: 10px;
      margin-bottom: 15px;
      border-radius: 6px;
      background-color: #fff;
    }

    .left-panel .image-slot-group h4 {
      margin-top: 0;
      margin-bottom: 8px;
      font-size: 0.95em;
      color: #333;
    }

    .left-panel .file-input-wrapper {
      display: flex;
      flex-direction: column;
      margin-bottom: 5px;
      padding-left: 0;
    }

    .left-panel .file-input-wrapper .file-input-label {
      font-weight: bold;
      font-size: 0.8em;
      margin-bottom: 3px;
      text-align: left;
    }

    .left-panel .file-input-controls {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .left-panel .file-input-controls input[type="file"] {
      flex-grow: 1;
      font-size: 0.7em;
      padding: 4px;
      border: 1px solid #ccc;
      border-radius: 4px;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      max-width: calc(100% - 50px);
      color: #888;
    }

    .left-panel .file-input-controls input[type="file"]::file-selector-button {
      font-size: 0.9em;
      padding: 2px 6px;
      margin-right: 5px;
    }

    .left-panel .file-input-controls input[type="file"]:not(:placeholder-shown) {
      color: #333;
    }

    .left-panel .clear-image-button {
      padding: 4px 8px;
      font-size: 0.7em;
      background-color: #f8f9fa;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
      line-height: 1;
      height: fit-content;
      flex-shrink: 0;
    }

    .left-panel .clear-image-button:hover {
      background-color: #e9ecef;
    }

    .left-panel .clear-image-button.hidden {
      display: none;
    }


    .left-panel img.preview-image {
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #fff;
      display: block;
      margin: 8px auto;
      max-width: calc(100% - 16px);
      max-height: 60px;
      object-fit: contain;
    }

    .left-panel .post-preview-edit-button {
      display: block;
      width: calc(100% - 0px);
      margin: 5px 0 10px 0;
      padding: 5px 10px;
      font-size: 0.8em;
      background-color: #5bc0de;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .left-panel .post-preview-edit-button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    .left-panel .form-group {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      padding-left: 0;
    }

    .left-panel .form-group label {
      flex-basis: 70px;
      flex-shrink: 0;
      font-weight: bold;
      font-size: 0.8em;
      margin-bottom: 0;
      text-align: right;
    }

    .left-panel .form-group input[type="text"],
    .left-panel .form-group select,
    .left-panel .form-group textarea {
      flex-grow: 1;
      padding: 6px 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 0.85em;
      box-sizing: border-box;
      margin-bottom: 0;
      width: auto;
    }


    .left-panel .form-group input[type="color"] {
      padding: 2px;
      height: 30px;
      flex-basis: 50px;
      min-width: 50px;
    }

    .left-panel .form-group input[type="number"] {
      width: 60px;
      flex-grow: 0;
    }


    .left-panel .order-checkbox-group {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-bottom: 8px;
      padding-left: 0;
      font-size: 0.75em;
    }

    .left-panel .order-checkbox-group .order-label {
      font-weight: bold;
      margin-right: 5px;
      flex-basis: auto;
      white-space: nowrap;
      text-align: right;
    }

    .left-panel .order-checkbox-group label {
      font-weight: normal;
      margin-right: 5px;
    }

    .left-panel .order-checkbox-group input[type="checkbox"] {
      margin-right: 1px;
    }

    .left-panel .form-group-checkbox {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      padding-left: 0;
    }

    .left-panel .form-group-checkbox label {
      flex-basis: auto;
      flex-shrink: 1;
      text-align: left;
      font-weight: normal;
      font-size: 0.85em;
    }

    #add-unit-border-visible-group label,
    #add-text-border-visible-group label,
    #image-collection-border-group label {
      flex-basis: 70px;
      flex-shrink: 0;
      font-weight: bold;
      font-size: 0.8em;
      text-align: right;
    }


    .left-panel .form-group-checkbox input[type="checkbox"] {
      margin-right: 1px;
    }


    .left-panel button.action-button {
      display: block;
      width: 100%;
      padding: 12px 15px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1em;
      transition: background-color 0.2s;
      margin-top: 15px;
    }

    .left-panel button.action-button:hover:not(:disabled) {
      background-color: #0056b3;
    }

    .left-panel button.action-button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    #image-collection-previews {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 10px;
      max-height: 150px;
      overflow-y: auto;
      border: 1px dashed #eee;
      padding: 5px;
      background-color: #f0f0f0;
    }

    #image-collection-previews img {
      width: 40px;
      height: 40px;
      object-fit: contain;
      border: 1px solid #ddd;
      background-color: white;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.2s;
    }

    #image-collection-previews img.selected-preview {
      opacity: 1.0;
      border-color: #007bff;
      box-shadow: 0 0 3px rgba(0, 123, 255, 0.5);
    }

    #image-collection-details {
      margin-top: 15px;
      border-top: 1px solid #eee;
      padding-top: 15px;
      max-height: 200px;
      overflow-y: auto;
    }

    #image-collection-details .detail-item {
      border: 1px dashed #ccc;
      padding: 8px;
      margin-bottom: 10px;
      border-radius: 4px;
      background-color: #fff;
    }

    #image-collection-details .detail-item p {
      font-size: 0.8em;
      margin: 0 0 5px 0;
      word-break: break-all;
      color: #555;
    }

    #image-collection-details .detail-item .form-group label {
      flex-basis: 50px;
    }

    #image-collection-details .detail-item .form-group input[type="text"] {
      font-size: 0.8em;
      padding: 4px 5px;
    }

    #image-collection-details .detail-item .form-group select {
      font-size: 0.8em;
      padding: 4px 5px;
    }


    /* --- Status Bar --- */
    #status-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      color: white;
      padding: 8px 15px;
      font-size: 0.9em;
      text-align: center;
      z-index: 1000;
      display: none;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      transition: background-color 0.3s ease;
    }

    /* --- Main Canvas Area --- */
    .main-canvas-area {
      flex-grow: 1;
      position: relative;
      overflow: auto;
      background-color: #e0e0e0;
    }

    #family-tree-canvas {
      display: block;
      background-color: #fdfdfd;
      cursor: grab;
    }

    #family-tree-canvas.dragging,
    #family-tree-canvas.connecting,
    #family-tree-canvas.grouping {
      cursor: grabbing;
    }

    #family-tree-canvas.mode-active {
      cursor: crosshair;
    }

    #family-tree-canvas.edit-mode {
      cursor: pointer;
    }

    /* --- Bottom Controls --- */
    .bottom-controls {
      padding: 8px 10px;
      background-color: #fff;
      border-top: 1px solid #ddd;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.05);
      flex-wrap: wrap;
      flex-shrink: 0;
      flex-wrap: nowrap;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      justify-content: flex-start;
      padding-bottom: calc(8px + env(safe-area-inset-bottom));
    }

    .bottom-controls button {
      padding: 8px 10px;
      background-color: #555;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.85em;
      min-width: 70px;
      transition: background-color 0.2s;
    }

    .bottom-controls button:hover:not(:disabled) {
      filter: brightness(1.2);
    }

    .bottom-controls button:disabled {
      filter: grayscale(50%);
      cursor: not-allowed;
      opacity: 0.7;
    }


    .bottom-controls button.active-mode-button {
      background-color: #dc3545 !important;
      color: white;
    }

    .bottom-controls button.active-mode-button:disabled {
      background-color: #f5c6cb !important;
      color: #721c24;
      filter: none;
      opacity: 0.8;
    }


    .bottom-controls button#undo-button,
    .bottom-controls button#redo-button {
      background-color: #ffc107;
      color: #333;
    }

    .bottom-controls button#undo-button:disabled,
    .bottom-controls button#redo-button:disabled {
      background-color: #ffeeba;
      color: #856404;
    }

    .bottom-controls button#connect-button {
      background-color: #17a2b8;
    }

    .bottom-controls button#edit-unit-button {
      background-color: #fd7e14;
    }

    .bottom-controls button#group-button {
      background-color: #6f42c1;
    }

    .bottom-controls button#unify-size-button {
      background-color: #20c997;
    }

    .bottom-controls button#align-button {
      background-color: #6A5ACD;
    }

    .bottom-controls button#draw-mode-button {
      background-color: #DA70D6;
    }

    .bottom-controls button#save-canvas-button {
      background-color: #28a745;
    }

    .bottom-controls button#zoom-in-button,
    .bottom-controls button#zoom-out-button {
      background-color: #6c757d;
    }

    #zoom-level-indicator {
      display: inline-block;
      min-width: 30px;
      padding: 0 5px;
      font-size: 0.9em;
      font-weight: bold;
      text-align: center;
      color: #555;
      border: 1px solid #ccc;
      border-radius: 4px;
      margin: 0 5px;
      line-height: 1.5;
    }

    /* --- Info Button --- */
    #info-button-container {
      position: fixed;
      top: 10px;
      right: 15px;
      z-index: 1001;
      transition: top 0.3s ease;
    }

    #info-button-container button {
      padding: 8px 12px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    /* --- Modal Styles --- */
    .modal-overlay {
      display: none;
      position: fixed;
      z-index: 1040;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
    }

    .modal {
      display: none;
      position: fixed;
      z-index: 1050;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background-color: #fff;
      padding: 20px;
      border: 1px solid #888;
      width: 80%;
      max-width: 500px;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      max-height: 90vh;
      overflow-y: auto;
    }

    #unit-edit-modal {
      z-index: 1050;
    }

    #cropper-modal {
      z-index: 1060;
    }

    #text-edit-modal {
      z-index: 1050;
    }


    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
      margin-bottom: 15px;
    }

    .modal-header h2 {
      margin: 0;
      font-size: 1.2em;
    }

    .modal-close-button {
      color: #aaa;
      font-size: 28px;
      font-weight: bold;
      background: none;
      border: none;
      cursor: pointer;
    }

    .modal-close-button:hover,
    .modal-close-button:focus {
      color: black;
    }

    .modal-body {
      padding-bottom: 15px;
    }

    .modal-footer {
      border-top: 1px solid #eee;
      padding-top: 15px;
      text-align: right;
    }

    .modal-footer button {
      padding: 8px 15px;
      margin-left: 10px;
      border-radius: 4px;
      cursor: pointer;
    }

    .modal-footer button.primary {
      background-color: #007bff;
      color: white;
      border: none;
    }

    .modal-footer button.secondary {
      background-color: #6c757d;
      color: white;
      border: none;
    }

    .modal-footer button.danger {
      background-color: #dc3545;
      color: white;
      border: none;
    }

    .modal-footer button.duplicate {
      background-color: #17a2b8;
      color: white;
      border: none;
    }

    .modal-footer button.duplicate:hover {
      background-color: #117a8b;
    }

    /* --- Cropper Modal Specific --- */
    #cropper-modal-content img {
      max-width: 100%;
      display: block;
    }

    #cropper-modal-controls {
      margin-top: 15px;
      text-align: center;
    }

    #cropper-modal-controls button,
    #cropper-modal-controls select {
      margin: 0 5px;
      padding: 8px 12px;
    }

    #cropper-zoom-controls {
      margin-top: 10px;
      text-align: center;
    }

    #cropper-zoom-controls button {
      font-size: 0.8em;
      padding: 5px 8px;
      margin: 2px;
    }

    /* --- Edit Modals Specific --- */
    #unit-edit-modal .form-group,
    #group-edit-modal .form-group,
    #text-edit-modal .form-group {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }

    #unit-edit-modal .form-group label,
    #group-edit-modal .form-group label,
    #text-edit-modal .form-group label {
      width: 100px;
      margin-right: 10px;
      text-align: right;
      font-size: 0.9em;
      flex-shrink: 0;
    }

    #unit-edit-modal .form-group input,
    #unit-edit-modal .form-group select,
    #group-edit-modal .form-group input,
    #text-edit-modal .form-group input,
    #text-edit-modal .form-group select,
    #text-edit-modal .form-group textarea {
      flex-grow: 1;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    #text-edit-modal .form-group input[type="color"] {
      padding: 2px;
      height: 30px;
      flex-basis: 50px;
      min-width: 50px;
    }

    #text-edit-modal .form-group input[type="number"] {
      width: 70px;
      flex-grow: 0;
    }


    #unit-edit-modal .slot-edit-section {
      border: 1px dashed #ccc;
      padding: 10px;
      margin-bottom: 10px;
      border-radius: 4px;
    }

    #unit-edit-modal .slot-edit-section h5 {
      margin-top: 0;
    }

    #unit-edit-modal .slot-edit-section img {
      max-width: 100px;
      max-height: 50px;
      display: block;
      margin-bottom: 5px;
    }

    #unit-edit-modal .slot-edit-section button {
      font-size: 0.8em;
      padding: 4px 8px;
      margin-top: 5px;
    }

    #unit-edit-modal .order-checkbox-group {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-bottom: 8px;
      padding-left: 0;
      font-size: 0.75em;
    }

    #unit-edit-modal .order-checkbox-group .order-label {
      font-weight: bold;
      margin-right: 5px;
      flex-basis: auto;
      white-space: nowrap;
      text-align: right;
    }

    #unit-edit-modal .order-checkbox-group label:not(.order-label) {
      font-weight: normal;
      margin-right: 5px;
    }

    #unit-edit-modal .order-checkbox-group input[type="checkbox"] {
      margin-right: 1px;
    }

    .form-group-checkbox {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }

    .form-group-checkbox label {
      width: 100px;
      margin-right: 10px;
      text-align: right;
      font-size: 0.9em;
      flex-shrink: 0;
    }

    .form-group-checkbox input[type="checkbox"] {
      margin-right: 5px;
    }


    /* --- Info Modal Specific --- */
    #info-modal .crop-list-item {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }

    .crop-color-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
      display: inline-block;
    }

    /* --- Responsive --- */
    @media (max-width: 768px) {
      .bottom-controls {
        height: auto;
        padding-top: 10px;
        padding-left: 10px;
        padding-right: 10px;
        padding-bottom: calc(10px + env(safe-area-inset-bottom));
        justify-content: space-around;
      }

      .bottom-controls button {
        font-size: 0.8em;
        min-width: 60px;
        padding: 6px 8px;
        margin-bottom: 5px;
      }

      .bottom-controls button:disabled {
        filter: grayscale(50%);
        cursor: not-allowed;
        opacity: 0.7;
      }

      .bottom-controls button.active-mode-button:disabled {
        background-color: #f5c6cb !important;
        color: #721c24;
        filter: none;
        opacity: 0.8;
      }

      .bottom-controls button#undo-button:disabled,
      .bottom-controls button#redo-button:disabled {
        background-color: #ffeeba;
        color: #856404;
      }


      #info-button-container {
        top: 5px;
        right: 10px;
      }

      #info-button-container button {
        padding: 6px 10px;
        font-size: 0.9em;
      }

      .modal {
        width: 90%;
        max-width: 90%;
      }
    }

    .accordion-section {
      border: 1px solid #eee;
      border-radius: 4px;
      margin-bottom: 15px;
      background-color: #fdfdfd;
    }

    .accordion-header {
      padding: 10px;
      cursor: pointer;
      font-weight: bold;
      background-color: #f7f7f7;
      border-bottom: 1px solid #eee;
      list-style: none;
      /* summaryのデフォルトマーカーを消す */
    }

    .accordion-header::-webkit-details-marker {
      display: none;
    }

    /* Chrome/Safariのマーカーを消す */
    .accordion-header::before {
      /* 簡単な開閉アイコン */
      content: '▶ ';
      font-size: 0.8em;
      margin-right: 5px;
      display: inline-block;
      transition: transform 0.2s ease-in-out;
    }

    details[open]>summary.accordion-header::before {
      transform: rotate(90deg);
    }

    .accordion-content {
      padding: 15px;
      border-top: 1px solid #eee;
      /* ヘッダーとの境界線 */
    }

    .accordion-content .form-group {
      margin-bottom: 12px;
      /* 設定項目間のスペース */
    }

    .accordion-content .form-group label {
      width: 100px;
      /* ラベル幅を少し広げる */
    }

    .accordion-content small {
      margin-left: 8px;
      font-size: 0.8em;
      color: #777;
    }

    /* 画像集合ユニット編集モーダルのリストスタイル */
    #collection-edit-image-list li {
      display: flex;
      align-items: center;
      border: 1px solid #eee;
      padding: 8px;
      margin-bottom: 8px;
      border-radius: 4px;
      background-color: #f9f9f9;
      cursor: grab;
      /* ドラッグ可能を示すカーソル */
    }

    #collection-edit-image-list li.dragging {
      /* ドラッグ中のスタイル */
      opacity: 0.5;
      background-color: #e0e0e0;
    }

    /* 削除マーク用スタイル (オプション) */
    #collection-edit-image-list li[data-deleted="true"] {
      opacity: 0.5;
      text-decoration: line-through;
      background-color: #ffe0e0;
    }


    #collection-edit-image-list img {
      width: 40px;
      height: 40px;
      object-fit: contain;
      border: 1px solid #ddd;
      margin-right: 10px;
      background-color: white;
    }

    #collection-edit-image-list .image-details {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      gap: 5px;
      /* 詳細項目間のギャップ */
    }

    #collection-edit-image-list .image-details p {
      margin: 0;
      font-size: 0.75em;
      color: #666;
      word-break: break-all;
      /* ファイル名が長い場合 */
    }

    #collection-edit-image-list .detail-form-group {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    #collection-edit-image-list .detail-form-group label {
      font-size: 0.8em;
      width: 40px;
      /* ラベル幅を調整 */
      text-align: right;
      flex-shrink: 0;
    }

    #collection-edit-image-list .detail-form-group input[type="text"],
    #collection-edit-image-list .detail-form-group select {
      font-size: 0.8em;
      padding: 3px 4px;
      border: 1px solid #ccc;
      border-radius: 3px;
      flex-grow: 1;
    }

    #collection-edit-image-list .delete-image-btn {
      background: none;
      border: none;
      color: #dc3545;
      font-size: 1.2em;
      cursor: pointer;
      padding: 5px;
      margin-left: 10px;
    }

    #collection-edit-image-list .delete-image-btn:hover {
      color: #a71d2a;
    }

    .checkbox-row-container {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .checkbox-item-container {
      display: flex;
      align-items: center;
      margin-right: 20px;
    }

    .checkbox-item-container:last-child {
      margin-right: 0;
    }

    .checkbox-item-container input[type="checkbox"] {
      margin-right: 4px;
    }

    .checkbox-item-container label {
      font-weight: normal;
      white-space: nowrap;
    }

    .drawing-undo-redo-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      margin-bottom: 5px;
    }

    .drawing-undo-redo-controls button {
      flex-grow: 1;
      font-size: 0.85em;
      padding: 6px 10px;
      background-color: #6c757d;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .drawing-undo-redo-controls button:hover:not(:disabled) {
      filter: brightness(1.15);
    }

    .drawing-undo-redo-controls button:disabled {
      background-color: #adb5bd;
      cursor: not-allowed;
      opacity: 0.7;
    }
  </style>
</head>

<body>
  <div id="status-bar">ステータスメッセージがここに表示されます</div>
  <div class="modal-overlay" id="modal-overlay"></div>

  <div class="container">
    <div class="top-area">
      <button id="left-panel-toggle-button" title="左パネルを開閉">＜</button>
      <div class="left-panel" id="left-panel">
        <div class="panel-section tool-info-section"> <!-- 新しいセクション -->
          <button id="show-tool-info-modal-button" class="action-button"
            style="background-color: #6c757d; margin-top:0;">ツール情報/使い方</button>
        </div>
        <div class="panel-section upload-main-section">
          <h2>ユニット追加</h2>
        </div>

        <div class="panel-section template-add-section">
          <h3>テンプレートから追加</h3>
          <div class="form-group">
            <label for="template-select">テンプレート:</label>
            <select id="template-select">
              <option value="">選択してください</option>
              <!-- JavaScriptでテンプレート名をここに追加 -->
            </select>
          </div>
          <div id="template-layout-preview-area" style="
                      width: 100%;
                      height: 200px;
                      border: 1px solid #ccc;
                      margin-top: 10px;
                      margin-bottom: 10px;
                      background-color: #f0f0f0;
                      position: relative;
                      overflow: hidden;
                      display: none;
                    ">
            <!-- ここにプレビューが描画される -->
          </div>

          <div class="file-input-wrapper">
            <label class="file-input-label" for="template-image-upload">画像を一括選択:</label>
            <div class="file-input-controls">
              <input type="file" id="template-image-upload" accept="image/*" multiple disabled>
              <!-- 初期状態はdisabled -->
            </div>
          </div>
          <small id="template-image-info">テンプレートを選択すると、必要な画像枚数が表示されます。</small>
          <div id="template-image-previews"
            style="display: flex; flex-wrap: wrap; gap: 5px; margin-top: 10px; max-height: 100px; overflow-y: auto; border: 1px dashed #eee; padding: 5px; background-color: #f0f0f0;">
            <!-- 選択された画像のプレビューがここに表示される -->
          </div>
          <button id="add-from-template-button" class="action-button" disabled
            style="margin-top: 10px;">テンプレートを家系図に追加</button>
        </div>

        <div class="image-slot-group">
          <h4>出生スロット</h4>
          <div class="file-input-wrapper">
            <label class="file-input-label" for="birth-image-upload">画像を選択:</label>
            <div class="file-input-controls">
              <input type="file" id="birth-image-upload" accept="image/*">
              <button class="clear-image-button hidden" id="clear-birth-image-button" title="画像をクリア">×</button>
            </div>
          </div>
          <img id="birth-image-preview" src="#" alt="出生画像プレビュー" class="preview-image" style="display:none;">
          <button class="post-preview-edit-button" id="edit-birth-image-button" disabled>この画像を編集</button>
          <div class="form-group">
            <label for="birth-name">名前:</label>
            <input type="text" id="birth-name" maxlength="10" placeholder="名前を入力(任意)">
          </div>
          <div class="form-group">
            <label for="birth-favorite-food">好物:</label>
            <select id="birth-favorite-food">
              <option value="未選択">選択してください(任意)</option>
              <option value="いちご">いちご</option>
              <option value="にがうり">にがうり</option>
              <option value="とうがらし">とうがらし</option>
              <option value="バナナ">バナナ</option>
              <option value="レモン">レモン</option>
              <option value="ぶどう">ぶどう</option>
              <option value="かき">かき</option>
            </select>
          </div>
        </div>

        <div class="image-slot-group">
          <h4>QRコード1(「先」の個体を推奨)</h4>
          <div class="file-input-wrapper">
            <label class="file-input-label" for="qr1-image-upload">画像を選択:</label>
            <div class="file-input-controls">
              <input type="file" id="qr1-image-upload" accept="image/*">
              <button class="clear-image-button hidden" id="clear-qr1-image-button" title="画像をクリア">×</button>
            </div>
          </div>
          <img id="qr1-image-preview" src="#" alt="QR1画像プレビュー" class="preview-image" style="display:none;">
          <button class="post-preview-edit-button" id="edit-qr1-image-button" disabled>この画像を編集</button>
          <div class="order-checkbox-group">
            <label class="order-label">入居順(任意):</label>
            <input type="checkbox" id="qr1-order-saki" name="qr1-order" value="先"> <label for="qr1-order-saki">先</label>
            <input type="checkbox" id="qr1-order-ato" name="qr1-order" value="後"> <label for="qr1-order-ato">後</label>
          </div>
          <div class="form-group">
            <label for="qr1-name">名前:</label>
            <input type="text" id="qr1-name" maxlength="10" placeholder="名前を入力(任意)">
          </div>
          <div class="form-group">
            <label for="qr1-favorite-food">好物:</label>
            <select id="qr1-favorite-food">
              <option value="未選択">選択してください(任意)</option>
              <option value="いちご">いちご</option>
              <option value="にがうり">にがうり</option>
              <option value="とうがらし">とうがらし</option>
              <option value="バナナ">バナナ</option>
              <option value="レモン">レモン</option>
              <option value="ぶどう">ぶどう</option>
              <option value="かき">かき</option>
            </select>
          </div>
        </div>

        <div class="image-slot-group">
          <h4>QRコード2(「後」の個体を推奨)</h4>
          <div class="file-input-wrapper">
            <label class="file-input-label" for="qr2-image-upload">画像を選択:</label>
            <div class="file-input-controls">
              <input type="file" id="qr2-image-upload" accept="image/*">
              <button class="clear-image-button hidden" id="clear-qr2-image-button" title="画像をクリア">×</button>
            </div>
          </div>
          <img id="qr2-image-preview" src="#" alt="QR2画像プレビュー" class="preview-image" style="display:none;">
          <button class="post-preview-edit-button" id="edit-qr2-image-button" disabled>この画像を編集</button>
          <div class="order-checkbox-group">
            <label class="order-label">入居順(任意):</label>
            <input type="checkbox" id="qr2-order-saki" name="qr2-order" value="先"> <label for="qr2-order-saki">先</label>
            <input type="checkbox" id="qr2-order-ato" name="qr2-order" value="後"> <label for="qr2-order-ato">後</label>
          </div>
          <div class="form-group">
            <label for="qr2-name">名前:</label>
            <input type="text" id="qr2-name" maxlength="10" placeholder="名前を入力(任意)">
          </div>
          <div class="form-group">
            <label for="qr2-favorite-food">好物:</label>
            <select id="qr2-favorite-food">
              <option value="未選択">選択してください(任意)</option>
              <option value="いちご">いちご</option>
              <option value="にがうり">にがうり</option>
              <option value="とうがらし">とうがらし</option>
              <option value="バナナ">バナナ</option>
              <option value="レモン">レモン</option>
              <option value="ぶどう">ぶどう</option>
              <option value="かき">かき</option>
            </select>
          </div>
        </div>

        <div class="form-group-checkbox" id="add-unit-border-visible-group">
          <label for="add-unit-border-visible">枠を表示:</label>
          <input type="checkbox" id="add-unit-border-visible" checked>
        </div>
        <button id="add-unit-button" class="action-button" disabled>ユニットを家系図に追加</button>

        <div class="panel-section image-collection-section">
          <h3>画像集合ユニット追加</h3>
          <div class="file-input-wrapper">
            <label class="file-input-label" for="image-collection-upload">画像を一括選択 (最大20枚):</label>
            <div class="file-input-controls">
              <input type="file" id="image-collection-upload" accept="image/*" multiple>
              <button class="clear-image-button hidden" id="clear-image-collection-button" title="選択画像をクリア">×</button>
            </div>
          </div>
          <div id="image-collection-previews"></div>
          <div id="image-collection-details" style="max-height: 200px; overflow-y: auto;"></div>
          <div class="form-group-checkbox" id="image-collection-border-group">
            <label for="image-collection-border-visible">枠を表示:</label>
            <input type="checkbox" id="image-collection-border-visible" checked>
          </div>
          <button id="add-image-collection-button" class="action-button" disabled>画像集合ユニットを追加</button>
        </div>


        <div class="panel-section text-add-section">
          <h3>テキスト追加</h3>
          <p>
            <small>※文章が長い・文字サイズを大きく設定した場合は改行することをおすすめします。また場合によっては家系図上での表示がおかしくなってしまう場合がありますが、追加後に枠のサイズを変更していただければ解決する可能性があります。</small>
          </p>
          <div class="form-group">
            <label for="add-text-content">内容:</label>
            <textarea id="add-text-content" rows="3" placeholder="表示したいテキスト"></textarea>
          </div>
          <div class="form-group">
            <label for="add-text-color">文字色:</label>
            <input type="color" id="add-text-color" value="#000000">
          </div>
          <div class="form-group">
            <label for="add-text-bgcolor">背景色:</label>
            <input type="color" id="add-text-bgcolor" value="#ffffff">
          </div>
          <div class="form-group">
            <label for="add-text-size">サイズ:</label>
            <input type="number" id="add-text-size" value="20" min="8">
          </div>
          <div class="form-group-checkbox" id="add-text-border-visible-group">
            <label for="add-text-border-visible">枠を表示:</label>
            <input type="checkbox" id="add-text-border-visible" checked>
          </div>
          <button id="add-text-item-button" class="action-button" disabled>テキストを家系図に追加</button>
        </div>
        <div class="panel-section drawing-tools-section" id="drawing-tools-panel" style="display: none;">
          <h3>手書きツール</h3>
          <div class="form-group">
            <label for="drawing-color-picker">色:</label> <!-- id変更: drawing-color -> drawing-color-picker -->
            <input type="color" id="drawing-color-picker" value="#000000">
          </div>
          <div class="form-group">
            <label for="drawing-line-width-slider">太さ:</label>
            <!-- id変更: drawing-line-width -> drawing-line-width-slider -->
            <input type="range" id="drawing-line-width-slider" min="1" max="20" value="3">
            <span id="drawing-line-width-value">3</span>px
          </div>
          <div class="form-group">
            <label for="drawing-shape-select">ツール:</label> <!-- id変更: drawing-shape -> drawing-shape-select -->
            <select id="drawing-shape-select">
              <option value="line" selected>線</option>
              <option value="rectangle">四角</option>
              <option value="circle">円</option>
              <option value="arrow">矢印</option>
              <option value="eraser">消しゴム</option>
            </select>
          </div>
          <div class="form-group" id="drawing-fill-group" style="display:none;">
            <label for="drawing-fill-checkbox">塗りつぶし:</label>
            <input type="checkbox" id="drawing-fill-checkbox">
          </div>
          <div class="drawing-undo-redo-controls">
            <button id="drawing-undo-button" title="描画を元に戻す" disabled>描画戻す</button>
            <button id="drawing-redo-button" title="描画をやり直す" disabled>描画進む</button>
          </div>
          <button id="clear-all-drawings-button" class="action-button"
            style="margin-top: 5px; background-color: #dc3545;">全描画消去</button>
        </div>
      </div>

      <div class="main-canvas-area" id="main-canvas-area">
        <canvas id="family-tree-canvas"></canvas>
      </div>
    </div>

    <div class="bottom-controls">
      <button id="undo-button" title="元に戻す">戻す</button>
      <button id="redo-button" title="やり直す">進む</button>
      <button id="connect-button" title="ユニット間を接続">接続</button>
      <button id="edit-unit-button" title="ユニット/グループ/テキストを編集">編集</button>
      <button id="group-button" title="選択した2つをまとめる">まとめる</button>
      <button id="unify-size-button" title="サイズを合わせる (未実装)">サイズ統一</button>
      <button id="unify-size-complete-selection-btn" title="選択したユニットにサイズ統一を適用"
        style="display: none; background-color: #28a745;">選択完了</button>
      <button id="align-button" title="ユニットを整列">整列</button>
      <button id="draw-mode-button" title="手書き描画モード">描画</button>
      <button id="save-canvas-button" title="家系図を画像で保存">保存</button>
      <button id="zoom-out-button" title="縮小">-</button>
      <span id="zoom-level-indicator">0</span> <button id="zoom-in-button" title="拡大">+</button>
      <button id="clear-storage-button" title="保存データを削除して新規作成"
        style="background-color: #ffc107; color: #333;">データクリア</button>
      <button id="export-data-button" title="家系図データをJSONファイルでエクスポート" style="background-color: #007bff;">エクスポート</button>
      <button id="import-data-button" title="JSONファイルから家系図データをインポート" style="background-color: #28a745;">インポート</button>
      <input type="file" id="import-file-input" accept=".json" style="display: none;">
    </div>
  </div>

  <div id="info-button-container">
    <button id="show-info-modal-button">家系図情報</button>
  </div>

  <div id="cropper-modal" class="modal">
    <div class="modal-header">
      <h2>画像の編集</h2>
      <button class="modal-close-button" id="cropper-modal-close-button-header">&times;</button>
    </div>
    <div class="modal-body">
      <div>
        <img id="image-to-crop" src="" alt="切り抜き対象" style="max-height: 50vh;">
      </div>
      <div id="cropper-zoom-controls">
        <label>ズーム:</label>
        <button data-zoom="0.01">1%</button>
        <button data-zoom="0.1">10%</button>
        <button data-zoom="0.25">25%</button>
        <button data-zoom="0.5">50%</button>
        <button data-zoom="1">100%</button>
        <button data-zoom-in>+</button>
        <button data-zoom-out>-</button>
      </div>
      <div id="cropper-modal-controls">
        <label for="aspect-ratio-select">アスペクト比:</label>
        <select id="aspect-ratio-select">
          <option value="NaN">自由</option>
          <option value="1">正方形 (1:1)</option>
        </select>
      </div>
    </div>
    <div class="modal-footer">
      <button id="cancel-crop-button" class="secondary">キャンセル</button>
      <button id="crop-image-button" class="primary">適用</button>
    </div>
  </div>

  <div id="unit-edit-modal" class="modal">
    <div class="modal-header">
      <h2 id="unit-edit-modal-title">ユニット編集</h2>
      <button class="modal-close-button" id="unit-edit-modal-close-button">&times;</button>
    </div>
    <div class="modal-body" id="unit-edit-modal-body">
    </div>
    <div class="modal-footer">
      <button id="unit-edit-delete-button" class="danger">ユニット削除</button>
      <button id="unit-edit-duplicate-button" class="duplicate">ユニット複製</button>
      <button id="unit-edit-cancel-button" class="secondary">キャンセル</button>
      <button id="unit-edit-apply-button" class="primary">適用</button>
    </div>
  </div>

  <div id="group-edit-modal" class="modal">
    <div class="modal-header">
      <h2 id="group-edit-modal-title">グループ編集</h2>
      <button class="modal-close-button" id="group-edit-modal-close-button">&times;</button>
    </div>
    <div class="modal-body" id="group-edit-modal-body">
      <div class="form-group">
        <label for="group-edit-name">グループ名:</label>
        <input type="text" id="group-edit-name" placeholder="グループ名 (任意)">
      </div>
      <div class="form-group-checkbox">
        <label for="group-edit-border-visible">枠を表示:</label>
        <input type="checkbox" id="group-edit-border-visible">
      </div>
      <p><small>グループ内のユニットの編集は、一度グループ化を解除するか、各ユニットを個別に編集モードで選択してください。</small></p>
    </div>
    <div class="modal-footer">
      <button id="group-edit-delete-button" class="danger">グループ削除</button>
      <button id="group-edit-ungroup-button" class="secondary">グループ化解除</button>
      <button id="group-edit-duplicate-button" class="duplicate">グループ複製</button>
      <button id="group-edit-cancel-button" class="secondary">キャンセル</button>
      <button id="group-edit-apply-button" class="primary">適用</button>
    </div>
  </div>

  <div id="text-edit-modal" class="modal">
    <div class="modal-header">
      <h2 id="text-edit-modal-title">テキスト編集</h2>
      <button class="modal-close-button" id="text-edit-modal-close-button">&times;</button>
    </div>
    <div class="modal-body" id="text-edit-modal-body">
    </div>
    <div class="modal-footer">
      <button id="text-edit-delete-button" class="danger">テキスト削除</button>
      <button id="text-edit-duplicate-button" class="duplicate">テキスト複製</button>
      <button id="text-edit-cancel-button" class="secondary">キャンセル</button>
      <button id="text-edit-apply-button" class="primary">適用</button>
    </div>
  </div>


  <div id="info-modal" class="modal" style="max-width: 650px;">
    <div class="modal-header">
      <h2>家系図情報</h2>
      <button class="modal-close-button" id="info-modal-close-button-header">&times;</button>
    </div>
    <div class="modal-body">
      <p>
        <small>※必要ゴールド及び作物は、スタミナ1で20までレベルを上げてふれあいで幸せを8にした後に好物を7個使い上限突破可能になるまでしあわせを上げることを想定しています。好物が未設定の場合はその分が反映されません。またこちらの設定ミスでおかしな数値になっている可能性があるのであまりアテにしないでください。</small>
      </p>
      <h3>必要作物</h3>
      <ul id="required-crops-list" style="list-style-type: none; padding-left: 0;">
      </ul>
      <h3>必要ゴールド</h3>
      <p id="total-gold-cost">0 G</p>
      <p><small id="gold-details">上限突破0回 0G、出生0回 0G、作物の種0個 0G</small></p>
    </div>
    <div class="modal-footer">
      <button id="info-modal-close-button-footer" class="secondary">閉じる</button>
    </div>

  </div>

  <div id="image-collection-edit-modal" class="modal" style="max-width: 600px;">
    <div class="modal-header">
      <h2 id="collection-edit-modal-title">画像集合ユニット編集</h2>
      <button class="modal-close-button" id="collection-edit-modal-close-button">×</button>
    </div>
    <div class="modal-body" id="collection-edit-modal-body">
      <div class="form-group">
        <label for="collection-edit-name">ユニット名:</label>
        <input type="text" id="collection-edit-name" placeholder="ユニット名 (任意)">
      </div>
      <div class="form-group-checkbox">
        <label for="collection-edit-border-visible">枠を表示:</label>
        <input type="checkbox" id="collection-edit-border-visible">
      </div>
      <hr>

      <details class="accordion-section" id="collection-layout-settings">
        <summary class="accordion-header">ユニット内の配置設定</summary>
        <div class="accordion-content">
          <div class="form-group">
            <label for="collection-edit-max-size">画像サイズ:</label>
            <input type="number" id="collection-edit-max-size" min="10" step="1">
            <small> (基本: 50)</small>
          </div>
          <div class="form-group">
            <label for="collection-edit-margin">基本マージン:</label>
            <input type="number" id="collection-edit-margin" min="0" step="1">
            <small> (基本: 5)</small>
          </div>
          <div class="form-group">
            <label for="collection-edit-padding">パディング:</label>
            <input type="number" id="collection-edit-padding" min="0" step="1">
            <small> (基本: 10)</small>
          </div>
          <div class="form-group">
            <label for="collection-edit-text-gap">テキスト間隔:</label>
            <input type="number" id="collection-edit-text-gap" min="0" step="1">
            <small> (基本: 8)</small>
          </div>
          <div class="form-group">
            <label for="collection-edit-per-row">1行の画像数:</label>
            <input type="number" id="collection-edit-per-row" min="1" step="1">
            <small> (基本: 3)</small>
          </div>
          <div class="form-group">
            <label for="collection-edit-font-size">文字サイズ:</label>
            <input type="number" id="collection-edit-font-size" min="6" step="1">
            <small> (基本: 10)</small>
          </div>
          <button id="reset-layout-settings-button" type="button"
            style="font-size: 0.8em; padding: 3px 6px; margin-left: 110px;">基本設定に戻す</button>
        </div>
      </details>
      <hr>


      <h4>内部の画像 (<span id="collection-edit-image-count">0</span>枚)</h4>
      <p><small>ドラッグ＆ドロップで並び替え、各項目を編集、削除ボタン(<span
            style="color:#dc3545; font-weight:bold;">×</span>)で削除リストに追加できます。</small>
      </p>
      <ul id="collection-edit-image-list" style="list-style: none; padding: 0; max-height: 40vh; overflow-y: auto;">
      </ul>
    </div>
    <div class="modal-footer">
      <button id="collection-edit-delete-button" class="danger">ユニット削除</button>
      <button id="collection-edit-cancel-button" class="secondary">キャンセル</button>
      <button id="collection-edit-apply-button" class="primary">適用</button>
    </div>
  </div>
  <div id="unify-size-options-modal" class="modal" style="max-width: 400px; display: none;">
    <div class="modal-header">
      <h2>サイズ統一の範囲を選択</h2>
    </div>
    <div class="modal-body">
      <p>基準ユニット: <strong id="unify-base-unit-name">未選択</strong> (<span id="unify-base-unit-size">0x0</span>)</p>
      <hr>
      <button id="unify-all-units-btn" class="action-button"
        style="margin-bottom: 10px; width: 100%;">家系図上の全ユニット</button>
      <button id="unify-visible-units-btn" class="action-button"
        style="margin-bottom: 10px; width: 100%;">画面内のユニットのみ</button>
      <button id="unify-select-targets-btn" class="action-button" style="width: 100%;">適用するユニットを選択する</button>
    </div>
    <div class="modal-footer">
      <button id="unify-size-options-modal-cancel-btn" class="secondary">キャンセル</button>
    </div>
  </div>
  <div id="align-options-modal" class="modal" style="max-width: 350px; display: none;">
    <div class="modal-header">
      <h2>整列方法を選択</h2>
    </div>
    <div class="modal-body">
      <p>基準ユニット: <strong id="align-options-base-unit-name">未選択</strong></p>
      <p>対象ユニット数: <span id="align-options-target-count">0</span>個</p>
      <hr>
      <button id="align-horizontal-btn" class="action-button"
        style="margin-bottom: 10px; width: 100%; background-color: #17a2b8;">水平方向に整列 (Y座標を揃える)</button>
      <button id="align-vertical-btn" class="action-button" style="width: 100%; background-color: #fd7e14;">垂直方向に整列
        (X座標を揃える)</button>
    </div>
    <div class="modal-footer">
      <button id="align-options-modal-cancel-btn" class="secondary">キャンセル</button>
    </div>
  </div>
  <div id="image-preview-modal" class="modal" style="max-width: 90vw; max-height: 90vh; display: none;">
    <div class="modal-header">
      <h2>保存プレビュー(写真アプリに保存する場合は、画像を長押しして「写真に追加」または「画像を保存」を選択してください。)</h2>
      <button class="modal-close-button" id="image-preview-modal-close-button">×</button>
    </div>
    <div class="modal-body" style="text-align: center; overflow: auto;">
      <img id="save-image-preview" src="#" alt="保存プレビュー画像"
        style="max-width: 100%; max-height: 70vh; object-fit: contain; border: 1px solid #ccc;">
    </div>
    <div class="modal-footer"
      style="border-top: none; padding-top: 10px; display: flex; justify-content: space-between; align-items: center;">
      <div class="resolution-selector-group-preview" style="display: flex; align-items: center;">
        <label for="preview-resolution-options"
          style="/* color: white; */ margin-right: 8px; font-size: 0.9em;">解像度:</label>
        <select id="preview-resolution-options"
          style="padding: 6px 8px; font-size: 0.85em; border-radius: 4px; border: 1px solid #ccc;">
          <option value="1.0">標準 (等倍)</option>
          <option value="2.0" selected>高画質 (2倍)</option>
          <option value="3.0">さらに高画質 (3倍)</option>
          <option value="4.0">超高画質 (4倍)</option>
        </select>
        <button id="regenerate-preview-button" class="secondary"
          style="margin-left: 10px; background-color: #ffc107; color: #333; padding: 6px 10px; font-size: 0.85em;">プレビュー再生成</button>
      </div>
      <button id="force-download-button" class="secondary" style="background-color: #5bc0de;">ファイルとしてダウンロード</button>
    </div>
  </div>
  <div id="tool-info-modal" class="modal" style="max-width: 700px;">
    <div class="modal-header">
      <h2>ツール情報 / 使い方</h2>
      <button class="modal-close-button" id="tool-info-modal-close-button-header">×</button>
    </div>
    <div class="modal-body" id="tool-info-modal-body">
      <!-- ここに説明文がJavaScriptによって挿入されます -->
      <p>読み込み中...</p>
    </div>
    <div class="modal-footer">
      <button id="tool-info-modal-close-button-footer" class="secondary">閉じる</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {


      // ========================================
      // 1. 定数宣言 (const)
      // ========================================
      const container = document.querySelector('.container');
      const topArea = document.querySelector('.top-area');
      const bottomControls = document.querySelector('.bottom-controls');
      const BASE_SCALE_FACTOR = 1.2;
      const DEFAULT_FONT = "'Noto Sans JP', sans-serif";
      const SLOT_WIDTH_BASE = 110;
      const SLOT_IMAGE_HEIGHT_BASE = 60 * BASE_SCALE_FACTOR;
      const SLOT_QR_IMAGE_SIZE_BASE = SLOT_IMAGE_HEIGHT_BASE;
      const SLOT_TEXT_LINE_HEIGHT_BASE = 16 * BASE_SCALE_FACTOR;
      const SLOT_PADDING_BASE = 8 * BASE_SCALE_FACTOR;
      const UNIT_INTERNAL_PADDING_BASE = 5 * BASE_SCALE_FACTOR;
      const IMAGE_TEXT_PADDING = SLOT_PADDING_BASE;
      const TEXT_LINE_HEIGHT_MULTIPLIER = 1.2;
      const RESIZE_HANDLE_SIZE = 10;
      const MIN_SLOT_WIDTH_FOR_DRAWING = 30;
      const BORDER_RESIZE_THRESHOLD = 8;
      const UNIT_WIDTH_ONE_SLOT = SLOT_WIDTH_BASE + (SLOT_PADDING_BASE * 2);
      const UNIT_WIDTH_TWO_SLOTS = (SLOT_WIDTH_BASE * 2) + UNIT_INTERNAL_PADDING_BASE + (SLOT_PADDING_BASE * 2);
      const UNIT_WIDTH_THREE_SLOTS = (SLOT_WIDTH_BASE * 3) + (UNIT_INTERNAL_PADDING_BASE * 2) + (SLOT_PADDING_BASE * 2);
      const GROUP_PADDING = 20;
      const TEXT_ITEM_PADDING = 5;
      const MIN_TEXT_ITEM_WIDTH = 30 + (TEXT_ITEM_PADDING * 2);
      const MIN_TEXT_ITEM_HEIGHT = 20 + (TEXT_ITEM_PADDING * 2);
      const COLLECTION_IMAGE_MAX_SIZE = 50;
      const COLLECTION_IMAGE_MARGIN = 5;
      const COLLECTION_PADDING = 10;
      const COLLECTION_IMAGES_PER_ROW = 3;
      const textFontSizeLogical = 10;
      const minTextGapLogical = 8;
      const cropColors = {
        'いちご': '#e73562', 'にがうり': '#47885e', 'とうがらし': '#ff0000',
        'バナナ': '#ffe135', 'レモン': '#fffcbf', 'ぶどう': '#522f60', 'かき': '#ed6d3d'
      };
      const SNAP_THRESHOLD = 15;
      const SNAP_RATIO = 5;
      const FAMILY_TREE_TEMPLATES = [
        {
          id: 'template-3step',
          name: '3手(太陽等)',
          maxImages: 15,
          layout: {
            units: [
              // 第四世代 (最下層の子孫) - G3_P1とG3_P2の中間X、G3より下
              { tempId: 'g4_child1', xOffset: 0, yOffset: 2, slotMapping: { birth: 14 } },

              // 第三世代 - G2ペアの中間X、G2より下、Y座標を揃える
              { tempId: 'g3_parent1', xOffset: -2, yOffset: 1, slotMapping: { birth: 12 } }, // G2_GP1とG2_GP2の中間
              { tempId: 'g3_parent2', xOffset: 2, yOffset: 1, slotMapping: { birth: 13 } }, // G2_GP3とG2_GP4の中間

              // 第二世代 - G1ペアの中間X、G1より下、Y座標を揃える
              { tempId: 'g2_grandparent1', xOffset: -3, yOffset: 0, slotMapping: { birth: 8 } },  // G1_A1とG1_A2の中間
              { tempId: 'g2_grandparent2', xOffset: -1, yOffset: 0, slotMapping: { birth: 9 } },  // G1_A3とG1_A4の中間
              { tempId: 'g2_grandparent3', xOffset: 1, yOffset: 0, slotMapping: { birth: 10 } }, // G1_A5とG1_A6の中間
              { tempId: 'g2_grandparent4', xOffset: 3, yOffset: 0, slotMapping: { birth: 11 } }, // G1_A7とG1_A8の中間

              // 第一世代 (最上位の先祖) - Y座標を揃える、ペアでXを調整
              { tempId: 'g1_ancestor1', xOffset: -3.5, yOffset: -1, slotMapping: { qr1: 0 } },
              { tempId: 'g1_ancestor2', xOffset: -2.5, yOffset: -1, slotMapping: { qr1: 1 } },
              { tempId: 'g1_ancestor3', xOffset: -1.5, yOffset: -1, slotMapping: { qr1: 2 } },
              { tempId: 'g1_ancestor4', xOffset: -0.5, yOffset: -1, slotMapping: { qr1: 3 } },
              { tempId: 'g1_ancestor5', xOffset: 0.5, yOffset: -1, slotMapping: { qr1: 4 } },
              { tempId: 'g1_ancestor6', xOffset: 1.5, yOffset: -1, slotMapping: { qr1: 5 } },
              { tempId: 'g1_ancestor7', xOffset: 2.5, yOffset: -1, slotMapping: { qr1: 6 } },
              { tempId: 'g1_ancestor8', xOffset: 3.5, yOffset: -1, slotMapping: { qr1: 7 } },
            ],
            connections: [
              // G3_P1 と G3_P2 から G4_C1 へ (T字の上辺と縦棒)
              { from: 'g3_parent1', to: 'g4_child1' }, { from: 'g3_parent2', to: 'g4_child1' },
              // G2_GP1/2 から G3_P1 へ
              { from: 'g2_grandparent1', to: 'g3_parent1' }, { from: 'g2_grandparent2', to: 'g3_parent1' },
              // G2_GP3/4 から G3_P2 へ
              { from: 'g2_grandparent3', to: 'g3_parent2' }, { from: 'g2_grandparent4', to: 'g3_parent2' },
              // G1_A1/2 から G2_GP1 へ
              { from: 'g1_ancestor1', to: 'g2_grandparent1' }, { from: 'g1_ancestor2', to: 'g2_grandparent1' },
              // G1_A3/4 から G2_GP2 へ
              { from: 'g1_ancestor3', to: 'g2_grandparent2' }, { from: 'g1_ancestor4', to: 'g2_grandparent2' },
              // G1_A5/6 から G2_GP3 へ
              { from: 'g1_ancestor5', to: 'g2_grandparent3' }, { from: 'g1_ancestor6', to: 'g2_grandparent3' },
              // G1_A7/8 から G2_GP4 へ
              { from: 'g1_ancestor7', to: 'g2_grandparent4' }, { from: 'g1_ancestor8', to: 'g2_grandparent4' },
            ],
            unitType: 'unit',
            defaultWidth: UNIT_WIDTH_ONE_SLOT,
            defaultHeightMultiplier: 1.0, // 高さを標準に
            gridSize: UNIT_WIDTH_ONE_SLOT * 1.5 // X方向の配置間隔の基準 (Y方向は yOffset で調整)
            // Y方向の世代間隔は yOffset の差で表現
          }
        },
        {
          id: 'template-2step-mozart',
          name: '2手(モーツァルト等)',
          maxImages: 7,
          layout: {
            units: [
              // 第三世代
              { tempId: 'g3_child1', xOffset: 0, yOffset: 1, slotMapping: { birth: 6 } },
              // 第二世代
              { tempId: 'g2_parent1', xOffset: -1.5, yOffset: 0, slotMapping: { birth: 4 } },
              { tempId: 'g2_parent2', xOffset: 1.5, yOffset: 0, slotMapping: { birth: 5 } },
              // 第一世代
              { tempId: 'g1_ancestor1', xOffset: -2.5, yOffset: -1, slotMapping: { qr1: 0 } },
              { tempId: 'g1_ancestor2', xOffset: -0.5, yOffset: -1, slotMapping: { qr1: 1 } },
              { tempId: 'g1_ancestor3', xOffset: 0.5, yOffset: -1, slotMapping: { qr1: 2 } },
              { tempId: 'g1_ancestor4', xOffset: 2.5, yOffset: -1, slotMapping: { qr1: 3 } },
            ],
            connections: [
              { from: 'g2_parent1', to: 'g3_child1' }, { from: 'g2_parent2', to: 'g3_child1' },
              { from: 'g1_ancestor1', to: 'g2_parent1' }, { from: 'g1_ancestor2', to: 'g2_parent1' },
              { from: 'g1_ancestor3', to: 'g2_parent2' }, { from: 'g1_ancestor4', to: 'g2_parent2' },
            ],
            unitType: 'unit',
            defaultWidth: UNIT_WIDTH_ONE_SLOT,
            defaultHeightMultiplier: 1.0,
            gridSize: UNIT_WIDTH_ONE_SLOT * 1.5
          }
        },
        {
          id: 'template-1step-item',
          name: '1手(おにぎり、ヘッドホン等)',
          maxImages: 3,
          layout: {
            units: [
              // 第二世代
              { tempId: 'g2_child1', xOffset: 0, yOffset: 0.5, slotMapping: { birth: 2 } },
              // 第一世代
              { tempId: 'g1_parent1', xOffset: -1, yOffset: -0.5, slotMapping: { qr1: 0 } },
              { tempId: 'g1_parent2', xOffset: 1, yOffset: -0.5, slotMapping: { qr1: 1 } },
            ],
            connections: [
              { from: 'g1_parent1', to: 'g2_child1' }, { from: 'g1_parent2', to: 'g2_child1' },
            ],
            unitType: 'unit',
            defaultWidth: UNIT_WIDTH_ONE_SLOT,
            defaultHeightMultiplier: 1.0,
            gridSize: UNIT_WIDTH_ONE_SLOT * 1.5
          }
        }
      ];

      // ========================================
      // 2. グローバル変数宣言 (let)
      // ========================================
      let units = [];
      let groups = [];
      let textItems = [];
      let connections = [];
      let nextItemId = 0;
      let selectedItem = null;
      let draggingItem = null;
      let resizingItem = null;
      let resizeHandle = null;
      let dragOffsetX, dragOffsetY;
      let currentMode = null;
      let currentModeButtonElement = null;
      let connectFromItem = null;
      let itemsToGroup = [];
      let scale = 1.0;
      let zoomLevel = 0;
      let originX = 0;
      let originY = 0;
      let isPanning = false;
      let lastPanX, lastPanY;
      let history = [];
      let historyIndex = -1;
      let cropper = null;
      let currentCropFinalizeCallback = null;
      let currentImageSlotKeyForEditing = null;
      let currentEditingUnitContext = null;
      let editingUnit = null;
      let editingGroup = null;
      let editingTextItem = null;
      let uploadedCollectionImages = [];
      let editingCollectionUnit = null;
      let editingCollectionImageIndex = null;
      let draggedItem = null;
      let isDrawing = false;
      let lastDrawX, lastDrawY;
      let currentDrawingPath = [];
      let drawnPaths = [];
      let drawingColor = '#000000';
      let drawingLineWidth = 3;
      let drawingShape = 'line';
      let drawnPathsHistory = [];
      let drawnPathsHistoryIndex = -1;
      let unifySizeModeSubState = null;
      let unifySizeBaseUnit = null;
      let unifySizeTargetUnits = [];
      let editingLine = null;
      let alignBaseUnit = null;
      let alignTargetUnits = [];
      let selectedTemplate = null;
      let templateUploadedImages = [];
      let isPinching = false;
      let lastPinchDistance = 0;
      let pinchStartCanvasCenterX = 0;
      let pinchStartCanvasCenterY = 0;
      let pinchStartScreenCenterX = 0;
      let pinchStartScreenCenterY = 0;
      let currentPreviewScaleFactor = 2.0;

      // ========================================
      // 3. HTML要素取得 (const ... = document.getElementById(...))
      // ========================================
      const leftPanel = document.getElementById('left-panel');
      const leftPanelToggleButton = document.getElementById('left-panel-toggle-button');
      const mainCanvasArea = document.getElementById('main-canvas-area');
      const modalOverlay = document.getElementById('modal-overlay');
      const addUnitBorderVisibleCheckbox = document.getElementById('add-unit-border-visible');
      const imageSlots = {
        birth: {
          uploadInput: document.getElementById('birth-image-upload'),
          previewImg: document.getElementById('birth-image-preview'),
          editBtn: document.getElementById('edit-birth-image-button'),
          clearBtn: document.getElementById('clear-birth-image-button'),
          nameInput: document.getElementById('birth-name'),
          foodSelect: document.getElementById('birth-favorite-food'),
          orderSakiCheckbox: null, orderAtoCheckbox: null, data: null
        },
        qr1: {
          uploadInput: document.getElementById('qr1-image-upload'),
          previewImg: document.getElementById('qr1-image-preview'),
          editBtn: document.getElementById('edit-qr1-image-button'),
          clearBtn: document.getElementById('clear-qr1-image-button'),
          nameInput: document.getElementById('qr1-name'),
          foodSelect: document.getElementById('qr1-favorite-food'),
          orderSakiCheckbox: document.getElementById('qr1-order-saki'),
          orderAtoCheckbox: document.getElementById('qr1-order-ato'), data: null
        },
        qr2: {
          uploadInput: document.getElementById('qr2-image-upload'),
          previewImg: document.getElementById('qr2-image-preview'),
          editBtn: document.getElementById('edit-qr2-image-button'),
          clearBtn: document.getElementById('clear-qr2-image-button'),
          nameInput: document.getElementById('qr2-name'),
          foodSelect: document.getElementById('qr2-favorite-food'),
          orderSakiCheckbox: document.getElementById('qr2-order-saki'),
          orderAtoCheckbox: document.getElementById('qr2-order-ato'), data: null
        }
      };
      const addUnitButton = document.getElementById('add-unit-button');
      const canvas = document.getElementById('family-tree-canvas');
      const ctx = canvas.getContext('2d');
      const statusBar = document.getElementById('status-bar');
      const infoButtonContainer = document.getElementById('info-button-container');
      const addTextContentInput = document.getElementById('add-text-content');
      const addTextColorInput = document.getElementById('add-text-color');
      const addTextBgColorInput = document.getElementById('add-text-bgcolor');
      const addTextSizeInput = document.getElementById('add-text-size');
      const addTextBorderVisibleCheckbox = document.getElementById('add-text-border-visible');
      const addTextItemButton = document.getElementById('add-text-item-button');
      const imageCollectionUploadInput = document.getElementById('image-collection-upload');
      const imageCollectionPreviewsDiv = document.getElementById('image-collection-previews');
      const imageCollectionDetailsDiv = document.getElementById('image-collection-details');
      const imageCollectionBorderCheckbox = document.getElementById('image-collection-border-visible');
      const addImageCollectionButton = document.getElementById('add-image-collection-button');
      const clearImageCollectionButton = document.getElementById('clear-image-collection-button');
      const undoButton = document.getElementById('undo-button');
      const redoButton = document.getElementById('redo-button');
      const connectButton = document.getElementById('connect-button');
      const editUnitButton = document.getElementById('edit-unit-button');
      const groupButton = document.getElementById('group-button');
      const unifySizeButton = document.getElementById('unify-size-button');
      const saveCanvasButton = document.getElementById('save-canvas-button');
      const zoomInButton = document.getElementById('zoom-in-button');
      const zoomOutButton = document.getElementById('zoom-out-button');
      const zoomLevelIndicator = document.getElementById('zoom-level-indicator');
      const cropperModal = document.getElementById('cropper-modal');
      const cropperModalCloseButtonHeader = document.getElementById('cropper-modal-close-button-header');
      const imageToCrop = document.getElementById('image-to-crop');
      const aspectRatioSelect = document.getElementById('aspect-ratio-select');
      const cropImageButton = document.getElementById('crop-image-button');
      const cancelCropButton = document.getElementById('cancel-crop-button');
      const cropperZoomControls = document.getElementById('cropper-zoom-controls');
      const unitEditModal = document.getElementById('unit-edit-modal');
      const unitEditModalTitle = document.getElementById('unit-edit-modal-title');
      const unitEditModalBody = document.getElementById('unit-edit-modal-body');
      const unitEditModalCloseButton = document.getElementById('unit-edit-modal-close-button');
      const unitEditApplyButton = document.getElementById('unit-edit-apply-button');
      const unitEditCancelButton = document.getElementById('unit-edit-cancel-button');
      const unitEditDuplicateButton = document.getElementById('unit-edit-duplicate-button');
      const unitEditDeleteButton = document.getElementById('unit-edit-delete-button');
      const groupEditModal = document.getElementById('group-edit-modal');
      const groupEditModalTitle = document.getElementById('group-edit-modal-title');
      const groupEditModalCloseButton = document.getElementById('group-edit-modal-close-button');
      const groupEditNameInput = document.getElementById('group-edit-name');
      const groupEditBorderVisibleCheckbox = document.getElementById('group-edit-border-visible');
      const groupEditApplyButton = document.getElementById('group-edit-apply-button');
      const groupEditCancelButton = document.getElementById('group-edit-cancel-button');
      const groupEditUngroupButton = document.getElementById('group-edit-ungroup-button');
      const groupEditDuplicateButton = document.getElementById('group-edit-duplicate-button');
      const groupEditDeleteButton = document.getElementById('group-edit-delete-button');
      const textEditModal = document.getElementById('text-edit-modal');
      const textEditModalTitle = document.getElementById('text-edit-modal-title');
      const textEditModalBody = document.getElementById('text-edit-modal-body');
      const textEditModalCloseButton = document.getElementById('text-edit-modal-close-button');
      const textEditApplyButton = document.getElementById('text-edit-apply-button');
      const textEditCancelButton = document.getElementById('text-edit-cancel-button');
      const textEditDeleteButton = document.getElementById('text-edit-delete-button');
      const textEditDuplicateButton = document.getElementById('text-edit-duplicate-button');
      const infoModal = document.getElementById('info-modal');
      const showInfoModalButton = document.getElementById('show-info-modal-button');
      const infoModalCloseButtonHeader = document.getElementById('info-modal-close-button-header');
      const infoModalCloseButtonFooter = document.getElementById('info-modal-close-button-footer');
      const requiredCropsList = document.getElementById('required-crops-list');
      const collectionEditModal = document.getElementById('image-collection-edit-modal');
      const collectionEditModalTitle = document.getElementById('collection-edit-modal-title');
      const collectionEditNameInput = document.getElementById('collection-edit-name');
      const collectionEditBorderCheckbox = document.getElementById('collection-edit-border-visible');
      const collectionEditImageList = document.getElementById('collection-edit-image-list');
      const collectionEditImageCount = document.getElementById('collection-edit-image-count');
      const collectionEditApplyButton = document.getElementById('collection-edit-apply-button');
      const collectionEditCancelButton = document.getElementById('collection-edit-cancel-button');
      const collectionEditDeleteButton = document.getElementById('collection-edit-delete-button');
      const collectionEditModalCloseButton = document.getElementById('collection-edit-modal-close-button');
      const resetLayoutButton = document.getElementById('reset-layout-settings-button');
      const clearStorageButton = document.getElementById('clear-storage-button');
      const drawModeButton = document.getElementById('draw-mode-button');
      const drawingToolsPanel = document.getElementById('drawing-tools-panel');
      const drawingColorPicker = document.getElementById('drawing-color-picker');
      const drawingLineWidthSlider = document.getElementById('drawing-line-width-slider');
      const drawingLineWidthValue = document.getElementById('drawing-line-width-value');
      const drawingShapeSelect = document.getElementById('drawing-shape-select');
      const drawingFillGroup = document.getElementById('drawing-fill-group');
      const drawingFillCheckbox = document.getElementById('drawing-fill-checkbox');
      const clearAllDrawingsButton = document.getElementById('clear-all-drawings-button');
      const drawingUndoButton = document.getElementById('drawing-undo-button');
      const drawingRedoButton = document.getElementById('drawing-redo-button');
      const alignButton = document.getElementById('align-button');
      const alignOptionsModal = document.getElementById('align-options-modal');
      const alignOptionsBaseUnitName = document.getElementById('align-options-base-unit-name');
      const alignOptionsTargetCount = document.getElementById('align-options-target-count');
      const alignHorizontalBtn = document.getElementById('align-horizontal-btn');
      const alignVerticalBtn = document.getElementById('align-vertical-btn');
      const alignOptionsModalCancelBtn = document.getElementById('align-options-modal-cancel-btn');
      const templateSelect = document.getElementById('template-select');
      const templateImageUpload = document.getElementById('template-image-upload');
      const templateImageInfo = document.getElementById('template-image-info');
      const templateImagePreviews = document.getElementById('template-image-previews');
      const addFromTemplateButton = document.getElementById('add-from-template-button');
      const imagePreviewModal = document.getElementById('image-preview-modal');
      const saveImagePreview = document.getElementById('save-image-preview');
      const imagePreviewModalCloseButton = document.getElementById('image-preview-modal-close-button');
      const forceDownloadButton = document.getElementById('force-download-button');
      const previewResolutionOptions = document.getElementById('preview-resolution-options');
      const regeneratePreviewButton = document.getElementById('regenerate-preview-button');
      const templateLayoutPreviewArea = document.getElementById('template-layout-preview-area');
      const showToolInfoModalButton = document.getElementById('show-tool-info-modal-button');
      const toolInfoModal = document.getElementById('tool-info-modal');
      const toolInfoModalBody = document.getElementById('tool-info-modal-body');
      const toolInfoModalCloseButtonHeader = document.getElementById('tool-info-modal-close-button-header');
      const toolInfoModalCloseButtonFooter = document.getElementById('tool-info-modal-close-button-footer');

      const modeButtons = {
        'connect': connectButton,
        'edit-item': editUnitButton,
        'grouping': groupButton,
        'unify-size': unifySizeButton,
        'align': alignButton
      };
      const modeMessages = {
        'connect': '接続モード: 接続元のユニットまたは線を選択し、次に対象のユニットまたは線を選択してください。',
        'edit-item': '編集モード: 編集したいユニット、グループ、またはテキストを選択してください。',
        'grouping': 'グループ化モード: ユニットを2つ以上選択し「決定」でグループ化。',
        'unify-size-select-base': 'サイズ統一: 基準となるユニットを選択してください。',
        'unify-size-select-targets': 'サイズ統一: 対象ユニットを選択 (クリックで選択/解除)。完了後「選択完了」ボタン。',
        'draw-path': '手書き描画モード: 家系図に直接描画します。',
        'align-select-base': '整列モード: 基準となるユニットを1つ選択してください。',
        'align-select-targets': '整列モード: 対象ユニットを選択 (クリックで選択/解除)。その後、再度「整列」ボタンを押して整列方法を選択。'
      };

      console.log("canvas 要素 (初期化時):", canvas);
      console.log("leftPanelToggleButton 要素 (初期化時):", leftPanelToggleButton);


      // ========================================
      // 4. 関数定義 (function ...() { ... })
      // ========================================

      function resizeCanvas() {
        canvas.width = 3000;
        canvas.height = 2000;
        drawCanvas();
      }

      function saveState() {
        const state = {
          units: JSON.parse(JSON.stringify(units.map(u => {
            if (u.type === 'image-collection') {
              return {
                ...u,
                layoutSettings: u.layoutSettings ? { ...u.layoutSettings } : null,
                images: u.images.map(imgInfo => ({
                  imgDataUrl: imgInfo.imgDataUrl,
                  originalDataUrl: imgInfo.originalDataUrl,
                  fileName: imgInfo.fileName,
                  name: imgInfo.name,
                  food: imgInfo.food
                }))
              };
            }
            const serializableSlots = {};
            for (const key in u.slots) {
              const slot = u.slots[key];
              serializableSlots[key] = slot ? {
                imgDataUrl: slot.imgDataUrl || null,
                originalDataUrl: slot.originalDataUrl || null,
                fileName: slot.fileName || null,
                name: slot.name || '',
                food: slot.food || '未選択',
                order: slot.order || null
              } : null;
            }
            return { ...u, width: u.width, height: u.height, slots: serializableSlots, borderVisible: u.borderVisible, activeSlotKeys: u.activeSlotKeys };

          }))),
          groups: JSON.parse(JSON.stringify(groups.map(g => ({ ...g, itemIds: [...g.itemIds], borderVisible: g.borderVisible })))),
          textItems: JSON.parse(JSON.stringify(textItems.map(t => ({ ...t, borderVisible: t.borderVisible, font: t.font || DEFAULT_FONT, rotation: t.rotation || 0 })))),
          connections: JSON.parse(JSON.stringify(connections.map(conn => ({
            id: conn.id,
            fromId: conn.fromId,
            toId: conn.toId,
            isUnitToLine: conn.isUnitToLine,
            isLineToUnit: conn.isLineToUnit,
            color: conn.color || '#555555',
            lineWidth: conn.lineWidth || 10,
            dashArray: conn.dashArray || [],
          })))),
          drawnPaths: JSON.parse(JSON.stringify(drawnPaths)),
          nextItemId: nextItemId,
          scale: scale,
          originX: originX,
          originY: originY,
          zoomLevel: zoomLevel

        };
        history = history.slice(0, historyIndex + 1);
        history.push(state);
        historyIndex++;
        updateUndoRedoButtons();

        try {
          localStorage.setItem('kakeizuToolState', JSON.stringify(state));
          console.log("状態をローカルストレージに保存しました。");
        } catch (e) {
          console.error("ローカルストレージへの保存に失敗しました:", e);
          // クォータ超過などの可能性をユーザーに通知することも検討
        }
      }

      function calculateUnitHeight(unitSlots) {
        let neededHeight = 0;
        let hasImage = false;
        let maxTextLines = 0;
        Object.entries(unitSlots).forEach(([slotKey, slotData]) => {
          let currentSlotLines = 0;
          if (slotData) {
            if (slotData.img || slotData.imgDataUrl) hasImage = true;
            if (slotData.name) currentSlotLines++;
            if (slotData.food && slotData.food !== '未選択') currentSlotLines++;
            if ((slotKey === 'qr1' || slotKey === 'qr2') && slotData.order) currentSlotLines++;
          }
          maxTextLines = Math.max(maxTextLines, currentSlotLines);
        });
        neededHeight += SLOT_PADDING_BASE;
        if (hasImage) {
          neededHeight += Math.max(SLOT_IMAGE_HEIGHT_BASE, SLOT_QR_IMAGE_SIZE_BASE);
          if (maxTextLines > 0) neededHeight += IMAGE_TEXT_PADDING;
        } else if (maxTextLines > 0) {
          neededHeight += SLOT_PADDING_BASE / 2;
        }
        neededHeight += maxTextLines * SLOT_TEXT_LINE_HEIGHT_BASE * TEXT_LINE_HEIGHT_MULTIPLIER;
        neededHeight += SLOT_PADDING_BASE;
        let minHeight;
        if (hasImage) {
          minHeight = SLOT_PADDING_BASE * 2 + Math.max(SLOT_IMAGE_HEIGHT_BASE, SLOT_QR_IMAGE_SIZE_BASE) + (maxTextLines > 0 ? IMAGE_TEXT_PADDING : 0) + (maxTextLines * SLOT_TEXT_LINE_HEIGHT_BASE * TEXT_LINE_HEIGHT_MULTIPLIER);
        } else {
          minHeight = SLOT_PADDING_BASE * 2 + (maxTextLines > 0 ? SLOT_PADDING_BASE / 2 : 0) + (maxTextLines * TEXT_LINE_HEIGHT_MULTIPLIER * SLOT_TEXT_LINE_HEIGHT_BASE);
        }
        minHeight = Math.max(minHeight, SLOT_PADDING_BASE * 2 + (maxTextLines > 0 ? SLOT_TEXT_LINE_HEIGHT_BASE * TEXT_LINE_HEIGHT_MULTIPLIER : SLOT_IMAGE_HEIGHT_BASE * 0.5));
        return Math.max(minHeight, neededHeight);
      }

      async function restoreState(state) {
        const restoredUnits = [];
        const loadImage = async (url) => {
          if (!url) return null;
          return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = () => { console.error(`Error loading image: ${url}`); resolve(null); };
            img.src = url;
          });
        };
        if (state.units) {
          for (const savedItem of state.units) {
            if (savedItem.type === 'image-collection') {
              const restoredImages = [];
              if (savedItem.images && Array.isArray(savedItem.images)) {
                for (const imgInfo of savedItem.images) {
                  restoredImages.push({ ...imgInfo, img: await loadImage(imgInfo.imgDataUrl) });
                }
              }
              restoredUnits.push({ ...savedItem, images: restoredImages, layoutSettings: savedItem.layoutSettings || null });
            } else {
              const newUnitSlots = {};
              if (savedItem.slots) {
                for (const key in savedItem.slots) {
                  const savedSlot = savedItem.slots[key];
                  if (savedSlot) {
                    newUnitSlots[key] = {
                      img: await loadImage(savedSlot.imgDataUrl),
                      imgDataUrl: savedSlot.imgDataUrl,
                      originalDataUrl: savedSlot.originalDataUrl,
                      fileName: savedSlot.fileName,
                      name: savedSlot.name,
                      food: savedSlot.food,
                      order: savedSlot.order || null
                    };
                  } else { newUnitSlots[key] = null; }
                }
              }
              const unitWidth = savedItem.width;
              const unitHeight = savedItem.height;
              const activeSlotKeys = savedItem.activeSlotKeys || Object.keys(newUnitSlots).filter(k => newUnitSlots[k]?.img || newUnitSlots[k]?.imgDataUrl);
              restoredUnits.push({
                ...savedItem, width: unitWidth, height: unitHeight, slots: newUnitSlots,
                borderVisible: savedItem.borderVisible !== undefined ? savedItem.borderVisible : true,
                activeSlotKeys: activeSlotKeys
              });
            }
          }
        }
        units = restoredUnits;
        groups = JSON.parse(JSON.stringify(state.groups || [])).map(g => ({ ...g, borderVisible: g.borderVisible !== undefined ? g.borderVisible : true }));
        textItems = JSON.parse(JSON.stringify(state.textItems || [])).map(t => ({ ...t, borderVisible: t.borderVisible !== undefined ? t.borderVisible : true, font: t.font || DEFAULT_FONT, rotation: t.rotation || 0 }));
        connections = JSON.parse(JSON.stringify(state.connections || [])).map(conn => ({
          ...conn,
          color: conn.color || '#555555',
          lineWidth: conn.lineWidth || 10,
          dashArray: conn.dashArray || [],
        }));
        nextItemId = state.nextItemId || 0;
        selectedItem = null; connectFromItem = null; itemsToGroup = [];
        drawCanvas(); updateUndoRedoButtons(); updateInfoModal();
        if (state.drawnPaths) {
          drawnPaths = JSON.parse(JSON.stringify(state.drawnPaths));
        } else {
          drawnPaths = [];
        }
        resetDrawingHistory();
        if (state.scale !== undefined) scale = state.scale;
        if (state.originX !== undefined) originX = state.originX;
        if (state.originY !== undefined) originY = state.originY;
        if (state.zoomLevel !== undefined) zoomLevel = state.zoomLevel;
        if (zoomLevelIndicator) zoomLevelIndicator.textContent = zoomLevel;

        selectedItem = null; connectFromItem = null; itemsToGroup = [];
        updateUndoRedoButtons();
        updateInfoModal();
        drawCanvas();
      }

      function updateUndoRedoButtons() {
        undoButton.disabled = historyIndex < 0;
        redoButton.disabled = historyIndex >= history.length - 1;
      }

      function checkAddUnitButtonState() {
        let hasAtLeastOneImage = false;
        Object.values(imageSlots).forEach(slot => {
          if (slot.data && slot.data.img) hasAtLeastOneImage = true;
        });
        addUnitButton.disabled = !hasAtLeastOneImage;
      }

      function checkAddTextButtonState() {
        addTextItemButton.disabled = addTextContentInput.value.trim() === '';
      }

      function checkAddImageCollectionButtonState() {
        addImageCollectionButton.disabled = uploadedCollectionImages.length === 0;
      }

      function handleQrOrderChange(changedSlotKey, changedValue, source) {
        const prefix = source === 'left-panel' ? '' : 'unit-edit-';
        const sakiSuffix = (source === 'left-panel') ? 'saki' : '先';
        const atoSuffix = (source === 'left-panel') ? 'ato' : '後';
        const qr1Saki = document.getElementById(`${prefix}qr1-order-${sakiSuffix}`);
        const qr1Ato = document.getElementById(`${prefix}qr1-order-${atoSuffix}`);
        const qr2Saki = document.getElementById(`${prefix}qr2-order-${sakiSuffix}`);
        const qr2Ato = document.getElementById(`${prefix}qr2-order-${atoSuffix}`);
        if (!qr1Saki || !qr1Ato || !qr2Saki || !qr2Ato) return;
        let operatedCheckbox;
        if (changedSlotKey.includes('qr1')) operatedCheckbox = (changedValue === '先') ? qr1Saki : qr1Ato;
        else operatedCheckbox = (changedValue === '先') ? qr2Saki : qr2Ato;
        const isChecked = operatedCheckbox.checked;
        if (isChecked) {
          if (changedSlotKey.includes('qr1')) {
            if (changedValue === '先') { qr1Ato.checked = false; qr2Saki.checked = false; qr2Ato.checked = true; }
            else { qr1Saki.checked = false; qr2Ato.checked = false; qr2Saki.checked = true; }
          } else {
            if (changedValue === '先') { qr2Ato.checked = false; qr1Saki.checked = false; qr1Ato.checked = true; }
            else { qr2Saki.checked = false; qr1Ato.checked = false; qr1Saki.checked = true; }
          }
        } else {
          if (changedSlotKey.includes('qr1')) { if (changedValue === '先') qr2Ato.checked = false; else qr2Saki.checked = false; }
          else { if (changedValue === '先') qr1Ato.checked = false; else qr1Saki.checked = false; }
        }
      }

      function selectCollectionImageForDetail(index) {
        imageCollectionPreviewsDiv.querySelectorAll('img').forEach(img => img.classList.remove('selected-preview'));
        imageCollectionDetailsDiv.querySelectorAll('.detail-item').forEach(item => item.style.display = 'none');
        const selectedPreview = imageCollectionPreviewsDiv.querySelector(`img[data-index="${index}"]`);
        if (selectedPreview) selectedPreview.classList.add('selected-preview');
        const selectedDetail = imageCollectionDetailsDiv.querySelector(`.detail-item[data-index="${index}"]`);
        if (selectedDetail) selectedDetail.style.display = 'block';
      }

      function renderImageCollectionDetails() {
        imageCollectionDetailsDiv.innerHTML = '';
        uploadedCollectionImages.forEach((imgData, index) => {
          const detailDiv = document.createElement('div'); detailDiv.className = 'detail-item'; detailDiv.dataset.index = index; detailDiv.style.display = 'none';
          const fileNameP = document.createElement('p'); fileNameP.textContent = `ファイル名: ${imgData.fileName}`; detailDiv.appendChild(fileNameP);
          const nameGroup = document.createElement('div'); nameGroup.className = 'form-group';
          const nameLabel = document.createElement('label'); nameLabel.textContent = '名前:'; nameLabel.style.flexBasis = '50px';
          const nameInput = document.createElement('input'); nameInput.type = 'text'; nameInput.value = imgData.name; nameInput.maxLength = 10; nameInput.placeholder = '名前(任意)'; nameInput.oninput = (e) => { uploadedCollectionImages[index].name = e.target.value; };
          nameGroup.appendChild(nameLabel); nameGroup.appendChild(nameInput); detailDiv.appendChild(nameGroup);
          const foodGroup = document.createElement('div'); foodGroup.className = 'form-group';
          const foodLabel = document.createElement('label'); foodLabel.textContent = '好物:'; foodLabel.style.flexBasis = '50px';
          const foodSelect = document.createElement('select');
          ['未選択', 'いちご', 'にがうり', 'とうがらし', 'バナナ', 'レモン', 'ぶどう', 'かき'].forEach(food => { const option = document.createElement('option'); option.value = food; option.textContent = food === '未選択' ? '選択(任意)' : food; foodSelect.appendChild(option); });
          foodSelect.value = imgData.food; foodSelect.onchange = (e) => { uploadedCollectionImages[index].food = e.target.value; };
          foodGroup.appendChild(foodLabel); foodGroup.appendChild(foodSelect); detailDiv.appendChild(foodGroup);
          imageCollectionDetailsDiv.appendChild(detailDiv);
        });
        if (uploadedCollectionImages.length > 0) selectCollectionImageForDetail(0);
      }

      function closeCropperModal() {
        cropperModal.style.display = 'none';
        if (currentEditingUnitContext === 'unit-edit-modal' || currentEditingUnitContext === 'collection-edit-modal') modalOverlay.style.zIndex = '1040';
        else modalOverlay.style.display = 'none';
        if (cropper) cropper.destroy(); cropper = null; currentCropFinalizeCallback = null;
      }

      function resetImageUploadsAndInputs() {
        Object.keys(imageSlots).forEach(slotKey => {
          const slotUI = imageSlots[slotKey];
          slotUI.previewImg.style.display = 'none'; slotUI.previewImg.src = '#'; slotUI.uploadInput.value = '';
          slotUI.editBtn.disabled = true; slotUI.clearBtn.classList.add('hidden');
          slotUI.nameInput.value = ''; slotUI.foodSelect.value = '未選択';
          if (slotUI.orderSakiCheckbox) slotUI.orderSakiCheckbox.checked = false;
          if (slotUI.orderAtoCheckbox) slotUI.orderAtoCheckbox.checked = false;
          slotUI.data = null;
        });
        addUnitBorderVisibleCheckbox.checked = true; checkAddUnitButtonState();
        imageCollectionUploadInput.value = ''; uploadedCollectionImages = [];
        imageCollectionPreviewsDiv.innerHTML = ''; imageCollectionDetailsDiv.innerHTML = '';
        imageCollectionBorderCheckbox.checked = true; checkAddImageCollectionButtonState();
        if (clearImageCollectionButton) clearImageCollectionButton.classList.add('hidden');
      }

      function wrapTextAndMeasure(text, maxWidth, fontSize, font, lineHeightMultiplier) {
        const words = text.split(/(\s+|\n)/); const lines = []; let currentLine = ''; let maxLineWidth = 0;
        const originalFont = ctx.font; ctx.font = `${fontSize}px ${font}`;
        for (const word of words) {
          if (word === '\n') { lines.push(currentLine); maxLineWidth = Math.max(maxLineWidth, ctx.measureText(currentLine).width); currentLine = ''; continue; }
          if (word.trim() === '' && word.length > 0) { currentLine += word; continue; }
          const testLine = currentLine + word; const testWidth = ctx.measureText(testLine).width;
          if (testWidth > maxWidth && currentLine !== '' && maxWidth > 0) {
            const wordWidth = ctx.measureText(word).width;
            if (wordWidth > maxWidth) { lines.push(currentLine); maxLineWidth = Math.max(maxLineWidth, ctx.measureText(currentLine).width); lines.push(word); maxLineWidth = Math.max(maxLineWidth, wordWidth); currentLine = ''; }
            else { lines.push(currentLine); maxLineWidth = Math.max(maxLineWidth, ctx.measureText(currentLine).width); currentLine = word.trimStart(); }
          } else { currentLine = testLine; }
        }
        lines.push(currentLine); maxLineWidth = Math.max(maxLineWidth, ctx.measureText(currentLine).width);
        ctx.font = originalFont;
        const nonEmptyLines = lines.filter((line, index) => line.trim() !== '' || index < lines.length - 1 || lines.length === 1);
        const calculatedHeight = nonEmptyLines.length * fontSize * lineHeightMultiplier;
        return { linesArray: nonEmptyLines, calculatedWidth: maxLineWidth, calculatedHeight: calculatedHeight };
      }

      function drawCanvas() {
        const itemsToDraw = {
          units: units,
          groups: groups,
          connections: connections,
          textItems: textItems,
          drawnPaths: drawnPaths,
          drawnPathsInProgress: currentDrawingPath, // 現在描画中のパスも渡す
          selectedItem: selectedItem,
          connectFromItem: connectFromItem,
          itemsToGroup: itemsToGroup,
          isDrawing: isDrawing // 現在描画モードかどうか
        };
        const currentSettings = {
          scale: scale,
          originX: originX,
          originY: originY,
          mode: currentMode // 必要であれば現在の操作モードも渡す
        };
        drawAllElementsOnContext(ctx, canvas, itemsToDraw, currentSettings);
      }
      function performUnifySize(baseUnit, scope, targetUnitsArray = null) {
        if (!baseUnit) {
          console.error("performUnifySize: 基準ユニットが指定されていません。");
          return;
        }
        const baseWidth = baseUnit.width;
        const baseHeight = baseUnit.height;
        let affectedUnits = [];
        let unifiedCount = 0;

        console.log(`performUnifySize: scope=${scope}, baseUnit=${getItemDisplayName(baseUnit)}`);

        if (scope === 'all') {
          affectedUnits = units.filter(u => u.id !== baseUnit.id && u.type === baseUnit.type);
        } else if (scope === 'visible') {
          affectedUnits = units.filter(u => {
            if (u.id === baseUnit.id || u.type !== baseUnit.type) return false;
            const unitRect = { // ユニットの表示上の矩形
              left: u.x * scale + originX,
              top: u.y * scale + originY,
              right: (u.x + u.width) * scale + originX,
              bottom: (u.y + u.height) * scale + originY
            };
            const canvasRect = { // キャンバスの表示領域
              left: 0,
              top: 0,
              right: mainCanvasArea.clientWidth, // mainCanvasArea を使用
              bottom: mainCanvasArea.clientHeight
            };
            // 矩形が一部でも重なっていれば表示されているとみなす
            return unitRect.left < canvasRect.right && unitRect.right > canvasRect.left &&
              unitRect.top < canvasRect.bottom && unitRect.bottom > canvasRect.top;
          });
        } else if (scope === 'selected' && targetUnitsArray && targetUnitsArray.length > 0) {
          // targetUnitsArray は既に isTargetSelectedForUnify でフィルタリングされたものを受け取る想定だが、
          // 念のため、ここでも baseUnit とタイプが同じか確認する
          affectedUnits = targetUnitsArray.filter(u => u.id !== baseUnit.id && u.type === baseUnit.type);
        }

        if (affectedUnits.length === 0) {
          showStatusBar('対象となるユニットがありませんでした。', unifySizeButton);
          // 選択解除
          unifySizeTargetUnits.forEach(u => u.isTargetSelectedForUnify = false);
          unifySizeTargetUnits = [];
          drawCanvas();
          return;
        }

        affectedUnits.forEach(unit => {
          unit.width = baseWidth;
          // アスペクト比を無視して基準ユニットの高さに一旦合わせる
          unit.height = baseHeight;

          // 画像集合ユニットの場合、高さは内容に応じて再計算（オプション）
          if (unit.type === 'image-collection') {
            const newSize = calculateImageCollectionUnitSize(unit.images, unit.layoutSettings);
            // 幅はbaseWidthのまま、高さだけ内容に合わせる
            unit.height = newSize.height;
          }
          // 通常ユニットの場合も、最小高さを下回らないようにする (オプション)
          else if (unit.type === 'unit') {
            const minRequiredHeight = calculateUnitHeight(unit.slots);
            unit.height = Math.max(unit.height, minRequiredHeight);
          }

          if (unit.isTargetSelectedForUnify) { // isTargetSelectedForUnify が設定されていれば解除
            unit.isTargetSelectedForUnify = false;
          }
          unifiedCount++;
        });

        if (unifiedCount > 0) {
          showStatusBar(`${unifiedCount}個のユニットのサイズを統一しました。`, unifySizeButton);
          saveState();
          drawCanvas();
        }
        unifySizeTargetUnits.forEach(u => u.isTargetSelectedForUnify = false);
        unifySizeTargetUnits = [];
      }
      function drawArrowhead(ctx, fromX, fromY, toX, toY, lineWidth) {

        // 矢じりの翼の長さを調整
        const baseHeadLength = 20; // 矢じりの基本的な長さ
        const headLengthFactor = 4; // 線の太さに対する倍率
        const headLength = Math.max(baseHeadLength, lineWidth * headLengthFactor);

        // 矢じりの翼の開く角度 (ラジアン)。小さいほど鋭角に、大きいほど鈍角に。
        const arrowAngle = Math.PI / 7; // (Math.PI / 6 は30度)

        // 線分の角度を計算
        const angle = Math.atan2(toY - fromY, toX - fromX);

        const x1 = toX - headLength * Math.cos(angle - arrowAngle);
        const y1 = toY - headLength * Math.sin(angle - arrowAngle);

        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(x1, y1);
        ctx.stroke();

        const x2 = toX - headLength * Math.cos(angle + arrowAngle);
        const y2 = toY - headLength * Math.sin(angle + arrowAngle);

        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }

      function drawRoundedRect(ctx, x, y, width, height, radius) {
        ctx.beginPath(); ctx.moveTo(x + radius, y); ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius); ctx.quadraticCurveTo(x, y, x + radius, y); ctx.closePath();
      }

      function truncateText(text, maxLength) {
        if (!text) return '';
        return text.length > maxLength ? text.substring(0, maxLength - 1) + '…' : text;
      }

      function findItemById(id) {
        return units.find(u => u.id === id) || groups.find(g => g.id === id) || textItems.find(t => t.id === id);
      }

      function getCanvasCoordinates(event) {
        const rect = canvas.getBoundingClientRect(); let clientX, clientY;
        if (event.touches && event.touches.length > 0) { clientX = event.touches[0].clientX; clientY = event.touches[0].clientY; }
        else { clientX = event.clientX; clientY = event.clientY; }
        const canvasElementX = clientX - rect.left; const canvasElementY = clientY - rect.top;
        return { x: (canvasElementX - originX) / scale, y: (canvasElementY - originY) / scale };
      }

      function getResizeHandle(item, x, y) {
        if (!item || (item.type !== 'unit' && item.type !== 'group' && item.type !== 'text' && item.type !== 'image-collection')) return null;
        if (!selectedItem || selectedItem.id !== item.id) return null;
        const handleSize = BORDER_RESIZE_THRESHOLD / scale;
        const right = item.x + item.width; const bottom = item.y + item.height;
        const left = item.x; const top = item.y;
        const onRight = Math.abs(x - right) < handleSize; const onBottom = Math.abs(y - bottom) < handleSize;
        const onLeft = Math.abs(x - left) < handleSize; const onTop = Math.abs(y - top) < handleSize;
        if (onRight && onBottom) return 'bottom-right'; if (onLeft && onBottom) return 'bottom-left';
        if (onRight && onTop) return 'top-right'; if (onLeft && onTop) return 'top-left';
        if (onRight) return 'right'; if (onBottom) return 'bottom';
        if (onLeft) return 'left'; if (onTop) return 'top';
        return null;
      }
      function getLineMidpoint(lineId) {
        const line = connections.find(conn => conn.id === lineId);
        if (!line) {
          console.warn(`getLineMidpoint: Line with id ${lineId} not found.`);
          return null;
        }
        const fromItem = findItemById(line.fromId);
        const toItem = findItemById(line.toId);

        if (fromItem && toItem &&
          (fromItem.type === 'unit' || fromItem.type === 'image-collection' || fromItem.type === 'group' || fromItem.type === 'text') &&
          (toItem.type === 'unit' || toItem.type === 'image-collection' || toItem.type === 'group' || toItem.type === 'text')) {
          const startX = fromItem.x + fromItem.width / 2;
          const startY = fromItem.y + fromItem.height / 2;
          const endX = toItem.x + toItem.width / 2;
          const endY = toItem.y + toItem.height / 2;
          return { x: (startX + endX) / 2, y: (startY + endY) / 2, originalLineId: lineId };
        } else {
          console.warn(`getLineMidpoint: Line ${lineId} does not connect two standard items directly. fromId: ${line.fromId} (type: ${fromItem?.type}), toId: ${line.toId} (type: ${toItem?.type})`);
          return null;
        }
      }

      function handleInteractionStart(event) {
        if (event.touches && event.touches.length === 2 && !currentMode) {
          isPanning = false;
          draggingItem = null;
          resizingItem = null;
          selectedItem = null;
          isPinching = true;
          const t0 = event.touches[0];
          const t1 = event.touches[1];
          lastPinchDistance = Math.hypot(t1.clientX - t0.clientX, t1.clientY - t0.clientY);
          pinchStartScreenCenterX = (t0.clientX + t1.clientX) / 2;
          pinchStartScreenCenterY = (t0.clientY + t1.clientY) / 2;
          const rect = canvas.getBoundingClientRect();
          const pinchStartCanvasX_onScreen = pinchStartScreenCenterX - rect.left;
          const pinchStartCanvasY_onScreen = pinchStartScreenCenterY - rect.top;
          pinchStartCanvasCenterX = (pinchStartCanvasX_onScreen - originX) / scale;
          pinchStartCanvasCenterY = (pinchStartCanvasY_onScreen - originY) / scale;
          canvas.style.cursor = 'move';
          return;
        }
        const coords = getCanvasCoordinates(event);
        let clickedItem = null;
        let clickedResizeHandleType = null;
        let clickedLine = null;

        if (!currentMode || currentMode !== 'draw-path') {
          let foundItem = null;
          const checkOrder = [...groups, ...units, ...textItems];

          for (let i = 0; i < checkOrder.length; i++) {
            const item = checkOrder[i];
            let itemBoundary = { x: item.x, y: item.y, width: item.width, height: item.height };

            if (item.type === 'group') {
              if (coords.x >= itemBoundary.x && coords.x <= itemBoundary.x + itemBoundary.width &&
                coords.y >= itemBoundary.y && coords.y <= itemBoundary.y + itemBoundary.height) {
                let unitInGroupClicked = false;
                for (const unitId of item.itemIds) {
                  const unitInGroup = findItemById(unitId);
                  if (unitInGroup &&
                    coords.x >= unitInGroup.x && coords.x <= unitInGroup.x + unitInGroup.width &&
                    coords.y >= unitInGroup.y && coords.y <= unitInGroup.y + unitInGroup.height) {
                    foundItem = unitInGroup;
                    unitInGroupClicked = true;
                    break;
                  }
                }
                if (!unitInGroupClicked) {
                  foundItem = item;
                }
                if (foundItem) break;
              }
            } else {
              const isItemInAGroup = groups.some(g => g.itemIds.includes(item.id));
              if (!isItemInAGroup ||
                currentMode === 'edit-item' ||
                (currentMode && currentMode.startsWith('unify-size'))
              ) {
                if (coords.x >= itemBoundary.x && coords.x <= itemBoundary.x + itemBoundary.width &&
                  coords.y >= itemBoundary.y && coords.y <= itemBoundary.y + itemBoundary.height) {
                  foundItem = item;
                  break;
                }
              }
            }
          }
          clickedItem = foundItem;
        }


        if (!clickedItem && (!currentMode || currentMode !== 'draw-path')) {
          let minDistanceSq = Infinity;
          const clickThresholdRadius = 10 / scale;
          const clickThresholdSq = clickThresholdRadius * clickThresholdRadius;

          for (const conn of connections) {
            if (conn.fromId.startsWith('conn-') || conn.toId.startsWith('conn-')) {
              continue;
            }

            const fromItem = findItemById(conn.fromId);
            const toItem = findItemById(conn.toId);

            if (fromItem && toItem) {
              const p1 = { x: fromItem.x + fromItem.width / 2, y: fromItem.y + fromItem.height / 2 };
              const p2 = { x: toItem.x + toItem.width / 2, y: toItem.y + toItem.height / 2 };

              const lenSq = (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
              if (lenSq === 0) continue;

              let t = ((coords.x - p1.x) * (p2.x - p1.x) + (coords.y - p1.y) * (p2.y - p1.y)) / lenSq;
              t = Math.max(0, Math.min(1, t));

              const closestPoint = {
                x: p1.x + t * (p2.x - p1.x),
                y: p1.y + t * (p2.y - p1.y)
              };
              const distanceSq = (coords.x - closestPoint.x) ** 2 + (coords.y - closestPoint.y) ** 2;

              if (distanceSq < minDistanceSq && distanceSq < clickThresholdSq) {
                minDistanceSq = distanceSq;
                clickedLine = conn;
              }
            }
          }
          if (clickedLine) {
            console.log("Clicked on line:", clickedLine.id);
          }
        }

        const targetForItemOrLine = clickedItem || clickedLine;

        if (currentMode === 'unify-size-select-base') {
          if (targetForItemOrLine && (targetForItemOrLine.type === 'unit' || targetForItemOrLine.type === 'image-collection')) {
            unifySizeBaseUnit = targetForItemOrLine;
            document.getElementById('unify-base-unit-name').textContent = getItemDisplayName(unifySizeBaseUnit);
            document.getElementById('unify-base-unit-size').textContent = `${unifySizeBaseUnit.width.toFixed(0)}x${unifySizeBaseUnit.height.toFixed(0)}`;
            openModal(document.getElementById('unify-size-options-modal'));
            unifySizeModeSubState = 'show-options';
            hideStatusBar();
          } else if (targetForItemOrLine) {
            showStatusBar('基準としてユニットまたは画像集合ユニットを選択してください。', unifySizeButton);
          }
          return;
        } else if (currentMode === 'unify-size-select-targets') {
          if (targetForItemOrLine && (targetForItemOrLine.type === 'unit' || targetForItemOrLine.type === 'image-collection')) {
            if (unifySizeBaseUnit && targetForItemOrLine.id === unifySizeBaseUnit.id) {
              showStatusBar('基準ユニット自身は対象として選択できません。', unifySizeButton);
            } else {
              const index = unifySizeTargetUnits.findIndex(u => u.id === targetForItemOrLine.id);
              if (index > -1) {
                unifySizeTargetUnits.splice(index, 1);
                targetForItemOrLine.isTargetSelectedForUnify = false;
              } else {
                unifySizeTargetUnits.push(targetForItemOrLine);
                targetForItemOrLine.isTargetSelectedForUnify = true;
              }
              showStatusBar(`${unifySizeTargetUnits.length}個のユニットを選択中。完了したら「選択完了」ボタン。`, unifySizeButton);
              drawCanvas();
            }
          } else if (targetForItemOrLine) {
            showStatusBar('対象としてユニットまたは画像集合ユニットを選択してください。', unifySizeButton);
          }
          return;
        }
        if (currentMode === 'align-select-base') {
          if (clickedItem && (clickedItem.type === 'unit' || clickedItem.type === 'image-collection')) {
            alignBaseUnit = clickedItem;
            alignBaseUnit.isAlignmentBase = true;

            currentMode = 'align-select-targets';
            if (alignButton) {
              alignButton.textContent = '整列方法選択';
              alignButton.dataset.originalText = "整列";
            }
            showStatusBar(
              modeMessages['align-select-targets'] + ` (基準: ${getItemDisplayName(alignBaseUnit)})`,
              alignButton
            );
            console.log("基準ユニット選択:", getItemDisplayName(alignBaseUnit));
          } else if (targetForItemOrLine) {
            showStatusBar('整列の基準としてユニットまたは画像集合ユニットを選択してください。', alignButton);
          } else { // 背景クリック
            // 何もしないか、モードをキャンセルするか選べる (今回は何もしない)
          }
          drawCanvas();
          return;
        }
        else if (currentMode === 'align-select-targets') {
          if (clickedItem && (clickedItem.type === 'unit' || clickedItem.type === 'image-collection')) {
            if (alignBaseUnit && clickedItem.id === alignBaseUnit.id) {
              showStatusBar('基準ユニット自身は対象として選択できません。', alignButton);
            } else {
              const index = alignTargetUnits.findIndex(u => u.id === clickedItem.id);
              if (index > -1) {
                alignTargetUnits.splice(index, 1);
                clickedItem.isTargetForAlignment = false;
              } else {
                alignTargetUnits.push(clickedItem);
                clickedItem.isTargetForAlignment = true;
              }
              showStatusBar(
                `対象 ${alignTargetUnits.length}個選択中。基準: ${getItemDisplayName(alignBaseUnit)}`,
                alignButton
              );
              console.log("対象ユニット選択:", alignTargetUnits.map(u => getItemDisplayName(u)));
            }
          } else if (targetForItemOrLine) {
            showStatusBar('整列の対象としてユニットまたは画像集合ユニットを選択してください。', alignButton);
          }
          drawCanvas();
          return;
        }

        if (currentMode === 'draw-path') {
          isDrawing = true;
          currentDrawingPath = [{
            type: drawingShape,
            color: drawingShape === 'eraser' ? (canvas.style.backgroundColor || '#fdfdfd') : drawingColor,
            lineWidth: drawingLineWidth,
            points: [[coords.x, coords.y]],
            isFilled: (drawingShape === 'rectangle' || drawingShape === 'circle') ? drawingFillCheckbox.checked : false,
            startX: coords.x,
            startY: coords.y
          }];
          drawCanvas();
          return;
        }

        if (selectedItem && !currentMode && !targetForItemOrLine && !isPinching) {
          clickedResizeHandleType = getResizeHandle(selectedItem, coords.x, coords.y);
          if (clickedResizeHandleType) {
            resizingItem = selectedItem;
            resizeHandle = clickedResizeHandleType;
            canvas.style.cursor = getResizeCursor(resizeHandle);
            canvas.classList.add('resizing');
            dragOffsetX = coords.x;
            dragOffsetY = coords.y;
            return;
          }
        }


        if (!resizingItem) {
          if (currentMode === 'connect') {
            // ... (前回の connect モードの処理はここにそのまま入ります) ...
            if (!connectFromItem) { // 接続元がまだ選択されていない場合
              if (targetForItemOrLine) { // 何かアイテムか線がクリックされた
                if (targetForItemOrLine.type === 'text') {
                  showStatusBar('テキストアイテムは接続元にできません。', connectButton);
                } else {
                  connectFromItem = targetForItemOrLine;
                  const fromType = targetForItemOrLine.id.startsWith('conn-') ? `線(${truncateText(targetForItemOrLine.id, 10)})` : getItemDisplayName(targetForItemOrLine);
                  showStatusBar(`接続元(${fromType})選択 - 接続先のユニットまたは線を選択`, connectButton);
                }
              }
            } else { // 接続元(connectFromItem)が既に選択されている場合 (これから接続先を選択する)
              if (targetForItemOrLine) {
                if (targetForItemOrLine.id === connectFromItem.id) {
                  showStatusBar('同じアイテム(または線)には接続できません。', connectButton);
                } else if (connectFromItem.id.startsWith('conn-') && targetForItemOrLine.id.startsWith('conn-')) {
                  showStatusBar('線と線を直接接続することはできません。ユニットを選択してください。', connectButton);
                } else if (targetForItemOrLine.type === 'text') {
                  showStatusBar('テキストアイテムは接続先にできません。', connectButton);
                } else {
                  let newConnectionMade = false;
                  let connectionStatusMessage = "";
                  if (!connectFromItem.id.startsWith('conn-') && targetForItemOrLine.id.startsWith('conn-')) {
                    const unitToConnect = connectFromItem;
                    const lineToConnectTo = targetForItemOrLine;
                    const lineMidpoint = getLineMidpoint(lineToConnectTo.id);
                    if (unitToConnect && unitToConnect.type !== 'text' && lineMidpoint) {
                      const newConnectionId = `conn-${nextItemId++}`;
                      connections.push({ id: newConnectionId, fromId: unitToConnect.id, toId: lineToConnectTo.id, isUnitToLine: true, color: '#555555', lineWidth: 10, dashArray: [] });
                      connectionStatusMessage = `接続(U→L): ${getItemDisplayName(unitToConnect)} -> 線(${truncateText(lineToConnectTo.id, 10)})`;
                      newConnectionMade = true;
                    } else { connectionStatusMessage = 'エラー: U→L 接続情報不足'; if (unitToConnect && unitToConnect.type === 'text') connectionStatusMessage = 'エラー: U→L テキスト不可'; }
                  } else if (connectFromItem.id.startsWith('conn-') && targetForItemOrLine && !targetForItemOrLine.id.startsWith('conn-')) {
                    const lineToConnectFrom = connectFromItem;
                    const unitToConnectTo = targetForItemOrLine;
                    const lineMidpoint = getLineMidpoint(lineToConnectFrom.id);
                    if (lineMidpoint && unitToConnectTo && unitToConnectTo.type !== 'text') {
                      const newConnectionId = `conn-${nextItemId++}`;
                      connections.push({ id: newConnectionId, fromId: lineToConnectFrom.id, toId: unitToConnectTo.id, isLineToUnit: true, color: '#555555', lineWidth: 10, dashArray: [] });
                      connectionStatusMessage = `接続(L→U): 線(${truncateText(lineToConnectFrom.id, 10)}) -> ${getItemDisplayName(unitToConnectTo)}`;
                      newConnectionMade = true;
                    } else { connectionStatusMessage = 'エラー: L→U 接続情報不足'; if (unitToConnectTo && unitToConnectTo.type === 'text') connectionStatusMessage = 'エラー: L→U テキスト不可'; }
                  } else if (!connectFromItem.id.startsWith('conn-') && targetForItemOrLine && !targetForItemOrLine.id.startsWith('conn-')) {
                    const unitFrom = connectFromItem;
                    const unitTo = targetForItemOrLine;
                    if (unitFrom.type !== 'text' && unitTo.type !== 'text' && unitFrom.type && unitTo.type) {
                      const newConnectionId = `conn-${nextItemId++}`;
                      connections.push({ id: newConnectionId, fromId: unitFrom.id, toId: unitTo.id, color: '#555555', lineWidth: 10, dashArray: [] });
                      connectionStatusMessage = `接続(U→U): ${getItemDisplayName(unitFrom)} -> ${getItemDisplayName(unitTo)}`;
                      newConnectionMade = true;
                    } else { connectionStatusMessage = "エラー: U→U 不明なアイテムタイプです。"; }
                  } else { connectionStatusMessage = "無効な接続の組み合わせです。"; console.warn("Invalid connection combination attempt:", connectFromItem, targetForItemOrLine); }

                  if (newConnectionMade) {
                    showStatusBar(connectionStatusMessage, connectButton);
                    saveState();
                    connectFromItem = null;
                  } else {
                    if (connectionStatusMessage) showStatusBar(connectionStatusMessage, connectButton);
                    else showStatusBar("接続できませんでした。対象を確認してください。", connectButton);
                  }
                }
              } else {
                if (connectFromItem) {
                  const fromType = connectFromItem.id.startsWith('conn-') ? `線(${truncateText(connectFromItem.id, 10)})` : getItemDisplayName(connectFromItem);
                  showStatusBar(`接続元(${fromType})の選択を解除。再度接続元を選択してください。`, connectButton);
                  connectFromItem = null;
                }
              }
            }
            // connect モードの処理はここまで。drawCanvasは関数の最後に。
          }
          else if (currentMode === 'grouping') {
            if (clickedItem && (clickedItem.type === 'unit' || clickedItem.type === 'image-collection' || clickedItem.type === 'text')) {
              const index = itemsToGroup.findIndex(item => item.id === clickedItem.id);
              if (index > -1) {
                itemsToGroup.splice(index, 1);
                if (clickedItem.isBeingGrouped) clickedItem.isBeingGrouped = false;
              } else {
                itemsToGroup.push(clickedItem);
                clickedItem.isBeingGrouped = true;
              }
              showStatusBar(
                `${itemsToGroup.length}個選択中。${itemsToGroup.length >= 2 ? '「決定」ボタンでグループ化。' : '2個以上選択して「決定」ボタン。'}`,
                groupButton
              );
            } else if (targetForItemOrLine) {
              showStatusBar("グループ化対象外です。ユニット、画像集合、またはテキストを選択してください。", groupButton);
            }
            // 背景クリック時は何もしない
          }
          // ▼▼▼ ここに edit-item モードの処理を正しく挿入 ▼▼▼
          else if (currentMode === 'edit-item') {
            if (clickedItem) { // アイテムがクリックされた場合
              if (clickedItem.type === 'unit') openUnitEditModal(clickedItem);
              else if (clickedItem.type === 'group') openGroupEditModal(clickedItem);
              else if (clickedItem.type === 'text') openTextEditModal(clickedItem);
              else if (clickedItem.type === 'image-collection') openImageCollectionEditModal(clickedItem);
            } else if (clickedLine) {
              openLineStyleEditModal(clickedLine);
            }
          }
          else if (!currentMode) {
            if (targetForItemOrLine && !isPinching) {
              selectedItem = targetForItemOrLine;
              if (clickedItem) {
                draggingItem = clickedItem;
                dragOffsetX = coords.x - clickedItem.x;
                dragOffsetY = coords.y - clickedItem.y;
                canvas.classList.add('dragging');
                canvas.style.cursor = 'grabbing';
              }
            } else if (!targetForItemOrLine && !isPinching) {
              selectedItem = null;
              isPanning = true;
              lastPanX = event.touches ? event.touches[0].clientX : event.clientX;
              lastPanY = event.touches ? event.touches[0].clientY : event.clientY;
              canvas.style.cursor = 'grabbing';
            }
          }
        }
        drawCanvas();
      }

      function handleInteractionMove(event) {
        if (isPinching && event.touches && event.touches.length === 2 && !currentMode) {
          event.preventDefault(); // ピンチ中はページのスクロールを防ぐ
          const t0 = event.touches[0];
          const t1 = event.touches[1];

          const currentPinchDistance = Math.hypot(t1.clientX - t0.clientX, t1.clientY - t0.clientY);

          if (lastPinchDistance > 0) {
            const scaleFactor = currentPinchDistance / lastPinchDistance;
            const newScale = scale * scaleFactor;
            scale = newScale;

            const currentScreenCenterX = (t0.clientX + t1.clientX) / 2;
            const currentScreenCenterY = (t0.clientY + t1.clientY) / 2;

            const rect = canvas.getBoundingClientRect();
            originX = (currentScreenCenterX - rect.left) - (pinchStartCanvasCenterX * scale);
            originY = (currentScreenCenterY - rect.top) - (pinchStartCanvasCenterY * scale);

            lastPinchDistance = currentPinchDistance;

            const base = 1.2;
            zoomLevel = Math.log(scale) / Math.log(base);
            if (zoomLevelIndicator) zoomLevelIndicator.textContent = Math.round(zoomLevel);
          } else {
            lastPinchDistance = currentPinchDistance;
          }
          drawCanvas();
          return;
        }
        if (isPanning && !currentMode) {
          event.preventDefault();
          const clientX = event.touches ? event.touches[0].clientX : event.clientX;
          const clientY = event.touches ? event.touches[0].clientY : event.clientY;
          originX += clientX - lastPanX;
          originY += clientY - lastPanY;
          lastPanX = clientX;
          lastPanY = clientY;
          drawCanvas();
          return;
        }
        if (currentMode === 'draw-path') {
          if (!isDrawing) {
            return;
          }
          event.preventDefault();
          const coords = getCanvasCoordinates(event);
          if (currentDrawingPath.length > 0) {
            const currentPathObject = currentDrawingPath[0];
            if (currentPathObject && currentPathObject.points) {

              if (currentPathObject.type === 'line' || currentPathObject.type === 'eraser' || currentPathObject.type === 'arrow') {
                currentPathObject.points.push([coords.x, coords.y]);
              } else if (currentPathObject.type === 'rectangle' || currentPathObject.type === 'circle') {
                if (currentPathObject.points.length === 1) {
                  currentPathObject.points.push([coords.x, coords.y]);
                } else if (currentPathObject.points.length === 2) {
                  currentPathObject.points[1] = [coords.x, coords.y];
                }
              }
            }
          }
          drawCanvas();
          return;
        }
        if (resizingItem || (draggingItem && !currentMode)) {
          event.preventDefault();
        }

        const coords = getCanvasCoordinates(event);

        if (resizingItem && resizeHandle) {
          const dx = coords.x - dragOffsetX; const dy = coords.y - dragOffsetY;
          let minWidth, minHeight; const textPadding = TEXT_ITEM_PADDING;
          if (resizingItem.type === 'text') { minWidth = MIN_TEXT_ITEM_WIDTH; minHeight = MIN_TEXT_ITEM_HEIGHT; }
          else if (resizingItem.type === 'unit') { minWidth = UNIT_WIDTH_ONE_SLOT; minHeight = calculateUnitHeight(resizingItem.slots); }
          else if (resizingItem.type === 'image-collection') { const minSize = calculateImageCollectionUnitSize(resizingItem.images || [], resizingItem.layoutSettings); minWidth = minSize.width; minHeight = minSize.height; }
          else { minWidth = 50; minHeight = 50; } // group
          let newWidth = resizingItem.width, newHeight = resizingItem.height, newX = resizingItem.x, newY = resizingItem.y;
          switch (resizeHandle) {
            case 'bottom-right': newWidth = Math.max(resizingItem.width + dx, minWidth); newHeight = Math.max(resizingItem.height + dy, minHeight); break;
            case 'right': newWidth = Math.max(resizingItem.width + dx, minWidth); break;
            case 'left': const pLW = resizingItem.width - dx; if (pLW >= minWidth) { newWidth = pLW; newX = resizingItem.x + dx; } else { newWidth = minWidth; newX = resizingItem.x + (resizingItem.width - minWidth); } break;
            case 'bottom': newHeight = Math.max(resizingItem.height + dy, minHeight); break;
            case 'top': const pTH = resizingItem.height - dy; if (pTH >= minHeight) { newHeight = pTH; newY = resizingItem.y + dy; } else { newHeight = minHeight; newY = resizingItem.y + (resizingItem.height - minHeight); } break;
            case 'top-left': const ptlW = resizingItem.width - dx, ptlH = resizingItem.height - dy; if (ptlW >= minWidth) { newWidth = ptlW; newX = resizingItem.x + dx; } else { newWidth = minWidth; newX = resizingItem.x + (resizingItem.width - minWidth); } if (ptlH >= minHeight) { newHeight = ptlH; newY = resizingItem.y + dy; } else { newHeight = minHeight; newY = resizingItem.y + (resizingItem.height - minHeight); } break;
            case 'top-right': newWidth = Math.max(resizingItem.width + dx, minWidth); const ptrH = resizingItem.height - dy; if (ptrH >= minHeight) { newHeight = ptrH; newY = resizingItem.y + dy; } else { newHeight = minHeight; newY = resizingItem.y + (resizingItem.height - minHeight); } break;
            case 'bottom-left': const pblW = resizingItem.width - dx; newHeight = Math.max(resizingItem.height + dy, minHeight); if (pblW >= minWidth) { newWidth = pblW; newX = resizingItem.x + dx; } else { newWidth = minWidth; newX = resizingItem.x + (resizingItem.width - minWidth); } break;
          }
          if (resizingItem.type === 'group') {
            let cMinX = Infinity, cMinY = Infinity, cMaxX = -Infinity, cMaxY = -Infinity; let hUIG = false;
            resizingItem.itemIds.forEach(id => { const uIG = findItemById(id); if (uIG) { hUIG = true; cMinX = Math.min(cMinX, uIG.x); cMinY = Math.min(cMinY, uIG.y); cMaxX = Math.max(cMaxX, uIG.x + uIG.width); cMaxY = Math.max(cMaxY, uIG.y + uIG.height); } });
            if (hUIG) { const rCW = cMaxX - cMinX; const rCH = cMaxY - cMinY; const mGW = rCW + GROUP_PADDING * 2; const mGH = rCH + GROUP_PADDING * 2; newWidth = Math.max(newWidth, mGW); newHeight = Math.max(newHeight, mGH); if (resizeHandle.includes('left')) { newX = Math.min(newX, cMinX - GROUP_PADDING); if (newX + newWidth < cMaxX + GROUP_PADDING) newWidth = cMaxX + GROUP_PADDING - newX; } else { if (newX + newWidth < cMaxX + GROUP_PADDING) newWidth = cMaxX + GROUP_PADDING - newX; } if (resizeHandle.includes('top')) { newY = Math.min(newY, cMinY - GROUP_PADDING); if (newY + newHeight < cMaxY + GROUP_PADDING) newHeight = cMaxY + GROUP_PADDING - newY; } else { if (newY + newHeight < cMaxY + GROUP_PADDING) newHeight = cMaxY + GROUP_PADDING - newY; } newWidth = Math.max(newWidth, mGW); newHeight = Math.max(newHeight, mGH); }
          } else if (resizingItem.type === 'unit') {
            const pG = groups.find(g => g.itemIds.includes(resizingItem.id));
            if (pG) { const gIL = pG.x + GROUP_PADDING, gIT = pG.y + GROUP_PADDING, gIR = pG.x + pG.width - GROUP_PADDING, gIB = pG.y + pG.height - GROUP_PADDING; if (newX < gIL) { newWidth = resizingItem.x + resizingItem.width - gIL; newX = gIL; } if (newY < gIT) { newHeight = resizingItem.y + resizingItem.height - gIT; newY = gIT; } if (newX + newWidth > gIR) newWidth = gIR - newX; if (newY + newHeight > gIB) newHeight = gIB - newY; newWidth = Math.max(newWidth, minWidth); newHeight = Math.max(newHeight, minHeight); if (newX + newWidth > gIR) newX = gIR - newWidth; if (newY + newHeight > gIB) newY = gIB - newHeight; if (newX < gIL) newX = gIL; if (newY < gIT) newY = gIT; }
          } else if (resizingItem.type === 'image-collection') {
            const newCalculatedSize = calculateImageCollectionUnitSize(resizingItem.images, resizingItem.layoutSettings);
            if (resizeHandle.includes('right') || resizeHandle.includes('left')) newHeight = newCalculatedSize.height;
            else if (resizeHandle.includes('top') || resizeHandle.includes('bottom')) newWidth = newCalculatedSize.width;
            else { newWidth = Math.max(newWidth, newCalculatedSize.width); newHeight = newCalculatedSize.height; }
          }
          resizingItem.width = newWidth; resizingItem.height = newHeight; resizingItem.x = newX; resizingItem.y = newY;
          if (resizingItem.type === 'text' && ['left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right'].includes(resizeHandle)) { const cMW = resizingItem.width - (textPadding * 2); if (cMW > 0) { const m = wrapTextAndMeasure(resizingItem.text, cMW, resizingItem.fontSize, resizingItem.font || DEFAULT_FONT, TEXT_LINE_HEIGHT_MULTIPLIER); const nCH = m.calculatedHeight + (textPadding * 2); resizingItem.height = Math.max(minHeight, nCH); } else { resizingItem.height = minHeight; } }
          dragOffsetX = coords.x; dragOffsetY = coords.y;
          drawCanvas();
        } else if (draggingItem && !currentMode && !isPinching && !isPanning) {
          const targetX = coords.x - dragOffsetX; const targetY = coords.y - dragOffsetY;
          let snappedX = targetX; let snappedY = targetY;
          if (draggingItem.type === 'unit' || draggingItem.type === 'image-collection') {
            const itemConnections = connections.filter(c => c.fromId === draggingItem.id || c.toId === draggingItem.id);
            if (itemConnections.length > 0) {
              const conn = itemConnections[0]; const otherItemId = conn.fromId === draggingItem.id ? conn.toId : conn.fromId;
              const otherItem = findItemById(otherItemId);
              if (otherItem) {
                const dC = { x: targetX + draggingItem.width / 2, y: targetY + draggingItem.height / 2 }; const oC = { x: otherItem.x + otherItem.width / 2, y: otherItem.y + otherItem.height / 2 };
                const dXAbs = Math.abs(dC.x - oC.x); const dYAbs = Math.abs(dC.y - oC.y);
                const currentSnapThreshold = SNAP_THRESHOLD / scale;
                if (dYAbs < currentSnapThreshold && dXAbs > dYAbs * SNAP_RATIO) snappedY = oC.y - draggingItem.height / 2;
                else if (dXAbs < currentSnapThreshold && dYAbs > dXAbs * SNAP_RATIO) snappedX = oC.x - draggingItem.width / 2;
              }
            }
          }
          const finalDeltaX = snappedX - draggingItem.x; const finalDeltaY = snappedY - draggingItem.y;
          if (draggingItem.type === 'unit' || draggingItem.type === 'image-collection' || draggingItem.type === 'text') {
            const parentGroup = groups.find(g => g.itemIds.includes(draggingItem.id));
            if (parentGroup) {
              snappedX = Math.max(parentGroup.x + GROUP_PADDING, Math.min(snappedX, parentGroup.x + parentGroup.width - GROUP_PADDING - draggingItem.width));
              snappedY = Math.max(parentGroup.y + GROUP_PADDING, Math.min(snappedY, parentGroup.y + parentGroup.height - GROUP_PADDING - draggingItem.height));
            }
          }
          draggingItem.x = snappedX; draggingItem.y = snappedY;
          if (draggingItem.type === 'group') { draggingItem.itemIds.forEach(unitId => { const uIG = findItemById(unitId); if (uIG) { uIG.x += finalDeltaX; uIG.y += finalDeltaY; } }); }
          drawCanvas();
        } else if (selectedItem && !currentMode && !isPinching && !isPanning) {
          const hT = getResizeHandle(selectedItem, coords.x, coords.y);
          if (hT) {
            canvas.style.cursor = getResizeCursor(hT);
            canvas.classList.add('resize-handle-hover');
          } else {
            canvas.style.cursor = 'grab';
            canvas.classList.remove('resize-handle-hover');
          }
        }
      }

      function handleInteractionEnd(event) {
        if (isPinching) {
          isPinching = false;
          canvas.style.cursor = currentMode ? (currentMode === 'edit-item' ? 'pointer' : (currentMode === 'draw-path' ? 'crosshair' : 'crosshair')) : 'grab';
          saveState();
        }
        if (isDrawing && currentMode === 'draw-path') {
          isDrawing = false;
          if (currentDrawingPath.length > 0 && currentDrawingPath[0].points.length >= 1) {
            const pathObj = currentDrawingPath[0];
            if ((pathObj.type === 'line' || pathObj.type === 'eraser') && pathObj.points.length < 2) {
              currentDrawingPath = [];
            }
            else if ((pathObj.type === 'rectangle' || pathObj.type === 'circle') &&
              pathObj.points.length === 2 &&
              pathObj.points[0][0] === pathObj.points[1][0] &&
              pathObj.points[0][1] === pathObj.points[1][1]) {
              currentDrawingPath = [];
            }

            if (currentDrawingPath.length > 0) {
              drawnPaths.push(...currentDrawingPath);
              currentDrawingPath = [];
              saveDrawingState();
            }
          } else {
            currentDrawingPath = [];
          }
        } else {
          if (resizingItem && resizingItem.type === 'image-collection') {
            const finalSize = calculateImageCollectionUnitSize(resizingItem.images, resizingItem.layoutSettings);
            resizingItem.width = Math.max(finalSize.width, resizingItem.width);
            resizingItem.height = finalSize.height;
          }
          else if (resizingItem && resizingItem.type === 'text' && ['left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right'].includes(resizeHandle)) {
            const textPaddingForCalc = TEXT_ITEM_PADDING;
            const contentMaxWidth = resizingItem.width - (textPaddingForCalc * 2);
            let minHeight = Math.max(MIN_TEXT_ITEM_HEIGHT, resizingItem.fontSize * TEXT_LINE_HEIGHT_MULTIPLIER + (textPaddingForCalc * 2));
            if (contentMaxWidth > 0) {
              const m = wrapTextAndMeasure(resizingItem.text, contentMaxWidth, resizingItem.fontSize, resizingItem.font || DEFAULT_FONT, TEXT_LINE_HEIGHT_MULTIPLIER);
              const finalHeight = m.calculatedHeight + (textPaddingForCalc * 2);
              resizingItem.height = Math.max(minHeight, finalHeight);
            } else { resizingItem.height = minHeight; }
          }
          else if (resizingItem && resizingItem.type === 'unit') {
            const minRequiredHeight = calculateUnitHeight(resizingItem.slots);
            resizingItem.height = Math.max(resizingItem.height, minRequiredHeight);
            const parentGroup = groups.find(g => g.itemIds.includes(resizingItem.id));
            if (parentGroup) { /* ... (unit in group resize end limits) ... */ }
          }
          else if (resizingItem && resizingItem.type === 'group') {
            let cMinX = Infinity, cMinY = Infinity, cMaxX = -Infinity, cMaxY = -Infinity; let hUIG = false;
            resizingItem.itemIds.forEach(id => { const uIG = findItemById(id); if (uIG) { hUIG = true; cMinX = Math.min(cMinX, uIG.x); cMinY = Math.min(cMinY, uIG.y); cMaxX = Math.max(cMaxX, uIG.x + uIG.width); cMaxY = Math.max(cMaxY, uIG.y + uIG.height); } });
            if (hUIG) { const rCW = cMaxX - cMinX, rCH = cMaxY - cMinY; const mGW = rCW + GROUP_PADDING * 2, mGH = rCH + GROUP_PADDING * 2; resizingItem.width = Math.max(resizingItem.width, mGW); resizingItem.height = Math.max(resizingItem.height, mGH); if (resizingItem.x + GROUP_PADDING > cMinX) resizingItem.x = cMinX - GROUP_PADDING; if (resizingItem.y + GROUP_PADDING > cMinY) resizingItem.y = cMinY - GROUP_PADDING; if (resizingItem.x + resizingItem.width - GROUP_PADDING < cMaxX) resizingItem.x = cMaxX + GROUP_PADDING - resizingItem.width; if (resizingItem.y + resizingItem.height - GROUP_PADDING < cMaxY) resizingItem.y = cMaxY + GROUP_PADDING - resizingItem.height; resizingItem.width = Math.max(resizingItem.width, mGW); resizingItem.height = Math.max(resizingItem.height, mGH); }
          }

          if ((draggingItem || resizingItem || isPanning) && !currentMode) {
            saveState();
          }
        }

        isDrawing = false;
        if (draggingItem) canvas.classList.remove('dragging');
        if (resizingItem) canvas.classList.remove('resizing');
        draggingItem = null;
        resizingItem = null;
        resizeHandle = null;
        if (isPanning) {
          isPanning = false;
        }
        canvas.classList.remove('resize-handle-hover');
        canvas.style.cursor = currentMode ?
          (currentMode === 'edit-item' ? 'pointer' :
            (currentMode === 'draw-path' ? 'crosshair' :
              (currentMode === 'connect' || currentMode.startsWith('group') || currentMode.startsWith('unify-size') || currentMode.startsWith('align') ? 'crosshair' : 'grab')))
          : 'grab';
        drawCanvas();
      }

      function toggleMode(newMode, buttonElement) {
        const unifySizeButton = document.getElementById('unify-size-button');
        const unifySizeCompleteSelectionBtn = document.getElementById('unify-size-complete-selection-btn');
        const unifyOptionsModal = document.getElementById('unify-size-options-modal');

        if (currentModeButtonElement) {
          if (currentModeButtonElement.dataset.originalText) {
            currentModeButtonElement.textContent = currentModeButtonElement.dataset.originalText;
          } else if (currentModeButtonElement.title) {
            currentModeButtonElement.textContent = currentModeButtonElement.title.split('(')[0].trim();
          } else {
            let originalText = "ボタン";
            const btnId = currentModeButtonElement.id;
            if (btnId === 'connect-button') originalText = "接続";
            else if (btnId === 'edit-unit-button') originalText = "編集";
            else if (btnId === 'group-button') originalText = "まとめる";
            else if (btnId === 'unify-size-button') originalText = "サイズ統一";
            else if (btnId === 'draw-mode-button') originalText = "描画";
            else if (btnId === 'align-button') originalText = "整列";
            currentModeButtonElement.textContent = originalText;
          }
          currentModeButtonElement.classList.remove('active-mode-button');
        }

        if (currentMode && currentMode.startsWith('unify-size') && (!newMode || !newMode.startsWith('unify-size'))) {
          unifySizeModeSubState = null;
          unifySizeBaseUnit = null;
          unifySizeTargetUnits.forEach(u => u.isTargetSelectedForUnify = false);
          unifySizeTargetUnits = [];
          if (unifySizeCompleteSelectionBtn) unifySizeCompleteSelectionBtn.style.display = 'none';
          if (unifyOptionsModal && unifyOptionsModal.style.display !== 'none') closeModal(unifyOptionsModal);
        }

        if (currentMode && currentMode.startsWith('align') && (!newMode || !newMode.startsWith('align'))) {
          if (alignBaseUnit) {
            alignBaseUnit.isAlignmentBase = false;
          }
          alignBaseUnit = null;

          if (alignTargetUnits.length > 0) {
            alignTargetUnits.forEach(u => {
              if (u) u.isTargetForAlignment = false;
            });
          }
          alignTargetUnits = [];

          if (alignButton && alignButton.dataset.originalText) {
            alignButton.textContent = alignButton.dataset.originalText;
            alignButton.classList.remove('active-mode-button');
          }
        }

        canvas.classList.remove('mode-active', 'connect-mode-active', 'edit-mode', 'grouping');
        if (drawingToolsPanel && (!newMode || newMode !== 'draw-path')) {
          drawingToolsPanel.style.display = 'none';
        }

        if (currentMode === newMode || newMode === null) {
          currentMode = null;
          currentModeButtonElement = null;
          connectFromItem = null;
          itemsToGroup = [];
          hideStatusBar();
          canvas.style.cursor = 'grab';
        } else {
          currentMode = newMode;
          currentModeButtonElement = buttonElement;

          if (buttonElement) {
            if (!buttonElement.dataset.originalText) {
              buttonElement.dataset.originalText = buttonElement.textContent;
            }
            if (newMode === 'grouping') {
              buttonElement.textContent = '決定'; // グループ化モードなら「決定」
            } else if (newMode && (newMode.startsWith('align') || newMode === 'connect' || newMode === 'edit-item' || newMode === 'draw-path' || newMode.startsWith('unify-size'))) {
              // align, connect, edit-item, draw-path, unify-size モードなら「キャンセル」
              buttonElement.textContent = 'キャンセル';
            } else {
              // その他の場合や、もしものためにデフォルトの「キャンセル」
              buttonElement.textContent = 'キャンセル';
            }
            buttonElement.classList.add('active-mode-button');
          }

          showStatusBar(modeMessages[currentMode] || `モード: ${currentMode}`, buttonElement);
          canvas.classList.add('mode-active');

          if (newMode === 'draw-path') {
            if (drawingToolsPanel) drawingToolsPanel.style.display = 'block';
            canvas.style.cursor = 'crosshair';
            updateFillOptionVisibility();
            resetDrawingHistory();
          } else if (newMode === 'edit-item') {
            canvas.classList.add('edit-mode');
            canvas.style.cursor = 'pointer';
          } else if (newMode === 'grouping') {
            canvas.classList.add('grouping');
            canvas.style.cursor = 'cell';
            itemsToGroup.forEach(it => it.isBeingGrouped = false);
            itemsToGroup = [];
          } else if (newMode.startsWith('unify-size')) {
            canvas.style.cursor = 'pointer';
            if (newMode === 'unify-size-select-base') {
              unifySizeModeSubState = 'select-base';
            }
            if (unifySizeCompleteSelectionBtn) {
              if (newMode === 'unify-size-select-targets') {
                unifySizeCompleteSelectionBtn.style.display = 'inline-block';
              } else {
                unifySizeCompleteSelectionBtn.style.display = 'none';
              }
            }
          } else if (newMode.startsWith('align')) {
            canvas.style.cursor = 'pointer';
            if (newMode === 'align-select-base') {
              // 基準選択開始時の特別な処理は今のところなし
            }
          } else {
            canvas.style.cursor = 'crosshair';
          }
        }
        drawCanvas();
      }

      function showStatusBar(message, buttonElement) {
        statusBar.textContent = message;
        if (buttonElement) {
          const buttonStyle = window.getComputedStyle(buttonElement);
          statusBar.style.backgroundColor = buttonStyle.backgroundColor;
          const bgColor = buttonStyle.backgroundColor;
          if (bgColor.includes('rgb')) {
            try { const rgb = bgColor.match(/\d+/g).map(Number); const luminance = 0.299 * rgb[0] + 0.587 * rgb[1] + 0.114 * rgb[2]; statusBar.style.color = luminance > 128 ? '#333' : '#fff'; }
            catch (e) { statusBar.style.color = '#fff'; }
          } else { statusBar.style.color = '#fff'; }
        } else { statusBar.style.backgroundColor = 'rgba(0,123,255,0.9)'; statusBar.style.color = '#fff'; }
        statusBar.style.display = 'block'; infoButtonContainer.style.top = `${statusBar.offsetHeight + 10}px`;
      }
      function hideStatusBar() { statusBar.style.display = 'none'; infoButtonContainer.style.top = '10px'; }

      function drawUnitForSave(targetContext, unit) {
        targetContext.save(); targetContext.translate(unit.x, unit.y);
        targetContext.fillStyle = '#fff'; drawRoundedRect(targetContext, 0, 0, unit.width, unit.height, 8); targetContext.fill();
        if (unit.borderVisible) { targetContext.strokeStyle = '#333'; targetContext.lineWidth = 2; drawRoundedRect(targetContext, 0, 0, unit.width, unit.height, 8); targetContext.stroke(); }
        const cSP = SLOT_PADDING_BASE, cIP = UNIT_INTERNAL_PADDING_BASE, fS = 11 * BASE_SCALE_FACTOR, tLH = SLOT_TEXT_LINE_HEIGHT_BASE * TEXT_LINE_HEIGHT_MULTIPLIER, bIH = SLOT_IMAGE_HEIGHT_BASE, qIMSH = SLOT_QR_IMAGE_SIZE_BASE;
        let hI = Object.values(unit.slots).some(s => s && s.img), hTI = Object.entries(unit.slots).some(([k, s]) => s && (s.name || (s.food && s.food !== '未選択') || ((k === 'qr1' || k === 'qr2') && s.order)));
        let tSY = cSP; if (hI) { tSY += Math.max(bIH, qIMSH) + (hTI ? IMAGE_TEXT_PADDING : 0); } else if (hTI) { tSY += cSP / 2; }
        const aSK = unit.activeSlotKeys || [], iC = aSK.length; let sW, sSX = cSP; const dSK = [];
        if (iC === 1) { sW = SLOT_WIDTH_BASE; sSX = (unit.width - sW) / 2; if (aSK.length > 0) dSK.push(aSK[0]); }
        else if (iC === 2) { sW = SLOT_WIDTH_BASE; const p = ['qr1', 'birth', 'qr2']; const srtK = [...aSK].sort((a, b) => p.indexOf(a) - p.indexOf(b)); if (srtK.length >= 2) { dSK.push(srtK[0]); dSK.push(srtK[1]); sSX = (unit.width - (sW * 2 + cIP)) / 2; } else if (srtK.length === 1) { dSK.push(srtK[0]); sSX = (unit.width - sW) / 2; } }
        else { sW = SLOT_WIDTH_BASE; const p = ['qr1', 'birth', 'qr2']; dSK.push(...p.filter(k => activeSlotKeys.includes(k))); p.forEach(k => { if (dSK.length < 3 && !dSK.includes(k) && unit.slots[k] && (unit.slots[k].img || unit.slots[k].name || (unit.slots[k].food && unit.slots[k].food !== '未選択') || unit.slots[k].order)) dSK.push(k); }); if (unit.width !== UNIT_WIDTH_THREE_SLOTS && dSK.length > 0 && dSK.length < 3) { const nTD = dSK.length; const tIPN = nTD > 1 ? cIP * (nTD - 1) : 0; const tPN = cSP * 2 + tIPN; sW = nTD > 0 ? (unit.width - tPN) / nTD : SLOT_WIDTH_BASE; sSX = cSP; } else if (dSK.length === 0 && hTI) { sW = unit.width - cSP * 2; sSX = cSP; const fTSlot = p.find(k => unit.slots[k] && (unit.slots[k].name || (unit.slots[k].food && unit.slots[k].food !== '未選択') || ((k === 'qr1' || k === 'qr2') && unit.slots[k].order))); if (fTSlot) dSK.push(fTSlot); } else { sSX = cSP; const nSTC = Math.max(dSK.length, 3); const tP3C = cSP * 2 + cIP * (nSTC - 1); sW = (UNIT_WIDTH_THREE_SLOTS - tP3C) / nSTC; if (dSK.length < 3 && unit.width !== UNIT_WIDTH_THREE_SLOTS) { const nTD = dSK.length; const tIPN = nTD > 1 ? cIP * (nTD - 1) : 0; const tPN = cSP * 2 + tIPN; sW = nTD > 0 ? (unit.width - tPN) / nTD : SLOT_WIDTH_BASE; } } }
        let cSX = sSX; const sOForD = ['qr1', 'birth', 'qr2']; let dCnt = 0;
        for (const sK of sOForD) {
          if (!dSK.includes(sK) && dCnt >= iC && iC > 0) continue; if (!unit.slots[sK]) continue;
          const sD = unit.slots[sK]; targetContext.save(); targetContext.translate(cSX, cSP);
          const iTD = sD?.img; const sAvH = (sK === 'birth') ? bIH : qIMSH; const sAvW = sW;
          if (iTD && iTD.complete && iTD.naturalWidth > 0) { try { const ar = iTD.naturalWidth / iTD.naturalHeight; let dW, dH; if (sK === 'birth') { dW = sAvW; dH = dW / ar; if (dH > sAvH) { dH = sAvH; dW = dH * ar; } } else { if (sAvW / ar <= sAvH) { dW = sAvW; dH = dW / ar; } else { dH = sAvH; dW = dH * ar; } } dW = Math.min(dW, sW); const iX = (sW - dW) / 2, iY = (sAvH - dH) / 2; targetContext.drawImage(iTD, iX, iY, dW, dH); } catch (e) { console.error("Error drawing image for save:", e); } }
          if (hTI && sD) { targetContext.font = `${fS}px ${DEFAULT_FONT}`; targetContext.textAlign = 'center'; let cTLY = tSY; const tAvH = unit.height - tSY - cSP; const tSSt = 'rgba(255,255,255,0.8)'; const tSWi = 3; const dTWOF = (t, y) => { if (y - tSY + tLH <= tAvH + 1) { targetContext.strokeStyle = tSSt; targetContext.lineWidth = tSWi; targetContext.strokeText(t, sW / 2, y - cSP, sW); targetContext.fillStyle = '#333'; targetContext.fillText(t, sW / 2, y - cSP, sW); return true; } return false; }; if (sD.name) { if (dTWOF(truncateText(sD.name, 12), cTLY)) cTLY += tLH; } if (sD.food && sD.food !== '未選択') { if (dTWOF(truncateText('好物:' + sD.food, 15), cTLY)) cTLY += tLH; } if (sD.order && (sK === 'qr1' || sK === 'qr2')) { dTWOF(sD.order, cTLY); } }
          targetContext.restore(); dCnt++; if (dCnt < dSK.length || (dSK.length < 3 && dCnt < 3)) cSX += sW + cIP;
        }
        targetContext.restore();
      }

      function updateZoom() { scale = Math.pow(1.2, zoomLevel); zoomLevelIndicator.textContent = zoomLevel; drawCanvas(); }
      function openModal(modalElement) { modalOverlay.style.display = 'block'; modalElement.style.display = 'block'; if (modalElement === cropperModal && (currentEditingUnitContext === 'unit-edit-modal' || currentEditingUnitContext === 'collection-edit-modal')) modalOverlay.style.zIndex = '1055'; else modalOverlay.style.zIndex = '1040'; }
      function closeModal(modalElement) { modalElement.style.display = 'none'; const anyOtherOpen = Array.from(document.querySelectorAll('.modal')).some(m => m !== modalElement && (m.style.display === 'block' || m.style.display === 'flex')); if (!anyOtherOpen) modalOverlay.style.display = 'none'; else if (unitEditModal.style.display === 'block' || unitEditModal.style.display === 'flex' || collectionEditModal.style.display === 'block' || collectionEditModal.style.display === 'flex') modalOverlay.style.zIndex = '1040'; }

      function openUnitEditModal(unit) {
        editingUnit = unit;
        editingLine = null;
        editingGroup = null;
        editingTextItem = null;
        editingCollectionUnit = null;
        unitEditModalTitle.textContent = `ユニット編集: ${truncateText(getItemDisplayName(unit), 20)}`;
        unitEditModalBody.innerHTML = '';

        function setupModalQrOrderLogic() {
          console.log("setupModalQrOrderLogic called");
          const qr1Saki = document.getElementById('unit-edit-qr1-order-先');
          const qr1Ato = document.getElementById('unit-edit-qr1-order-後');
          const qr2Saki = document.getElementById('unit-edit-qr2-order-先');
          const qr2Ato = document.getElementById('unit-edit-qr2-order-後');

          console.log("Checkboxes in setupModalQrOrderLogic:", qr1Saki, qr1Ato, qr2Saki, qr2Ato);

          if (!qr1Saki || !qr1Ato || !qr2Saki || !qr2Ato) {
            console.warn("Modal QR order checkboxes not found for logic setup.");
            return;
          }

          const updateChecks = (changedSlot, changedValue, isChecked) => {
            if (isChecked) {
              if (changedSlot === 'qr1' && changedValue === '先') {
                qr1Ato.checked = false;
                qr2Saki.checked = false;
                if (!qr2Ato.checked) qr2Ato.checked = true;
              } else if (changedSlot === 'qr1' && changedValue === '後') {
                qr1Saki.checked = false;
                qr2Ato.checked = false;
                if (!qr2Saki.checked) qr2Saki.checked = true;
              } else if (changedSlot === 'qr2' && changedValue === '先') {
                qr2Ato.checked = false;
                qr1Saki.checked = false;
                if (!qr1Ato.checked) qr1Ato.checked = true;
              } else if (changedSlot === 'qr2' && changedValue === '後') {
                qr2Saki.checked = false;
                qr1Ato.checked = false;
                if (!qr1Saki.checked) qr1Saki.checked = true;
              }
            } else {
              if (changedSlot === 'qr1' && changedValue === '先') {
                qr2Ato.checked = false;
              } else if (changedSlot === 'qr1' && changedValue === '後') {
                qr2Saki.checked = false;
              } else if (changedSlot === 'qr2' && changedValue === '先') {
                qr1Ato.checked = false;
              } else if (changedSlot === 'qr2' && changedValue === '後') {
                qr1Saki.checked = false;
              }
            }
          };

          qr1Saki.addEventListener('change', (e) => updateChecks('qr1', '先', e.target.checked));
          qr1Ato.addEventListener('change', (e) => updateChecks('qr1', '後', e.target.checked));
          qr2Saki.addEventListener('change', (e) => updateChecks('qr2', '先', e.target.checked));
          qr2Ato.addEventListener('change', (e) => updateChecks('qr2', '後', e.target.checked));
        }

        const checkboxesRowContainer = document.createElement('div');
        checkboxesRowContainer.className = 'checkbox-row-container';

        const borderItemContainer = document.createElement('div');
        borderItemContainer.className = 'checkbox-item-container';
        const borderCheckboxInput = document.createElement('input');
        borderCheckboxInput.type = 'checkbox';
        borderCheckboxInput.id = 'unit-edit-border-visible';
        borderCheckboxInput.checked = unit.borderVisible !== undefined ? unit.borderVisible : true;
        const borderLabel = document.createElement('label');
        borderLabel.htmlFor = 'unit-edit-border-visible';
        borderLabel.textContent = '枠表示';
        borderItemContainer.appendChild(borderCheckboxInput);
        borderItemContainer.appendChild(borderLabel);
        checkboxesRowContainer.appendChild(borderItemContainer);

        const imageCount = unit.activeSlotKeys ? unit.activeSlotKeys.length : 0;
        if (unit.type === 'unit' && imageCount === 1) {
          targetIndividualCheckboxInput.disabled = false;
          targetIndividualLabel.title = 'このユニットを推奨捕獲順の最終目標に設定します。';
        } else {
          targetIndividualCheckboxInput.disabled = true;
          targetIndividualCheckboxInput.checked = false;
          targetIndividualLabel.title = '推奨捕獲順の最終目標は、画像が1枚含まれるユニットのみ設定できます。';
        }
        targetItemContainer.appendChild(targetIndividualCheckboxInput);
        targetItemContainer.appendChild(targetIndividualLabel);
        checkboxesRowContainer.appendChild(targetItemContainer);

        unitEditModalBody.appendChild(checkboxesRowContainer);
        unitEditModalBody.appendChild(document.createElement('hr'));

        Object.keys(unit.slots).forEach(sK => {
          const sD = unit.slots[sK];
          const sDv = document.createElement('div');
          sDv.className = 'slot-edit-section';

          const titleH5 = document.createElement('h5');
          titleH5.textContent = `${sK === 'birth' ? '出生' : sK.toUpperCase()}スロット`;
          sDv.appendChild(titleH5);

          const previewImg = document.createElement('img');
          previewImg.id = `unit-edit-preview-${sK}`;
          previewImg.src = sD?.imgDataUrl || 'https://placehold.co/100x50/eee/ccc?text=No+Image';
          previewImg.style.cssText = 'max-width:100px;max-height:50px;display:block;margin-bottom:5px; background-color: #fff; border: 1px solid #ddd;';
          sDv.appendChild(previewImg);

          const currentSlotEditImageButton = document.createElement('button');
          currentSlotEditImageButton.textContent = '画像を編集';
          currentSlotEditImageButton.id = `unit-edit-edit-image-btn-${sK}`;
          currentSlotEditImageButton.style.marginBottom = '5px';
          currentSlotEditImageButton.onclick = () => {
            currentImageSlotKeyForEditing = sK;
            currentEditingUnitContext = 'unit-edit-modal';
            const urlToEdit = editingUnit.slots[sK]?.originalDataUrl || editingUnit.slots[sK]?.imgDataUrl;
            if (urlToEdit) {
              imageToCrop.src = urlToEdit;
              openModal(cropperModal);
              if (cropper) cropper.destroy();
              const aspectRatio = (sK === 'birth') ? NaN : 1;
              aspectRatioSelect.value = isNaN(aspectRatio) ? "NaN" : aspectRatio.toString();
              cropper = new Cropper(imageToCrop, {
                aspectRatio: aspectRatio, viewMode: 1, dragMode: 'move', background: false,
                responsive: true, restore: true, checkCrossOrigin: true, checkOrientation: true,
                modal: true, guides: true, center: true, highlight: true,
                cropBoxMovable: true, cropBoxResizable: true, toggleDragModeOnDblclick: false,
              });
              currentCropFinalizeCallback = (croppedDataUrl) => {
                const img = new Image();
                img.onload = () => {
                  if (!editingUnit.slots[currentImageSlotKeyForEditing]) {
                    editingUnit.slots[currentImageSlotKeyForEditing] = {};
                  }
                  const targetSlot = editingUnit.slots[currentImageSlotKeyForEditing];
                  targetSlot.img = img;
                  targetSlot.imgDataUrl = croppedDataUrl;
                  if (!targetSlot.originalDataUrl || targetSlot.originalDataUrl !== croppedDataUrl) {
                    targetSlot.originalDataUrl = croppedDataUrl;
                  }
                  const modalPreviewImage = document.getElementById(`unit-edit-preview-${currentImageSlotKeyForEditing}`);
                  if (modalPreviewImage) modalPreviewImage.src = croppedDataUrl;
                };
                img.onerror = () => { console.error("モーダル内での切り抜き後画像読み込みエラー:", currentImageSlotKeyForEditing); };
                img.src = croppedDataUrl;
                closeCropperModal();
              };
            } else {
              alert('このスロットに編集可能な元画像データがありません。先に「画像を変更」で画像をアップロードするか、既存の画像があることを確認してください。');
            }
          };
          sDv.appendChild(currentSlotEditImageButton);

          const currentSlotChangeNewImageButton = document.createElement('button');
          currentSlotChangeNewImageButton.textContent = '画像を変更';
          currentSlotChangeNewImageButton.id = `unit-edit-change-new-image-btn-${sK}`;
          currentSlotChangeNewImageButton.style.marginBottom = '10px';
          currentSlotChangeNewImageButton.onclick = () => {
            currentImageSlotKeyForEditing = sK;
            currentEditingUnitContext = 'unit-edit-modal';

            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'image/*';
            fileInput.onchange = (event) => {
              const file = event.target.files[0];
              if (file) {
                const reader = new FileReader();
                reader.onload = (e_reader) => {
                  const newImageDataUrl = e_reader.target.result;
                  const img = new Image();
                  img.onload = () => {
                    if (!editingUnit.slots[currentImageSlotKeyForEditing]) {
                      editingUnit.slots[currentImageSlotKeyForEditing] = { name: '', food: '未選択', order: null, img: null, imgDataUrl: null, originalDataUrl: null, fileName: null };
                    }
                    const targetSlot = editingUnit.slots[currentImageSlotKeyForEditing];
                    targetSlot.img = img;
                    targetSlot.imgDataUrl = newImageDataUrl;
                    targetSlot.originalDataUrl = newImageDataUrl;
                    targetSlot.fileName = file.name;

                    const modalPreviewImage = document.getElementById(`unit-edit-preview-${currentImageSlotKeyForEditing}`);
                    if (modalPreviewImage) modalPreviewImage.src = newImageDataUrl;
                  };
                  img.onerror = () => {
                    console.error("モーダル内での「画像を変更」時の新しい画像読み込みエラー:", currentImageSlotKeyForEditing);
                    alert("画像の読み込みに失敗しました。");
                  };
                  img.src = newImageDataUrl;
                };
                reader.readAsDataURL(file);
              }
            };
            fileInput.click();
          };
          sDv.appendChild(currentSlotChangeNewImageButton);

          // 名前入力
          const nameGroup = document.createElement('div'); nameGroup.className = 'form-group';
          const nameLabel = document.createElement('label'); nameLabel.htmlFor = `unit-edit-name-${sK}`; nameLabel.textContent = '名前:';
          const nameInput = document.createElement('input'); nameInput.type = 'text'; nameInput.id = `unit-edit-name-${sK}`; nameInput.value = sD?.name || ''; nameInput.maxLength = 10; nameInput.dataset.slotKey = sK; nameInput.className = 'unit-edit-slot-name';
          nameGroup.appendChild(nameLabel); nameGroup.appendChild(nameInput); sDv.appendChild(nameGroup);

          // 好物選択
          const foodGroup = document.createElement('div'); foodGroup.className = 'form-group';
          const foodLabel = document.createElement('label'); foodLabel.htmlFor = `unit-edit-food-${sK}`; foodLabel.textContent = '好物:';
          const foodSelect = document.createElement('select'); foodSelect.id = `unit-edit-food-${sK}`; foodSelect.dataset.slotKey = sK; foodSelect.className = 'unit-edit-slot-food';
          ['未選択', 'いちご', 'にがうり', 'とうがらし', 'バナナ', 'レモン', 'ぶどう', 'かき'].forEach(food => {
            const option = document.createElement('option'); option.value = food; option.textContent = food === '未選択' ? '選択(任意)' : food; foodSelect.appendChild(option);
          });
          foodSelect.value = sD?.food || '未選択';
          foodGroup.appendChild(foodLabel); foodGroup.appendChild(foodSelect); sDv.appendChild(foodGroup);

          // 入居順 (QR1, QR2スロットのみ)
          if (sK === 'qr1' || sK === 'qr2') {
            const orderGroup = document.createElement('div');
            orderGroup.className = 'order-checkbox-group';
            const orderMainLabel = document.createElement('label');
            orderMainLabel.textContent = '入居順(任意):';
            orderMainLabel.className = 'order-label';
            orderGroup.appendChild(orderMainLabel);

            const sakiCheckId = `unit-edit-${sK}-order-先`;
            const sakiOrderCheck = document.createElement('input');
            sakiOrderCheck.type = 'checkbox';
            sakiOrderCheck.name = `unit-edit-${sK}-order`;
            sakiOrderCheck.value = '先';
            sakiOrderCheck.id = sakiCheckId;
            sakiOrderCheck.checked = sD?.order === '先';
            sakiOrderCheck.dataset.slotKey = sK;
            sakiOrderCheck.className = 'unit-edit-slot-order';

            const atoCheckId = `unit-edit-${sK}-order-後`;
            const atoOrderCheck = document.createElement('input');
            atoOrderCheck.type = 'checkbox';
            atoOrderCheck.name = `unit-edit-${sK}-order`;
            atoOrderCheck.value = '後';
            atoOrderCheck.id = atoCheckId;
            atoOrderCheck.checked = sD?.order === '後';
            atoOrderCheck.dataset.slotKey = sK;
            atoOrderCheck.className = 'unit-edit-slot-order';

            sakiOrderCheck.addEventListener('change', (e) => {
              if (e.target.checked) {
                atoOrderCheck.checked = false;
                const otherSlotKey = sK === 'qr1' ? 'qr2' : 'qr1';
                const otherSlotSaki = document.getElementById(`unit-edit-${otherSlotKey}-order-先`);
                const otherSlotAto = document.getElementById(`unit-edit-${otherSlotKey}-order-後`);
                if (otherSlotSaki && otherSlotAto) {
                  otherSlotSaki.checked = false;
                  if (!otherSlotAto.checked) otherSlotAto.checked = true;
                }
              }
            });
            atoOrderCheck.addEventListener('change', (e) => {
              if (e.target.checked) {
                sakiOrderCheck.checked = false;
                const otherSlotKey = sK === 'qr1' ? 'qr2' : 'qr1';
                const otherSlotSaki = document.getElementById(`unit-edit-${otherSlotKey}-order-先`);
                const otherSlotAto = document.getElementById(`unit-edit-${otherSlotKey}-order-後`);
                if (otherSlotSaki && otherSlotAto) {
                  otherSlotAto.checked = false;
                  if (!otherSlotSaki.checked) otherSlotSaki.checked = true;
                }
              }
            });

            const sakiLabelElement = document.createElement('label');
            sakiLabelElement.htmlFor = sakiCheckId;
            sakiLabelElement.textContent = '先';
            sakiLabelElement.style.fontWeight = 'normal';

            const atoLabelElement = document.createElement('label');
            atoLabelElement.htmlFor = atoCheckId;
            atoLabelElement.textContent = '後';
            atoLabelElement.style.fontWeight = 'normal';

            orderGroup.appendChild(sakiOrderCheck);
            orderGroup.appendChild(sakiLabelElement);
            orderGroup.appendChild(atoOrderCheck);
            orderGroup.appendChild(atoLabelElement);
            sDv.appendChild(orderGroup);
          }
          unitEditModalBody.appendChild(sDv);
        });
        setupModalQrOrderLogic();

        const duplicateButton = document.getElementById('unit-edit-duplicate-button');
        const deleteButton = document.getElementById('unit-edit-delete-button');
        const applyButton = document.getElementById('unit-edit-apply-button');
        const cancelButton = document.getElementById('unit-edit-cancel-button');

        if (duplicateButton) {
          duplicateButton.style.display = 'inline-block';
        }
        if (deleteButton) {
          deleteButton.style.display = 'inline-block';
          deleteButton.textContent = 'ユニット削除';
        }
        if (applyButton) {
          applyButton.style.display = 'inline-block';
        }
        if (cancelButton) {
          cancelButton.style.display = 'inline-block';
        }

        openModal(unitEditModal);
      }

      function openGroupEditModal(group) {
        editingGroup = group; groupEditModalTitle.textContent = `グループ編集: ${truncateText(group.name || '無名グループ', 20)}`;
        groupEditNameInput.value = group.name || '';
        groupEditBorderVisibleCheckbox.checked = group.borderVisible !== undefined ? group.borderVisible : true;
        openModal(groupEditModal);
      }

      function openTextEditModal(textItem) {
        editingTextItem = textItem; textEditModalTitle.textContent = `テキスト編集: ${truncateText(textItem.text, 15)}`;
        textEditModalBody.innerHTML = `<div class="form-group"><label for="modal-text-content">内容:</label><textarea id="modal-text-content" rows="3">${textItem.text}</textarea></div><div class="form-group"><label for="modal-text-color">文字色:</label><input type="color" id="modal-text-color" value="${textItem.color}"></div><div class="form-group"><label for="modal-text-bgcolor">背景色:</label><input type="color" id="modal-text-bgcolor" value="${textItem.backgroundColor}"></div><div class="form-group"><label for="modal-text-size">サイズ:</label><input type="number" id="modal-text-size" value="${textItem.fontSize}" min="8"></div><div class="form-group-checkbox"><label for="modal-text-border-visible">枠を表示:</label><input type="checkbox" id="modal-text-border-visible"></div><div class="form-group"><label for="modal-text-rotation">回転角度:</label><input type="number" id="modal-text-rotation" value="${textItem.rotation || 0}" step="1" min="-360" max="360"></div>`;
        document.getElementById('modal-text-border-visible').checked = textItem.borderVisible !== undefined ? textItem.borderVisible : true;
        openModal(textEditModal);
      }
      function openLineStyleEditModal(line) {
        editingLine = line;
        editingUnit = null;
        editingGroup = null;
        editingTextItem = null;
        editingCollectionUnit = null;

        const modal = document.getElementById('unit-edit-modal');
        const modalTitle = document.getElementById('unit-edit-modal-title');
        const modalBody = document.getElementById('unit-edit-modal-body');
        const applyButton = document.getElementById('unit-edit-apply-button');
        const cancelButton = document.getElementById('unit-edit-cancel-button');
        const deleteButton = document.getElementById('unit-edit-delete-button');
        const duplicateButton = document.getElementById('unit-edit-duplicate-button');

        modalTitle.textContent = `接続線スタイル編集 (ID: ${truncateText(line.id, 15)})`;
        modalBody.innerHTML = '';

        // 色選択UI
        const colorGroup = document.createElement('div');
        colorGroup.className = 'form-group';
        const colorLabel = document.createElement('label');
        colorLabel.htmlFor = 'line-edit-color';
        colorLabel.textContent = '線の色:';
        const colorInput = document.createElement('input');
        colorInput.type = 'color';
        colorInput.id = 'line-edit-color';
        colorInput.value = line.color || '#555555'; // 現在の色をセット
        colorGroup.appendChild(colorLabel);
        colorGroup.appendChild(colorInput);
        modalBody.appendChild(colorGroup);

        // 太さ選択UI
        const lineWidthGroup = document.createElement('div');
        lineWidthGroup.className = 'form-group';
        const lineWidthLabel = document.createElement('label');
        lineWidthLabel.htmlFor = 'line-edit-lineWidth';
        lineWidthLabel.textContent = '線の太さ:';
        const lineWidthInput = document.createElement('input');
        lineWidthInput.type = 'number';
        lineWidthInput.id = 'line-edit-lineWidth';
        lineWidthInput.value = line.lineWidth || 10;
        lineWidthInput.min = '1';   // 最小値
        lineWidthInput.max = '50';  // 最大値 (適宜調整)
        lineWidthInput.step = '1';
        lineWidthGroup.appendChild(lineWidthLabel);
        lineWidthGroup.appendChild(lineWidthInput);
        modalBody.appendChild(lineWidthGroup);
        const lineDashGroup = document.createElement('div');
        lineDashGroup.className = 'form-group';
        const lineDashLabel = document.createElement('label');
        lineDashLabel.htmlFor = 'line-edit-dashType';
        lineDashLabel.textContent = '線の種類:';
        const lineDashSelect = document.createElement('select');
        lineDashSelect.id = 'line-edit-dashType';

        const lineTypes = [
          { name: '実線', value: '[]' },
          { name: '破線 (標準)', value: '[15, 10]' },
          { name: '破線 (短め)', value: '[8, 6]' },
          { name: '点線 (標準)', value: '[2, 5]' },
          { name: '点線 (細かめ)', value: '[1, 3]' }
        ];

        lineTypes.forEach(type => {
          const option = document.createElement('option');
          option.value = type.value;
          option.textContent = type.name;
          lineDashSelect.appendChild(option);
        });

        const currentDashArrayString = JSON.stringify(line.dashArray || []);
        lineDashSelect.value = currentDashArrayString;
        if (!lineTypes.some(type => type.value === currentDashArrayString)) {
          lineDashSelect.value = '[]';
        }

        lineDashGroup.appendChild(lineDashLabel);
        lineDashGroup.appendChild(lineDashSelect);
        modalBody.appendChild(lineDashGroup);

        if (duplicateButton) {
          duplicateButton.style.display = 'none';
        }
        if (deleteButton) {
          deleteButton.style.display = 'inline-block';
          deleteButton.textContent = '接続線削除';
        }
        if (applyButton) applyButton.style.display = 'inline-block';
        if (cancelButton) cancelButton.style.display = 'inline-block';


        openModal(modal);
      }

      function createGroupFromSelection() {
        if (itemsToGroup.length < 2) return; let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        const groupUnitIds = []; let canGroup = true; let firstItemGroupId = null; let allFromSameGroup = true;
        for (const item of itemsToGroup) {
          if (item.type !== 'unit' && item.type !== 'image-collection' && item.type !== 'text') { showStatusBar("グループ化はユニット系のみ", currentModeButtonElement); canGroup = false; break; }
          const containingGroup = groups.find(g => g.itemIds.includes(item.id));
          if (itemsToGroup.length > 1) { if (firstItemGroupId === null && containingGroup) firstItemGroupId = containingGroup.id; else if (containingGroup?.id !== firstItemGroupId) allFromSameGroup = false; else if (!containingGroup && firstItemGroupId !== null) allFromSameGroup = false; }
          groupUnitIds.push(item.id); minX = Math.min(minX, item.x); minY = Math.min(minY, item.y); maxX = Math.max(maxX, item.x + item.width); maxY = Math.max(maxY, item.y + item.height);
        }
        if (!canGroup) { itemsToGroup = []; drawCanvas(); return; }
        const selectedUnitsAreAllUngrouped = itemsToGroup.every(item => !groups.some(g => g.itemIds.includes(item.id)));
        const selectedUnitsAreAllFromTheSameExistingGroup = firstItemGroupId !== null && allFromSameGroup && itemsToGroup.every(item => groups.find(g => g.itemIds.includes(item.id))?.id === firstItemGroupId);
        if (!selectedUnitsAreAllUngrouped && !selectedUnitsAreAllFromTheSameExistingGroup) { showStatusBar("異なるグループや内外混在は不可", currentModeButtonElement); itemsToGroup = []; drawCanvas(); return; }
        if (selectedUnitsAreAllFromTheSameExistingGroup) { showStatusBar("既に同じグループ", currentModeButtonElement); itemsToGroup = []; drawCanvas(); return; }
        const groupX = minX - GROUP_PADDING; const groupY = minY - GROUP_PADDING;
        const groupWidth = (maxX - minX) + GROUP_PADDING * 2; const groupHeight = (maxY - minY) + GROUP_PADDING * 2;
        const newGroup = { id: `item-${nextItemId++}`, type: 'group', itemIds: groupUnitIds, x: groupX, y: groupY, width: groupWidth, height: groupHeight, name: '', isSelected: false, borderVisible: true };
        groups.push(newGroup); itemsToGroup = []; saveState(); drawCanvas(); showStatusBar("グループ作成完了", currentModeButtonElement);
      }

      function updateInfoModal() {
        const cropCounts = {
          'いちご': 0, 'にがうり': 0, 'とうがらし': 0,
          'バナナ': 0, 'レモン': 0, 'ぶどう': 0, 'かき': 0
        };
        let totalUnitImagesWithFoodSlot = 0; // 好物スロットを持つ可能性のあるユニット内の総画像数
        let birthImagesCount = 0;
        let baseUnitCountWithoutFavFood = 0;

        units.forEach(unit => {
          let isBaseUnitForThisUnit = false;
          let unitHasAnyFavoriteFoodActuallySet = false;

          if (unit.type === 'image-collection') {
            if (unit.images) {
              unit.images.forEach(imgInfo => {
                totalUnitImagesWithFoodSlot++;
                if (imgInfo.food && imgInfo.food !== '未選択' && cropCounts.hasOwnProperty(imgInfo.food)) {
                  cropCounts[imgInfo.food]++;
                  unitHasAnyFavoriteFoodActuallySet = true;
                }
              });
            }
          } else if (unit.type === 'unit') {
            const parents = getDirectParentsStrictRule(unit.id);
            if (parents.length === 0 && unit.activeSlotKeys && unit.activeSlotKeys.length > 0) {
              isBaseUnitForThisUnit = true;
            }

            Object.entries(unit.slots).forEach(([slotKey, slotData]) => {
              if (slotData) {
                if (slotData.img || slotData.imgDataUrl) {
                  totalUnitImagesWithFoodSlot++;
                  if (slotKey === 'birth') birthImagesCount++;
                }
                if (slotData.food && slotData.food !== '未選択' && cropCounts.hasOwnProperty(slotData.food)) {
                  cropCounts[slotData.food]++;
                  unitHasAnyFavoriteFoodActuallySet = true;
                }
              }
            });

            if (isBaseUnitForThisUnit && !unitHasAnyFavoriteFoodActuallySet) {
              baseUnitCountWithoutFavFood++;
              console.log(`[InfoModal] Base unit ${getItemDisplayName(unit)} has no favorite food set. Counting for default seed cost.`);
            }
          }
        });

        requiredCropsList.innerHTML = '';
        let hasAnyCropRequirement = false;
        Object.entries(cropCounts).forEach(([food, count]) => {
          if (count > 0) {
            hasAnyCropRequirement = true;
            const li = document.createElement('li');
            li.className = 'crop-list-item';
            const dot = document.createElement('span');
            dot.className = 'crop-color-dot';
            dot.style.backgroundColor = cropColors[food] || '#ccc';
            li.appendChild(dot);
            li.appendChild(document.createTextNode(`${food}: ${count}個`));
            requiredCropsList.appendChild(li);
          }
        });
        if (!hasAnyCropRequirement) {
          requiredCropsList.innerHTML = '<li><small>好物は設定されていません。</small></li>';
        }
        // --- ここまで「必要作物」リスト表示 ---


        // --- ゴールド計算 ---
        let totalSetFavoriteFoodItems = 0;
        for (const food in cropCounts) {
          totalSetFavoriteFoodItems += cropCounts[food];
        }

        // 1. 実際に好物が設定されている分の必要種数とコスト
        const seedsForSetFavorites = totalSetFavoriteFoodItems * 7; // 各7個必要
        const seedPricePerOne = 150; // 1個あたりの種の値段
        const costForSetFavoritesSeeds = seedsForSetFavorites * seedPricePerOne;

        // 2. 好物未設定の基本ユニット分のデフォルト種コスト (各ユニットにつき7個 * 150G)
        const costForDefaultBaseUnitSeeds = baseUnitCountWithoutFavFood * 7 * seedPricePerOne;

        // 総作物の種コスト
        const totalCropSeedCost = costForSetFavoritesSeeds + costForDefaultBaseUnitSeeds;
        const totalSeedsCalculated = seedsForSetFavorites + (baseUnitCountWithoutFavFood * 7);
        const limitBreakCost = totalUnitImagesWithFoodSlot * 300;
        const birthEventCost = birthImagesCount * 1000; // 出生スロットを持つ画像数に基づく
        const totalGold = limitBreakCost + birthEventCost + totalCropSeedCost;
        document.getElementById('total-gold-cost').textContent = `${totalGold.toLocaleString()} G`;
      }

      function calculateImageCollectionUnitSize(images, layoutSettings = null) {
        console.log("[CalcSize] 開始", "画像数:", images?.length, "渡されたLayoutSettings:", layoutSettings);
        const imageCount = images?.length || 0;

        const defaultLayout = {
          maxSize: COLLECTION_IMAGE_MAX_SIZE, margin: COLLECTION_IMAGE_MARGIN, padding: COLLECTION_PADDING,
          textGap: minTextGapLogical, perRow: COLLECTION_IMAGES_PER_ROW, fontSize: textFontSizeLogical
        };
        // settings オブジェクトの各プロパティが数値であることを保証する
        const getSetting = (key, defaultValue) => {
          let val = (layoutSettings && layoutSettings[key] !== undefined) ? layoutSettings[key] :
            (editingCollectionUnit && editingCollectionUnit.layoutSettings && editingCollectionUnit.layoutSettings[key] !== undefined) ? editingCollectionUnit.layoutSettings[key] :
              defaultValue;
          const numVal = parseInt(val, 10); // 必ず数値に変換
          return isNaN(numVal) ? defaultValue : numVal; // NaNならデフォルト
        };

        const settings = {
          maxSize: getSetting('maxSize', COLLECTION_IMAGE_MAX_SIZE),
          margin: getSetting('margin', COLLECTION_IMAGE_MARGIN),
          padding: getSetting('padding', COLLECTION_PADDING),
          textGap: getSetting('textGap', minTextGapLogical),
          perRow: getSetting('perRow', COLLECTION_IMAGES_PER_ROW),
          fontSize: getSetting('fontSize', textFontSizeLogical)
        };
        console.log("[CalcSize] 使用するSettings:", JSON.parse(JSON.stringify(settings)));


        const logicalPadding = settings.padding;
        const logicalImageMaxSize = settings.maxSize;
        const baseLogicalImageMargin = settings.margin;
        let logicalImagesPerRow = settings.perRow;
        const textFontSizeLogicalValue = settings.fontSize;
        const minTextGapLogicalValue = settings.textGap;
        const textLineHeightLogical = SLOT_TEXT_LINE_HEIGHT_BASE * TEXT_LINE_HEIGHT_MULTIPLIER;
        const imageTextPaddingLogical = IMAGE_TEXT_PADDING;

        if (imageCount === 0) {
          console.log("[CalcSize] 画像0枚 -> デフォルト最小サイズ返却");
          return { width: logicalPadding * 2 + logicalImageMaxSize, height: logicalPadding * 2 + logicalImageMaxSize };
        }

        if (isNaN(logicalImagesPerRow) || logicalImagesPerRow <= 0) {
          console.warn(`[CalcSize] 不正な logicalImagesPerRow (${settings.perRow}) -> デフォルト ${COLLECTION_IMAGES_PER_ROW} 使用`);
          logicalImagesPerRow = COLLECTION_IMAGES_PER_ROW;
        }
        if (logicalImagesPerRow === 0) { // 0除算を避ける
          console.error("[CalcSize] logicalImagesPerRow が0です。デフォルト1を使用します。");
          logicalImagesPerRow = 1;
        }


        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        if (!tempCtx) {
          console.error("[CalcSize] 一時Canvasコンテキスト作成失敗。固定サイズ返却。");
          return { width: 200, height: 150 };
        }
        const fontForMeasure = `${textFontSizeLogicalValue}px ${DEFAULT_FONT}`;
        tempCtx.font = fontForMeasure;
        console.log("[CalcSize] テキスト幅測定用フォント:", fontForMeasure);

        const imageTextWidths = images.map((imgData, idx) => {
          let maxWidth = 0;
          if (imgData.name) {
            const nameWidth = tempCtx.measureText(imgData.name).width;
            maxWidth = Math.max(maxWidth, isNaN(nameWidth) ? 0 : nameWidth);
          }
          if (imgData.food && imgData.food !== '未選択') {
            const foodWidth = tempCtx.measureText('好物:' + imgData.food).width;
            maxWidth = Math.max(maxWidth, isNaN(foodWidth) ? 0 : foodWidth);
          }
          return maxWidth;
        });
        console.log("[CalcSize] 計算された全テキスト幅:", imageTextWidths);


        const hasTextInfo = imageTextWidths.some(width => width > 0);
        const textHeightPerImage = hasTextInfo ? (textLineHeightLogical * 2) + imageTextPaddingLogical : 0;
        const numRows = Math.ceil(imageCount / logicalImagesPerRow);
        console.log(`[CalcSize] 計算された行数 (numRows): ${numRows}`);


        let maxRowOccupiedWidthLogical = 0;
        for (let r = 0; r < numRows; r++) {
          let currentRowContentWidthLogical = 0;
          let currentRowMarginWidthLogical = 0;
          const startIndex = r * logicalImagesPerRow;
          const endIndex = Math.min(startIndex + logicalImagesPerRow, imageCount);
          const imagesInThisRow = endIndex - startIndex;

          for (let i = 0; i < imagesInThisRow; i++) {
            currentRowContentWidthLogical += logicalImageMaxSize;
            if (i > 0) {
              const prevImageIndex = startIndex + i - 1;
              const currentImageIndex = startIndex + i;
              const prevTextW = imageTextWidths[prevImageIndex] || 0;
              const currentTextW = imageTextWidths[currentImageIndex] || 0;
              const neededSpaceForText = (prevTextW / 2) + (currentTextW / 2) + minTextGapLogicalValue;
              const marginToUse = Math.max(baseLogicalImageMargin, (isNaN(neededSpaceForText) ? 0 : neededSpaceForText));
              currentRowMarginWidthLogical += marginToUse;
            }
          }
          currentRowContentWidthLogical += currentRowMarginWidthLogical;

          let requiredLeftPadding = logicalPadding;
          let requiredRightPadding = logicalPadding;
          if (imagesInThisRow > 0) {
            const firstImageIndex = startIndex;
            const lastImageIndex = endIndex - 1;
            const firstImageTextWidth = imageTextWidths[firstImageIndex] || 0;
            const lastImageTextWidth = imageTextWidths[lastImageIndex] || 0;
            requiredLeftPadding = Math.max(logicalPadding, firstImageTextWidth / 2);
            requiredRightPadding = Math.max(logicalPadding, lastImageTextWidth / 2);
          }
          const currentRowOccupiedWidth = requiredLeftPadding + currentRowContentWidthLogical + requiredRightPadding;
          maxRowOccupiedWidthLogical = Math.max(maxRowOccupiedWidthLogical, currentRowOccupiedWidth);
        }
        console.log("[CalcSize] 最大行占有幅(論理):", maxRowOccupiedWidthLogical);

        const unitWidth = maxRowOccupiedWidthLogical;
        const contentHeight = (numRows * logicalImageMaxSize) + (Math.max(0, numRows - 1) * baseLogicalImageMargin) + (numRows * textHeightPerImage);
        const unitHeight = contentHeight + (logicalPadding * 2);
        const minHeightBase = logicalPadding * 2 + logicalImageMaxSize;
        const minHeightWithText = hasTextInfo ? minHeightBase + textHeightPerImage : minHeightBase;
        const minWidthBase = logicalPadding * 2 + logicalImageMaxSize;

        let finalWidth = Math.max(unitWidth, minWidthBase);
        let finalHeight = Math.max(unitHeight, minHeightWithText);

        if (isNaN(finalWidth) || finalWidth <= 0) {
          console.error(`[CalcSize] finalWidth が不正 (${finalWidth})。デフォルト幅200を使用します。`);
          finalWidth = 200;
        }
        if (isNaN(finalHeight) || finalHeight <= 0) {
          console.error(`[CalcSize] finalHeight が不正 (${finalHeight})。デフォルト高150を使用します。`);
          finalHeight = 150;
        }
        console.log(`[CalcSize] 結果: width=${finalWidth}, height=${finalHeight}`);
        return {
          width: finalWidth,
          height: finalHeight
        };
      }

      function drawImagesInCollectionUnit(targetCtx, unit, currentScale = 1, layoutSettings = null) {
        const images = unit.images || [];
        if (images.length === 0) {
          return;
        }

        // --- 設定値取得 ---
        const settings = layoutSettings || unit.layoutSettings || {
          maxSize: COLLECTION_IMAGE_MAX_SIZE, margin: COLLECTION_IMAGE_MARGIN, padding: COLLECTION_PADDING,
          textGap: minTextGapLogical, perRow: COLLECTION_IMAGES_PER_ROW, fontSize: textFontSizeLogical
        };

        const logicalPadding = settings.padding;
        const logicalImageMaxSize = settings.maxSize;
        const baseLogicalImageMargin = settings.margin;
        let logicalImagesPerRow = settings.perRow;
        const textFontSizeLogicalValue = settings.fontSize;
        const minTextGapLogicalValue = settings.textGap;
        const textLineHeightLogical = SLOT_TEXT_LINE_HEIGHT_BASE * TEXT_LINE_HEIGHT_MULTIPLIER;
        const imageTextPaddingLogical = IMAGE_TEXT_PADDING;

        // logicalImagesPerRow バリデーション
        if (isNaN(logicalImagesPerRow) || logicalImagesPerRow <= 0) {
          logicalImagesPerRow = COLLECTION_IMAGES_PER_ROW;
        }

        // --- テキスト幅測定 (tempCtxを使用) ---
        let textMeasurementCtx = null;
        try {
          const tempCanvas = document.createElement('canvas');
          textMeasurementCtx = tempCanvas.getContext('2d');
        } catch (e) {
          console.error("drawImagesInCollectionUnit: 一時Canvasコンテキストの作成に失敗:", e);
        }

        const imageTextWidthsForDrawing = images.map((imgData, idx) => {
          if (!textMeasurementCtx) return 0;
          let mW = 0;
          try {
            textMeasurementCtx.font = `${textFontSizeLogicalValue}px ${DEFAULT_FONT}`;
            if (imgData.name) mW = Math.max(mW, textMeasurementCtx.measureText(truncateText(imgData.name, 8)).width);
            if (imgData.food && imgData.food !== '未選択') mW = Math.max(mW, textMeasurementCtx.measureText(truncateText('好物:' + imgData.food, 10)).width);
            if (isNaN(mW)) return 0;
          } catch (e) { return 0; } return mW;
        });

        const hasTextInfo = imageTextWidthsForDrawing.some(w => w > 0);
        const textHeightPerImage = hasTextInfo ? (textLineHeightLogical * 2) + imageTextPaddingLogical : 0;
        const numRows = Math.ceil(images.length / logicalImagesPerRow);
        if (isNaN(numRows) || numRows <= 0) { /* console.error("行数不正"); */ return; }

        let currentY_logical = logicalPadding;

        for (let r = 0; r < numRows; r++) {
          const startIndex = r * logicalImagesPerRow;
          const endIndex = Math.min(startIndex + logicalImagesPerRow, images.length);
          const imagesInThisRow = endIndex - startIndex;

          let currentRowContentWidthLogical = 0;
          let requiredMarginsWidthLogical = 0;
          let dynamicMargins = [];
          for (let i = 0; i < imagesInThisRow; i++) {
            currentRowContentWidthLogical += logicalImageMaxSize;
            if (i > 0) {
              const prevImageIndex = startIndex + i - 1;
              const currentImageIndex = startIndex + i;
              const prevW = imageTextWidthsForDrawing[prevImageIndex] === undefined ? 0 : imageTextWidthsForDrawing[prevImageIndex];
              const currW = imageTextWidthsForDrawing[currentImageIndex] === undefined ? 0 : imageTextWidthsForDrawing[currentImageIndex];
              const gap = isNaN(minTextGapLogicalValue) ? 4 : minTextGapLogicalValue;
              const baseM = isNaN(baseLogicalImageMargin) ? 5 : baseLogicalImageMargin;
              const needed = (prevW / 2) + (currW / 2) + gap;
              const margin = Math.max(baseM, (isNaN(needed) ? 0 : needed));
              requiredMarginsWidthLogical += margin;
              dynamicMargins.push(margin);
            }
          }
          currentRowContentWidthLogical += requiredMarginsWidthLogical;

          const logicalDrawableUnitWidth = unit.width - (logicalPadding * 2);
          let startX_L = logicalPadding + (logicalDrawableUnitWidth - currentRowContentWidthLogical) / 2;
          if (startX_L < logicalPadding) startX_L = logicalPadding;

          let currentX_L = startX_L;
          for (let i = 0; i < imagesInThisRow; i++) {
            const currentImageDrawIndex = startIndex + i;

            const imgData = images[currentImageDrawIndex];
            const imgObject = imgData.img;

            if (imgObject && imgObject.complete && imgObject.naturalWidth > 0) {
              try {
                let dWL, dHL; const ar = imgObject.naturalWidth / imgObject.naturalHeight;
                if (ar >= 1) { dWL = logicalImageMaxSize; dHL = dWL / ar; } else { dHL = logicalImageMaxSize; dWL = dHL * ar; }
                if (dHL > logicalImageMaxSize) { dHL = logicalImageMaxSize; dWL = dHL * ar; }
                if (dWL > logicalImageMaxSize) { dWL = logicalImageMaxSize; dHL = dWL / ar; }
                const offX = (logicalImageMaxSize - dWL) / 2, offY = (logicalImageMaxSize - dHL) / 2;
                targetCtx.drawImage(imgObject, currentX_L + offX, currentY_logical + offY, dWL, dHL);
              } catch (e) {
                const errBoxSizeL = logicalImageMaxSize; targetCtx.strokeStyle = 'red';
                targetCtx.lineWidth = 1 / currentScale; targetCtx.strokeRect(currentX_L, currentY_logical, errBoxSizeL, errBoxSizeL);
                console.error(`drawImagesInCollectionUnit 画像 ${currentImageDrawIndex}: drawImage中にエラー`, e);
              }
            } else {
              const pSizeL = logicalImageMaxSize; targetCtx.fillStyle = '#e0e0e0';
              targetCtx.fillRect(currentX_L, currentY_logical, pSizeL, pSizeL);
              targetCtx.fillStyle = '#a0a0a0'; targetCtx.font = `${textFontSizeLogicalValue / currentScale}px ${DEFAULT_FONT}`;
              targetCtx.textAlign = 'center'; targetCtx.textBaseline = 'middle';
              targetCtx.fillText('N/A', currentX_L + pSizeL / 2, currentY_logical + pSizeL / 2);
            }

            if (imgData.name || (imgData.food && imgData.food !== '未選択')) {
              targetCtx.fillStyle = '#333'; targetCtx.font = `${textFontSizeLogicalValue / currentScale}px ${DEFAULT_FONT}`;
              targetCtx.textAlign = 'center'; targetCtx.textBaseline = 'top';
              const tStartX_L = currentX_L + logicalImageMaxSize / 2; let tStartY_L = currentY_logical + logicalImageMaxSize + imageTextPaddingLogical;
              const uBY = unit.height - logicalPadding;
              if (imgData.name) { if ((tStartY_L + textLineHeightLogical) <= uBY) targetCtx.fillText(truncateText(imgData.name, 8), tStartX_L, tStartY_L); tStartY_L += textLineHeightLogical; }
              if (imgData.food && imgData.food !== '未選択') { if ((tStartY_L + textLineHeightLogical) <= uBY) targetCtx.fillText(truncateText('好物:' + imgData.food, 10), tStartX_L, tStartY_L); }
            }

            if (i < imagesInThisRow - 1) {
              const mTU = dynamicMargins[i];
              if (isNaN(mTU)) currentX_L += logicalImageMaxSize + baseLogicalImageMargin;
              else currentX_L += logicalImageMaxSize + mTU;
            } else {
              // console.log(`      行 ${r} の最後の画像 (${currentImageDrawIndex})`); // デバッグ用
            }
          }

          currentY_logical += logicalImageMaxSize + textHeightPerImage + baseLogicalImageMargin;
        }
      }

      function drawImageCollectionForSave(targetContext, unit) {
        targetContext.save();
        targetContext.translate(unit.x, unit.y);
        if (unit.borderVisible) {
          targetContext.strokeStyle = '#4caf50'; targetContext.lineWidth = 2;
          targetContext.fillStyle = 'rgba(240, 240, 240, 0.8)';
          drawRoundedRect(targetContext, 0, 0, unit.width, unit.height, 8);
          targetContext.fill(); targetContext.stroke();
        }
        drawImagesInCollectionUnit(targetContext, unit, 1, unit.layoutSettings);
        targetContext.restore();
      }
      function getItemDisplayName(item) {
        if (!item) return 'アイテム';
        if (item.type === 'unit') return item.slots.birth?.name || item.slots.qr1?.name || item.slots.qr2?.name || 'ユニット';
        if (item.type === 'group') return item.name || 'グループ';
        if (item.type === 'text') return truncateText(item.text, 10) || 'テキスト';
        if (item.type === 'image-collection') return item.name || `画像集合 (${item.images?.length || 0}枚)`;
        return 'アイテム';
      }

      function openImageCollectionEditModal(unit) {
        editingCollectionUnit = unit;
        collectionEditModalTitle.textContent = `画像集合編集: ${truncateText(getItemDisplayName(unit), 20)}`;
        collectionEditNameInput.value = unit.name || '';
        collectionEditBorderCheckbox.checked = unit.borderVisible !== undefined ? unit.borderVisible : true;
        collectionEditImageCount.textContent = unit.images?.length || 0;
        if (!unit.layoutSettings) {
          unit.layoutSettings = {
            maxSize: COLLECTION_IMAGE_MAX_SIZE, margin: COLLECTION_IMAGE_MARGIN, padding: COLLECTION_PADDING,
            textGap: minTextGapLogical, perRow: COLLECTION_IMAGES_PER_ROW, fontSize: textFontSizeLogical
          };
        }
        document.getElementById('collection-edit-max-size').value = unit.layoutSettings.maxSize;
        document.getElementById('collection-edit-margin').value = unit.layoutSettings.margin;
        document.getElementById('collection-edit-padding').value = unit.layoutSettings.padding;
        document.getElementById('collection-edit-text-gap').value = unit.layoutSettings.textGap;
        document.getElementById('collection-edit-per-row').value = unit.layoutSettings.perRow;
        document.getElementById('collection-edit-font-size').value = unit.layoutSettings.fontSize;
        const layoutDetails = document.getElementById('collection-layout-settings');
        if (layoutDetails) layoutDetails.open = false;
        collectionEditImageList.innerHTML = '';
        if (unit.images && unit.images.length > 0) {
          unit.images.forEach((imgData, index) => {
            const listItem = document.createElement('li');
            listItem.dataset.originalIndex = index; listItem.draggable = true;
            addDragDropListeners(listItem);
            const imgElement = document.createElement('img'); imgElement.id = `collection-edit-img-${index}`;
            imgElement.src = imgData.imgDataUrl || 'https://placehold.co/40x40/eee/ccc?text=N/A';
            imgElement.alt = imgData.fileName || '画像プレビュー'; listItem.appendChild(imgElement);
            const detailsDiv = document.createElement('div'); detailsDiv.className = 'image-details';
            const fileNameP = document.createElement('p'); fileNameP.textContent = `ファイル: ${truncateText(imgData.fileName || '不明', 25)}`; detailsDiv.appendChild(fileNameP);
            const nameGroup = document.createElement('div'); nameGroup.className = 'detail-form-group';
            const nameLabel = document.createElement('label'); nameLabel.textContent = '名前:';
            const nameInput = document.createElement('input'); nameInput.type = 'text'; nameInput.value = imgData.name || ''; nameInput.maxLength = 10; nameInput.placeholder = '名前(任意)'; nameInput.dataset.field = 'name';
            nameGroup.appendChild(nameLabel); nameGroup.appendChild(nameInput); detailsDiv.appendChild(nameGroup);
            const foodGroup = document.createElement('div'); foodGroup.className = 'detail-form-group';
            const foodLabel = document.createElement('label'); foodLabel.textContent = '好物:';
            const foodSelect = document.createElement('select'); foodSelect.dataset.field = 'food';
            ['未選択', 'いちご', 'にがうり', 'とうがらし', 'バナナ', 'レモン', 'ぶどう', 'かき'].forEach(food => { const opt = document.createElement('option'); opt.value = food; opt.textContent = food === '未選択' ? '選択(任意)' : food; foodSelect.appendChild(opt); });
            foodSelect.value = imgData.food || '未選択';
            foodGroup.appendChild(foodLabel); foodGroup.appendChild(foodSelect); detailsDiv.appendChild(foodGroup);
            listItem.appendChild(detailsDiv);
            const editImageBtn = document.createElement('button'); editImageBtn.textContent = '編集';
            editImageBtn.title = 'この画像を編集'; editImageBtn.style.cssText = 'font-size:0.75em;padding:2px 6px;margin-left:5px;';
            editImageBtn.onclick = () => {
              currentImageSlotKeyForEditing = null; currentEditingUnitContext = 'collection-edit-modal'; editingCollectionImageIndex = index;
              const urlToEdit = imgData.originalDataUrl || imgData.imgDataUrl;
              if (urlToEdit) {
                imageToCrop.src = urlToEdit; openModal(cropperModal); if (cropper) cropper.destroy();
                aspectRatioSelect.value = "NaN";
                cropper = new Cropper(imageToCrop, { aspectRatio: NaN, viewMode: 1, background: false, zoomable: true, movable: true, cropBoxResizable: true, dragMode: 'move' });
                currentCropFinalizeCallback = (croppedDataUrl) => {
                  const targetImageIndex = editingCollectionImageIndex;
                  if (editingCollectionUnit && editingCollectionUnit.images[targetImageIndex]) {
                    const targetImgData = editingCollectionUnit.images[targetImageIndex]; const img = new Image();
                    img.onload = () => {
                      targetImgData.img = img; targetImgData.imgDataUrl = croppedDataUrl;
                      if (!targetImgData.originalDataUrl) targetImgData.originalDataUrl = urlToEdit;
                      const previewInModal = document.getElementById(`collection-edit-img-${targetImageIndex}`);
                      if (previewInModal) previewInModal.src = croppedDataUrl;
                      closeCropperModal();
                    };
                    img.onerror = () => { console.error("編集後画像の読み込みエラー:", targetImageIndex); closeCropperModal(); };
                    img.src = croppedDataUrl;
                  } else { console.error("編集対象の画像データが見つかりません:", targetImageIndex); closeCropperModal(); }
                };
              } else { alert('編集可能な画像データが見つかりません。'); }
            }; listItem.appendChild(editImageBtn);
            const deleteBtn = document.createElement('button'); deleteBtn.innerHTML = '&times;'; deleteBtn.title = 'この画像を削除リストに追加'; deleteBtn.className = 'delete-image-btn';
            deleteBtn.onclick = () => {
              if (listItem.dataset.deleted === 'true') {
                if (confirm(`画像「${imgData.fileName || '選択画像'}」の削除を取り消しますか？`)) {
                  listItem.style.opacity = '1'; listItem.style.textDecoration = 'none'; listItem.dataset.deleted = 'false';
                  const currentCount = parseInt(collectionEditImageCount.textContent, 10) + 1;
                  collectionEditImageCount.textContent = currentCount;
                }
              } else {
                if (confirm(`画像「${imgData.fileName || '選択画像'}」を削除リストに追加しますか？ (適用ボタンで削除)`)) {
                  listItem.style.opacity = '0.5'; listItem.style.textDecoration = 'line-through'; listItem.dataset.deleted = 'true';
                  const currentCount = parseInt(collectionEditImageCount.textContent, 10) - 1;
                  collectionEditImageCount.textContent = Math.max(0, currentCount);
                }
              }
            }; listItem.appendChild(deleteBtn);
            collectionEditImageList.appendChild(listItem);
          });
        } else { collectionEditImageList.innerHTML = '<li>画像がありません。</li>'; }
        openModal(collectionEditModal);
      }

      function addDragDropListeners(item) { item.addEventListener('dragstart', handleDragStart); item.addEventListener('dragover', handleDragOver); item.addEventListener('dragenter', handleDragEnter); item.addEventListener('dragleave', handleDragLeave); item.addEventListener('drop', handleDrop); item.addEventListener('dragend', handleDragEnd); }
      function handleDragStart(e) { draggedItem = this; e.dataTransfer.effectAllowed = 'move'; setTimeout(() => this.classList.add('dragging'), 0); }
      function handleDragOver(e) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; return false; }
      function handleDragEnter(e) { if (draggedItem !== this) this.style.borderTop = '2px dashed blue'; }
      function handleDragLeave(e) { this.style.borderTop = ''; }
      function handleDrop(e) { e.stopPropagation(); if (draggedItem !== this) { const list = collectionEditImageList; const items = Array.from(list.children); const dragIdx = items.indexOf(draggedItem); const dropIdx = items.indexOf(this); if (dragIdx < dropIdx) list.insertBefore(draggedItem, this.nextSibling); else list.insertBefore(draggedItem, this); } this.style.borderTop = ''; return false; }
      function handleDragEnd(e) { collectionEditImageList.querySelectorAll('li').forEach(item => { item.classList.remove('dragging'); item.style.borderTop = ''; }); draggedItem = null; }

      function getResizeCursor(handle) {
        switch (handle) {
          case 'bottom-right': case 'top-left': return 'nwse-resize';
          case 'bottom-left': case 'top-right': return 'nesw-resize';
          case 'right': case 'left': return 'ew-resize';
          case 'bottom': case 'top': return 'ns-resize';
          default: return 'grab'; // デフォルトは掴むカーソル
        }
      }
      function updateFillOptionVisibility() {
        if (drawingFillGroup && drawingShapeSelect) {
          const shape = drawingShapeSelect.value;
          if (shape === 'rectangle' || shape === 'circle') {
            drawingFillGroup.style.display = 'flex';
          } else {
            drawingFillGroup.style.display = 'none';
          }
        }
      }

      function getIntersectionPointWithUnitBoundary(unit, pointP) {
        const unitCenterX = unit.x + unit.width / 2;
        const unitCenterY = unit.y + unit.height / 2;

        // ユニットの中心から点Pへのベクトル
        const dx = pointP.x - unitCenterX;
        const dy = pointP.y - unitCenterY;

        if (dx === 0 && dy === 0) {
          return { x: unitCenterX, y: unitCenterY };
        }

        let t = Infinity;
        let intersectionX = null, intersectionY = null;

        // 上辺との交差チェック (y = unit.y)
        if (dy !== 0) {
          const tEdge = (unit.y - unitCenterY) / dy;
          if (tEdge > 0) {
            const xEdge = unitCenterX + tEdge * dx;
            if (xEdge >= unit.x && xEdge <= unit.x + unit.width) {
              if (tEdge < t) {
                t = tEdge;
                intersectionX = xEdge;
                intersectionY = unit.y;
              }
            }
          }
        }

        // 下辺との交差チェック (y = unit.y + unit.height)
        if (dy !== 0) {
          const tEdge = (unit.y + unit.height - unitCenterY) / dy;
          if (tEdge > 0) {
            const xEdge = unitCenterX + tEdge * dx;
            if (xEdge >= unit.x && xEdge <= unit.x + unit.width) {
              if (tEdge < t) {
                t = tEdge;
                intersectionX = xEdge;
                intersectionY = unit.y + unit.height;
              }
            }
          }
        }

        // 左辺との交差チェック (x = unit.x)
        if (dx !== 0) {
          const tEdge = (unit.x - unitCenterX) / dx;
          if (tEdge > 0) {
            const yEdge = unitCenterY + tEdge * dy;
            if (yEdge >= unit.y && yEdge <= unit.y + unit.height) {
              if (tEdge < t) {
                t = tEdge;
                intersectionX = unit.x;
                intersectionY = yEdge;
              }
            }
          }
        }

        // 右辺との交差チェック (x = unit.x + unit.width)
        if (dx !== 0) {
          const tEdge = (unit.x + unit.width - unitCenterX) / dx;
          if (tEdge > 0) {
            const yEdge = unitCenterY + tEdge * dy;
            if (yEdge >= unit.y && yEdge <= unit.y + unit.height) {
              if (tEdge < t) {
                t = tEdge;
                intersectionX = unit.x + unit.width;
                intersectionY = yEdge;
              }
            }
          }
        }

        if (intersectionX !== null && intersectionY !== null) {
          return { x: intersectionX, y: intersectionY };
        } else {
          console.warn("getIntersectionPointWithUnitBoundary: No intersection found, returning center.", unit, pointP);
          return { x: unitCenterX, y: unitCenterY };
        }
      }

      function getDirectlyConnectedUnits(unitId) {
        const connectedUnitIds = new Set();
        connections.forEach(conn => {
          if (conn.fromId === unitId && !conn.toId.startsWith('conn-')) {
            const targetUnit = findItemById(conn.toId);
            if (targetUnit && (targetUnit.type === 'unit' || targetUnit.type === 'image-collection')) {
              connectedUnitIds.add(conn.toId);
            }
          }
          else if (conn.toId === unitId && !conn.fromId.startsWith('conn-')) {
            const sourceUnit = findItemById(conn.fromId);
            if (sourceUnit && (sourceUnit.type === 'unit' || sourceUnit.type === 'image-collection')) {
              connectedUnitIds.add(conn.fromId);
            }
          }
        });
        return Array.from(connectedUnitIds).map(id => findItemById(id)).filter(Boolean);
      }

      function drawAllElementsOnContext(targetContext, targetCanvasElement, items, currentDrawingSettings, isTransparentBackground = false) {
        const drawScale = currentDrawingSettings.scale;
        const currentSelectedItem = (targetCanvasElement === canvas) ? items.selectedItem : null;
        const currentConnectFromItem = (targetCanvasElement === canvas) ? items.connectFromItem : null;
        const currentItemsToGroup = (targetCanvasElement === canvas) ? items.itemsToGroup : [];
        const isDrawingModeActive = (targetCanvasElement === canvas) ? items.isDrawing : false;
        const currentDrawingPathForRender = (targetCanvasElement === canvas) ? items.drawnPathsInProgress : [];

        targetContext.save();
        targetContext.clearRect(0, 0, targetCanvasElement.width, targetCanvasElement.height);

        if (!isTransparentBackground) {
          let bgColorToFill = '#fdfdfd';
          if (targetCanvasElement === canvas) {
            bgColorToFill = window.getComputedStyle(canvas).backgroundColor || '#fdfdfd';
          }
          targetContext.fillStyle = bgColorToFill;
          targetContext.fillRect(0, 0, targetCanvasElement.width, targetCanvasElement.height);
        }
        targetContext.translate(currentDrawingSettings.originX, currentDrawingSettings.originY);
        targetContext.scale(drawScale, drawScale);

        // 1. 接続線の描画
        const connectionsToDraw = [...items.connections];
        const drawnTConnectionPairs = new Set();

        // ステップ1: T字接続を優先的に処理して描画し、構成要素となった接続線は描画対象から除く
        items.units.forEach(childUnit => {
          const parentConnections = connectionsToDraw.filter(conn =>
            conn.toId === childUnit.id &&
            !conn.fromId.startsWith('conn-') &&
            findItemById(conn.fromId)
          );

          if (parentConnections.length === 2) {
            const conn1 = parentConnections[0];
            const conn2 = parentConnections[1];
            const parent1 = findItemById(conn1.fromId);
            const parent2 = findItemById(conn2.fromId);

            if (parent1 && parent2 && parent1.id !== parent2.id) {
              targetContext.beginPath();
              const isSelectedT = (currentSelectedItem && (currentSelectedItem.id === conn1.id || currentSelectedItem.id === conn2.id || currentSelectedItem.id === childUnit.id));
              const baseLineWidth = conn1.lineWidth || 10;
              const displayLineWidth = baseLineWidth / drawScale;
              targetContext.strokeStyle = isSelectedT ? '#007bff' : (conn1.color || '#555555');
              targetContext.lineWidth = isSelectedT ? (displayLineWidth + (2 / drawScale)) : displayLineWidth;
              targetContext.setLineDash((conn1.dashArray || []).map(d => d / drawScale));

              const p1Center = { x: parent1.x + parent1.width / 2, y: parent1.y + parent1.height / 2 };
              const p2Center = { x: parent2.x + parent2.width / 2, y: parent2.y + parent2.height / 2 };
              const junctionX = (p1Center.x + p2Center.x) / 2;
              const junctionY = (p1Center.y + p2Center.y) / 2;

              const p1Start = getIntersectionPointWithUnitBoundary(parent1, { x: junctionX, y: junctionY });
              targetContext.moveTo(p1Start.x, p1Start.y);
              targetContext.lineTo(junctionX, junctionY);

              const p2Start = getIntersectionPointWithUnitBoundary(parent2, { x: junctionX, y: junctionY });
              targetContext.moveTo(p2Start.x, p2Start.y);
              targetContext.lineTo(junctionX, junctionY);

              const childEnd = getIntersectionPointWithUnitBoundary(childUnit, { x: junctionX, y: junctionY });
              targetContext.moveTo(junctionX, junctionY);
              targetContext.lineTo(childEnd.x, childEnd.y);

              targetContext.stroke();
              targetContext.setLineDash([]);

              drawnTConnectionPairs.add(conn1.id);
              drawnTConnectionPairs.add(conn2.id);
            }
          }
        });

        // ステップ2: T字の一部として描画されなかった残りの接続を描画
        connectionsToDraw.forEach(conn => {
          if (drawnTConnectionPairs.has(conn.id)) {
            return;
          }

          const fromItem = findItemById(conn.fromId);
          const toItem = findItemById(conn.toId);
          if (!fromItem || !toItem) return;

          targetContext.beginPath();
          const isSelectedConn = currentSelectedItem && currentSelectedItem.id === conn.id;
          const baseLineWidth = conn.lineWidth || 10;
          const displayLineWidth = baseLineWidth / drawScale;
          targetContext.strokeStyle = isSelectedConn ? '#007bff' : (conn.color || '#555555');
          targetContext.lineWidth = isSelectedConn ? (displayLineWidth + (2 / drawScale)) : displayLineWidth;
          targetContext.setLineDash((conn.dashArray || []).map(d => d / drawScale));

          let startPoint, endPoint;

          if (conn.isUnitToLine) {
            const targetLineMidpoint = getLineMidpoint(conn.toId);
            if (targetLineMidpoint) {
              startPoint = getIntersectionPointWithUnitBoundary(fromItem, targetLineMidpoint);
              endPoint = targetLineMidpoint;
            } else return;
          } else if (conn.isLineToUnit) {
            const sourceLineMidpoint = getLineMidpoint(conn.fromId);
            if (sourceLineMidpoint) {
              startPoint = sourceLineMidpoint;
              endPoint = getIntersectionPointWithUnitBoundary(toItem, sourceLineMidpoint);
            } else return;
          } else {
            const fromCenter = { x: fromItem.x + fromItem.width / 2, y: fromItem.y + fromItem.height / 2 };
            const toCenter = { x: toItem.x + toItem.width / 2, y: toItem.y + toItem.height / 2 };
            startPoint = getIntersectionPointWithUnitBoundary(fromItem, toCenter);
            endPoint = getIntersectionPointWithUnitBoundary(toItem, fromCenter);
          }

          if (startPoint && endPoint) {
            targetContext.moveTo(startPoint.x, startPoint.y);
            targetContext.lineTo(endPoint.x, endPoint.y);
            targetContext.stroke();
          }
          targetContext.setLineDash([]);
        });

        // --- ステップ2: T字として描画されなかった接続、および線とユニットの接続を直線で描画 ---
        items.connections.forEach(conn => {
          const fromItem = findItemById(conn.fromId);
          const toItem = findItemById(conn.toId);

          if (!fromItem || !toItem) {
            // console.warn(`Connection ${conn.id} has missing item(s). Skipping.`);
            return;
          }

          targetContext.beginPath();
          const isSelectedConn = currentSelectedItem && currentSelectedItem.id === conn.id && targetCanvasElement === canvas;
          const baseLineWidth = conn.lineWidth || 10; // デフォルトの太さを10に設定
          const displayLineWidth = baseLineWidth / drawScale;

          targetContext.strokeStyle = isSelectedConn ? '#007bff' : (conn.color || '#555555');
          targetContext.lineWidth = isSelectedConn ? (displayLineWidth + (2 / drawScale)) : displayLineWidth;
          targetContext.setLineDash((conn.dashArray || []).map(d => d / drawScale));

          let startPoint, endPoint, junctionPoint = null;
          let isVerticalPartOfT = false;
          let parent1 = null, parent2 = null;
          const connectionsToChild = items.connections.filter(c => c.toId === conn.toId && c.id !== conn.id && !c.fromId.startsWith('conn-'));

          if (connectionsToChild.length === 1 && !conn.fromId.startsWith('conn-')) {
            parent1 = fromItem;
            parent2 = findItemById(connectionsToChild[0].fromId);
            if (parent1 && parent2 && parent1.id !== parent2.id) {
              isVerticalPartOfT = true;
            }
          }


          if (isVerticalPartOfT && parent1 && parent2) {
            const p1Center = { x: parent1.x + parent1.width / 2, y: parent1.y + parent1.height / 2 };
            const p2Center = { x: parent2.x + parent2.width / 2, y: parent2.y + parent2.height / 2 };

            junctionPoint = {
              x: (p1Center.x + p2Center.x) / 2,
              y: (p1Center.y + p2Center.y) / 2
            };

            // 親1からジャンクションへの線
            const p1Start = getIntersectionPointWithUnitBoundary(parent1, junctionPoint);
            targetContext.moveTo(p1Start.x, p1Start.y);
            targetContext.lineTo(junctionPoint.x, junctionPoint.y);

            // 親2からジャンクションへの線
            const p2Start = getIntersectionPointWithUnitBoundary(parent2, junctionPoint);
            targetContext.moveTo(p2Start.x, p2Start.y);
            targetContext.lineTo(junctionPoint.x, junctionPoint.y);

            // ジャンクションから子への線 (toItem)
            startPoint = junctionPoint;
            endPoint = getIntersectionPointWithUnitBoundary(toItem, junctionPoint);
            targetContext.moveTo(startPoint.x, startPoint.y);
            targetContext.lineTo(endPoint.x, endPoint.y);

          } else if (conn.isUnitToLine) {
            const lineToConnectTo = items.connections.find(c => c.id === conn.toId);
            if (!lineToConnectTo) { targetContext.stroke(); targetContext.setLineDash([]); return; }
            const lineMidpoint = getLineMidpoint(lineToConnectTo.id); // getLineMidpoint は既存の関数を想定
            if (!lineMidpoint) { targetContext.stroke(); targetContext.setLineDash([]); return; }
            startPoint = getIntersectionPointWithUnitBoundary(fromItem, lineMidpoint);
            endPoint = lineMidpoint;
            targetContext.moveTo(startPoint.x, startPoint.y);
            targetContext.lineTo(endPoint.x, endPoint.y);
          } else if (conn.isLineToUnit) {
            const lineToConnectFrom = items.connections.find(c => c.id === conn.fromId);
            if (!lineToConnectFrom) { targetContext.stroke(); targetContext.setLineDash([]); return; }
            const lineMidpoint = getLineMidpoint(lineToConnectFrom.id); // getLineMidpoint は既存の関数を想定
            if (!lineMidpoint) { targetContext.stroke(); targetContext.setLineDash([]); return; }
            startPoint = lineMidpoint;
            endPoint = getIntersectionPointWithUnitBoundary(toItem, lineMidpoint);
            targetContext.moveTo(startPoint.x, startPoint.y);
            targetContext.lineTo(endPoint.x, endPoint.y);
          } else {
            // 通常の直線接続
            // ただし、この接続がT字の親からジャンクションへの線の一部として既に描画されたかチェック
            let alreadyDrawnAsTparent = false;
            items.connections.forEach(otherConn => {
              if (otherConn.id === conn.id) return;
              const otherChild = findItemById(otherConn.toId);
              if (!otherChild) return;

              const otherParent1 = findItemById(otherConn.fromId);
              const connectionsToOtherChild = items.connections.filter(c => c.toId === otherConn.toId && c.id !== otherConn.id && !c.fromId.startsWith('conn-'));
              if (connectionsToOtherChild.length === 1 && !otherConn.fromId.startsWith('conn-')) {
                const otherParent2 = findItemById(connectionsToOtherChild[0].fromId);
                if (otherParent1 && otherParent2 && otherParent1.id !== otherParent2.id) {
                  if ((conn.fromId === otherParent1.id && conn.toId === otherChild.id && findItemById(conn.fromId) === otherParent1) ||
                    (conn.fromId === otherParent2.id && conn.toId === otherChild.id && findItemById(conn.fromId) === otherParent2)) {
                    if ((fromItem === otherParent1 && toItem === otherChild) || (fromItem === otherParent2 && toItem === otherChild)) {
                      alreadyDrawnAsTparent = true;
                    }
                  }
                }
              }
            });

            let isPartOfTStructureThatWillBeDrawn = false;
            const childUnit = toItem;
            const directParentConnectionsToChild = items.connections.filter(c =>
              c.toId === childUnit.id &&
              !c.fromId.startsWith('conn-') && // fromがユニット
              c.fromId !== childUnit.id   // 自己参照でない
            );

            if (directParentConnectionsToChild.length === 2) {
              const pA = findItemById(directParentConnectionsToChild[0].fromId);
              const pB = findItemById(directParentConnectionsToChild[1].fromId);
              if (pA && pB && pA.id !== pB.id) { // 2つの異なる親がいる
                // この conn がその2つの親のどちらかから子への接続の場合、T字で描画される
                if ((conn.fromId === pA.id && conn.toId === childUnit.id) || (conn.fromId === pB.id && conn.toId === childUnit.id)) {
                  isPartOfTStructureThatWillBeDrawn = true;
                }
              }
            }


            if (!isPartOfTStructureThatWillBeDrawn) {
              // T字構造として描画されない、または線とユニットの接続でない場合のみ通常の直線接続
              const fromCenter = { x: fromItem.x + fromItem.width / 2, y: fromItem.y + fromItem.height / 2 };
              const toCenter = { x: toItem.x + toItem.width / 2, y: toItem.y + toItem.height / 2 };
              startPoint = getIntersectionPointWithUnitBoundary(fromItem, toCenter);
              endPoint = getIntersectionPointWithUnitBoundary(toItem, fromCenter);
              targetContext.moveTo(startPoint.x, startPoint.y);
              targetContext.lineTo(endPoint.x, endPoint.y);
            }
          }
          targetContext.stroke();
          targetContext.setLineDash([]);
        });
        // 2. 手書き描画 (保存済みパス)
        (items.drawnPaths || []).forEach(pathObj => {
          if (!pathObj || !pathObj.points || pathObj.points.length < 1) return;
          targetContext.strokeStyle = pathObj.color;
          targetContext.lineWidth = pathObj.lineWidth / drawScale;
          targetContext.lineCap = 'round';
          targetContext.lineJoin = 'round';
          if (pathObj.type === 'eraser') {
            const mainCanvasBgColor = (targetCanvasElement === canvas) ?
              (window.getComputedStyle(canvas).backgroundColor || '#fdfdfd') :
              (window.getComputedStyle(document.getElementById('family-tree-canvas')).backgroundColor || '#fdfdfd');
            targetContext.strokeStyle = mainCanvasBgColor;
          }
          targetContext.beginPath();
          if (pathObj.type === 'line' || pathObj.type === 'eraser') {
            targetContext.moveTo(pathObj.points[0][0], pathObj.points[0][1]);
            for (let i = 1; i < pathObj.points.length; i++) {
              targetContext.lineTo(pathObj.points[i][0], pathObj.points[i][1]);
            }
            targetContext.stroke();
          } else if (pathObj.type === 'arrow' && pathObj.points.length >= 2) {
            const points = pathObj.points;
            const endX = points[points.length - 1][0]; const endY = points[points.length - 1][1];
            const prevX = points.length > 1 ? points[points.length - 2][0] : points[0][0];
            const prevY = points.length > 1 ? points[points.length - 2][1] : points[0][1];
            targetContext.moveTo(points[0][0], points[0][1]);
            for (let i = 1; i < points.length; i++) { targetContext.lineTo(points[i][0], points[i][1]); }
            targetContext.stroke();
            drawArrowhead(targetContext, prevX, prevY, endX, endY, pathObj.lineWidth / drawScale);
          } else if (pathObj.type === 'rectangle' && pathObj.points.length >= 2 && pathObj.startX !== undefined) {
            const startX = pathObj.startX; const startY = pathObj.startY;
            const endX = pathObj.points[1][0]; const endY = pathObj.points[1][1];
            const rectX = Math.min(startX, endX); const rectY = Math.min(startY, endY);
            const rectW = Math.abs(startX - endX); const rectH = Math.abs(startY - endY);
            if (pathObj.isFilled) { targetContext.fillStyle = pathObj.color; targetContext.fillRect(rectX, rectY, rectW, rectH); }
            targetContext.strokeRect(rectX, rectY, rectW, rectH);
          } else if (pathObj.type === 'circle' && pathObj.points.length >= 2 && pathObj.startX !== undefined) {
            const startX = pathObj.startX; const startY = pathObj.startY;
            const endX = pathObj.points[1][0]; const endY = pathObj.points[1][1];
            const radiusX = Math.abs(startX - endX) / 2; const radiusY = Math.abs(startY - endY) / 2;
            const centerX = Math.min(startX, endX) + radiusX; const centerY = Math.min(startY, endY) + radiusY;
            targetContext.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
            if (pathObj.isFilled) { targetContext.fillStyle = pathObj.color; targetContext.fill(); }
            targetContext.stroke();
          }
        });

        // 3. 手書き描画 (現在描画中パス - メインキャンバスのみ)
        if (targetCanvasElement === canvas && items.isDrawing && items.drawnPathsInProgress && items.drawnPathsInProgress.length > 0) {
          const pathObj = items.drawnPathsInProgress[0];
          if (pathObj && pathObj.points && pathObj.points.length >= 1) {
            targetContext.strokeStyle = pathObj.color;
            targetContext.lineWidth = pathObj.lineWidth / drawScale;
            targetContext.lineCap = 'round'; targetContext.lineJoin = 'round';
            if (pathObj.type === 'eraser') {
              targetContext.strokeStyle = window.getComputedStyle(canvas).backgroundColor || '#fdfdfd';
            }
            targetContext.beginPath();
            if (pathObj.type === 'line' || pathObj.type === 'eraser') {
              if (pathObj.points.length > 0) {
                targetContext.moveTo(pathObj.points[0][0], pathObj.points[0][1]);
                for (let i = 1; i < pathObj.points.length; i++) {
                  targetContext.lineTo(pathObj.points[i][0], pathObj.points[i][1]);
                }
                targetContext.stroke();
              }
            } else if (pathObj.type === 'arrow' && pathObj.points.length >= 2) {
              const points = pathObj.points;
              const endX = points[points.length - 1][0]; const endY = points[points.length - 1][1];
              const prevX = points.length > 1 ? points[points.length - 2][0] : points[0][0];
              const prevY = points.length > 1 ? points[points.length - 2][1] : points[0][1];
              targetContext.moveTo(points[0][0], points[0][1]);
              for (let i = 1; i < points.length; i++) { targetContext.lineTo(points[i][0], points[i][1]); }
              targetContext.stroke();
              drawArrowhead(targetContext, prevX, prevY, endX, endY, pathObj.lineWidth / drawScale);
            } else if (pathObj.type === 'rectangle' && pathObj.points.length >= 2 && pathObj.startX !== undefined) {
              const startX = pathObj.startX; const startY = pathObj.startY;
              const endX = pathObj.points[1][0]; const endY = pathObj.points[1][1];
              const rectX = Math.min(startX, endX); const rectY = Math.min(startY, endY);
              const rectW = Math.abs(startX - endX); const rectH = Math.abs(startY - endY);
              if (pathObj.isFilled) { targetContext.fillStyle = pathObj.color; targetContext.fillRect(rectX, rectY, rectW, rectH); }
              targetContext.strokeRect(rectX, rectY, rectW, rectH);
            } else if (pathObj.type === 'circle' && pathObj.points.length >= 2 && pathObj.startX !== undefined) {
              const startX = pathObj.startX; const startY = pathObj.startY;
              const endX = pathObj.points[1][0]; const endY = pathObj.points[1][1];
              const radiusX = Math.abs(startX - endX) / 2; const radiusY = Math.abs(startY - endY) / 2;
              const centerX = Math.min(startX, endX) + radiusX; const centerY = Math.min(startY, endY) + radiusY;
              targetContext.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
              if (pathObj.isFilled) { targetContext.fillStyle = pathObj.color; targetContext.fill(); }
              targetContext.stroke();
            }
          }
        }

        // 4. グループの描画
        items.groups.forEach(group => {
          targetContext.save();
          targetContext.translate(group.x, group.y);
          const isSelectedForDisplay = currentSelectedItem && currentSelectedItem.id === group.id && targetCanvasElement === canvas;

          if (group.borderVisible) {
            targetContext.strokeStyle = isSelectedForDisplay ? '#007bff' : '#6f42c1';
            targetContext.lineWidth = (isSelectedForDisplay ? 6 : 4) / drawScale;
            targetContext.fillStyle = 'rgba(111, 66, 193, 0.05)';
            drawRoundedRect(targetContext, 0, 0, group.width, group.height, 15);
            targetContext.fill();
            targetContext.stroke();
          } else if (isSelectedForDisplay) {
            targetContext.strokeStyle = '#007bff';
            targetContext.lineWidth = 6 / drawScale;
            drawRoundedRect(targetContext, 0, 0, group.width, group.height, 15);
            targetContext.stroke();
          }
          if (group.name) {
            targetContext.fillStyle = '#6f42c1';
            targetContext.font = `${14 / drawScale}px ${DEFAULT_FONT}`;
            targetContext.textAlign = 'center';
            targetContext.strokeStyle = 'rgba(255,255,255,0.7)';
            targetContext.lineWidth = 3 / drawScale;
            targetContext.strokeText(truncateText(group.name, 20), group.width / 2, -(5 / drawScale));
            targetContext.fillText(truncateText(group.name, 20), group.width / 2, -(5 / drawScale));
          }
          targetContext.restore();
        });

        // 5. ユニットの描画
        items.units.forEach(unit => {
          targetContext.save();
          targetContext.translate(unit.x, unit.y);

          const isNormallySelected = currentSelectedItem && currentSelectedItem.id === unit.id && targetCanvasElement === canvas;
          const isUnitConnectFrom = currentConnectFromItem && currentConnectFromItem.id === unit.id && targetCanvasElement === canvas;
          const isUnitInGroupSelection = currentItemsToGroup.find(item => item.id === unit.id) && targetCanvasElement === canvas;
          const isUnitUnifyTarget = unit.isTargetSelectedForUnify === true && targetCanvasElement === canvas;
          const isAlignmentBaseForDisplay = alignBaseUnit && alignBaseUnit.id === unit.id && targetCanvasElement === canvas && currentMode && currentMode.startsWith('align');
          const isAlignmentTargetForDisplay = alignTargetUnits.some(target => target.id === unit.id) && targetCanvasElement === canvas && currentMode === 'align-select-targets';

          let currentUnitLineWidth = 2 / drawScale;
          let defaultStrokeColor = (targetCanvasElement === canvas) ?
            (unit.type === 'image-collection' ? '#4caf50' : '#333') :
            '#000000';
          let currentUnitStrokeStyle = defaultStrokeColor;
          let currentUnitFillStyle = unit.type === 'image-collection' ? 'rgba(240, 240, 240, 0.8)' : '#fff';

          if (targetCanvasElement === canvas) {
            if (isUnitUnifyTarget) { currentUnitLineWidth = 5 / drawScale; currentUnitStrokeStyle = '#20c997'; }
            else if (isAlignmentBaseForDisplay) { currentUnitLineWidth = 5 / drawScale; currentUnitStrokeStyle = '#ff69b4'; }
            else if (isAlignmentTargetForDisplay) { currentUnitLineWidth = 4 / drawScale; currentUnitStrokeStyle = '#ffa500'; }
            else if (isNormallySelected) { currentUnitLineWidth = 4 / drawScale; currentUnitStrokeStyle = '#007bff'; }
            else if (isUnitConnectFrom) { currentUnitLineWidth = 4 / drawScale; currentUnitStrokeStyle = '#ffc107'; }
            else if (isUnitInGroupSelection) { currentUnitLineWidth = 4 / drawScale; currentUnitStrokeStyle = '#28a745'; }
          }

          if (unit.borderVisible) {
            targetContext.lineWidth = currentUnitLineWidth;
            targetContext.strokeStyle = currentUnitStrokeStyle;
            targetContext.fillStyle = currentUnitFillStyle;
            drawRoundedRect(targetContext, 0, 0, unit.width, unit.height, 8);
            targetContext.fill();
            targetContext.stroke();
          } else if (targetCanvasElement === canvas && (isUnitUnifyTarget || isAlignmentBaseForDisplay || isAlignmentTargetForDisplay || isNormallySelected || isUnitConnectFrom || isUnitInGroupSelection)) {
            targetContext.lineWidth = currentUnitLineWidth;
            targetContext.strokeStyle = currentUnitStrokeStyle;
            drawRoundedRect(targetContext, 0, 0, unit.width, unit.height, 8);
            targetContext.stroke();
          }


          if (unit.type === 'image-collection') {
            drawImagesInCollectionUnit(targetContext, unit, drawScale, unit.layoutSettings);
            if (unit.images?.length === 0) {
              targetContext.fillStyle = '#000000'; // 保存時も黒
              targetContext.font = `${14 / drawScale}px ${DEFAULT_FONT}`;
              targetContext.textAlign = 'center'; targetContext.textBaseline = 'middle';
              targetContext.fillText(`画像なし`, unit.width / 2, unit.height / 2);
            }
          } else {
            const cSP = SLOT_PADDING_BASE; const cIP = UNIT_INTERNAL_PADDING_BASE;
            const fS_logical = 11 * BASE_SCALE_FACTOR;
            const fS_display = fS_logical / drawScale; // 描画時のフォントサイズ
            const tLH_logical = SLOT_TEXT_LINE_HEIGHT_BASE * TEXT_LINE_HEIGHT_MULTIPLIER;
            const tLH_display = tLH_logical / drawScale; // 描画時の行の高さ
            const bIH = SLOT_IMAGE_HEIGHT_BASE; const qIMSH = SLOT_QR_IMAGE_SIZE_BASE;
            let hasImg = Object.values(unit.slots).some(s => s && (s.img || s.imgDataUrl));
            let hasTxtInfo = Object.entries(unit.slots).some(([k, s]) => s && (s.name || (s.food && s.food !== '未選択') || ((k === 'qr1' || k === 'qr2') && s.order)));
            let txtStartY_logical = cSP;
            if (hasImg) txtStartY_logical += Math.max(bIH, qIMSH) + (hasTxtInfo ? IMAGE_TEXT_PADDING : 0);
            else if (hasTxtInfo) txtStartY_logical += cSP / 2;

            const activeSKs = unit.activeSlotKeys || [];
            const imgCnt = activeSKs.length;
            let slW, slStartX = cSP, dispSKs = [];

            if (imgCnt === 1) { slW = SLOT_WIDTH_BASE; slStartX = (unit.width - slW) / 2; if (activeSKs.length > 0) dispSKs.push(activeSKs[0]); }
            else if (imgCnt === 2) {
              slW = SLOT_WIDTH_BASE; const p_order = ['qr1', 'birth', 'qr2']; const srtK = [...activeSKs].sort((a, b) => p_order.indexOf(a) - p_order.indexOf(b));
              if (srtK.length >= 2) { dispSKs.push(srtK[0]); dispSKs.push(srtK[1]); slStartX = (unit.width - (slW * 2 + cIP)) / 2; }
              else if (srtK.length === 1) { dispSKs.push(srtK[0]); slStartX = (unit.width - slW) / 2; }
            } else {
              slW = SLOT_WIDTH_BASE;
              const p_order = ['qr1', 'birth', 'qr2'];
              p_order.forEach(k => {
                if (unit.slots[k] && (unit.slots[k].img || unit.slots[k].imgDataUrl)) {
                  if (!dispSKs.includes(k)) dispSKs.push(k);
                }
              });
              if (dispSKs.length === 0 && hasTxtInfo) {
                p_order.forEach(k => {
                  if (unit.slots[k] && (unit.slots[k].name || (unit.slots[k].food && unit.slots[k].food !== '未選択') || ((k === 'qr1' || k === 'qr2') && unit.slots[k].order))) {
                    if (!dispSKs.includes(k)) dispSKs.push(k);
                  }
                });
              }
              const numSlotsToDraw = dispSKs.length > 0 ? dispSKs.length : (unit.width === UNIT_WIDTH_THREE_SLOTS ? 3 : 1);
              const totalInternalPaddingForDisplay = numSlotsToDraw > 1 ? cIP * (numSlotsToDraw - 1) : 0;
              const totalPaddingForDisplay = cSP * 2 + totalInternalPaddingForDisplay;
              slW = numSlotsToDraw > 0 ? (unit.width - totalPaddingForDisplay) / numSlotsToDraw : SLOT_WIDTH_BASE;
              slStartX = cSP;
              if (numSlotsToDraw === 1 && unit.width > UNIT_WIDTH_ONE_SLOT) {
                slStartX = (unit.width - slW) / 2;
              }
            }


            let curSlX = slStartX; const slOrder = ['qr1', 'birth', 'qr2']; let slDrawn = 0;

            for (const slK of slOrder) {
              const shouldDisplayThisSlot = dispSKs.includes(slK);
              if (!shouldDisplayThisSlot && imgCnt > 0) continue;
              if (!shouldDisplayThisSlot && imgCnt === 0 && !hasTxtInfo) continue;

              const slData = unit.slots[slK];
              if (!slData && !dispSKs.includes(slK)) continue;
              if (slData && !slData.img && !slData.imgDataUrl && !slData.name && !(slData.food && slData.food !== '未選択') && !slData.order && !dispSKs.includes(slK)) continue;


              targetContext.save();
              targetContext.translate(curSlX, cSP);
              const sAH = (slK === 'birth') ? bIH : qIMSH;
              const sAW = slW;

              const imgToDraw = slData?.img;
              if (imgToDraw && imgToDraw.complete && imgToDraw.naturalWidth > 0) {
                try {
                  const ar = imgToDraw.naturalWidth / imgToDraw.naturalHeight; let dW, dH;
                  if (slK === 'birth') {
                    dH = sAH; dW = dH * ar; if (dW > sAW) { dW = sAW; dH = dW / ar; }
                  } else { if (sAW / ar <= sAH) { dW = sAW; dH = dW / ar; } else { dH = sAH; dW = dH * ar; } }
                  dW = Math.min(dW, sAW); dH = Math.min(dH, sAH);
                  const iX = (sAW - dW) / 2; const iY = (sAH - dH) / 2;
                  targetContext.drawImage(imgToDraw, iX, iY, dW, dH);
                } catch (e) { console.error("Error drawing unit slot image:", e); }
              }

              if (slData && (slData.name || (slData.food && slData.food !== '未選択') || slData.order)) {
                targetContext.font = `${fS_display}px ${DEFAULT_FONT}`;
                targetContext.textAlign = 'center';
                let currentTextLineY_InSlot_display = txtStartY_logical;

                const textShadowStyle = 'rgba(255,255,255,0.8)';
                const textShadowWidth = 3 / drawScale;

                const drawTextLineInSlot_ForRender = (text, yOffsetLogical, isFoodItem = false, foodColor = '#ccc') => {
                  const actualYInSlotLocal_display = yOffsetLogical - cSP;
                  targetContext.strokeStyle = textShadowStyle;
                  targetContext.lineWidth = textShadowWidth;
                  if (isFoodItem) {
                    const textMetrics = targetContext.measureText(text);
                    const textActualWidth_display = textMetrics.width;
                    const circleRadius_display = (fS_logical / 2.8) / drawScale; // 円の半径 (表示ピクセル)
                    const circleX_display = (sAW / 2) - (textActualWidth_display / 2) - circleRadius_display - (2 / drawScale);
                    const textRenderX_display = sAW / 2;
                    targetContext.beginPath();
                    targetContext.arc(circleX_display, actualYInSlotLocal_display - (fS_display / 2) + (circleRadius_display / 2), circleRadius_display, 0, 2 * Math.PI);
                    targetContext.fillStyle = foodColor;
                    targetContext.fill();
                    targetContext.strokeText(text, textRenderX_display, actualYInSlotLocal_display, sAW - circleRadius_display * 2 - (4 / drawScale));
                    targetContext.fillStyle = '#000000'; // 文字色は黒
                    targetContext.fillText(text, textRenderX_display, actualYInSlotLocal_display, sAW - circleRadius_display * 2 - (4 / drawScale));
                  } else {
                    targetContext.strokeText(text, sAW / 2, actualYInSlotLocal_display, sAW);
                    targetContext.fillStyle = '#000000'; // 文字色は黒
                    targetContext.fillText(text, sAW / 2, actualYInSlotLocal_display, sAW);
                  }
                };
                if (slData.name) { drawTextLineInSlot_ForRender(truncateText(slData.name, 12), currentTextLineY_InSlot_display); currentTextLineY_InSlot_display += tLH_logical; }
                if (slData.food && slData.food !== '未選択') { const foodColorForDisplay = cropColors[slData.food] || '#888'; drawTextLineInSlot_ForRender(truncateText('好物:' + slData.food, 15), currentTextLineY_InSlot_display, true, foodColorForDisplay); currentTextLineY_InSlot_display += tLH_logical; }
                if (slData.order && (slK === 'qr1' || slK === 'qr2')) { drawTextLineInSlot_ForRender(slData.order, currentTextLineY_InSlot_display); }
              }
              targetContext.restore();
              slDrawn++;
              if (slDrawn < (dispSKs.length > 0 ? dispSKs.length : 1)) {
                curSlX += slW + cIP;
              }
            }
          }
          targetContext.restore();
        });

        // 6. テキストアイテムの描画
        items.textItems.forEach(textItem => {
          targetContext.save();
          targetContext.translate(textItem.x + textItem.width / 2, textItem.y + textItem.height / 2);
          if (textItem.rotation) targetContext.rotate(textItem.rotation * Math.PI / 180);
          const dX = -textItem.width / 2, dY = -textItem.height / 2;

          const isSelectedForTextDisplay = currentSelectedItem && currentSelectedItem.id === textItem.id && targetCanvasElement === canvas;

          targetContext.fillStyle = textItem.backgroundColor;
          drawRoundedRect(targetContext, dX, dY, textItem.width, textItem.height, 5);
          targetContext.fill();

          if (textItem.borderVisible) {
            targetContext.lineWidth = (isSelectedForTextDisplay ? 4 : 2) / drawScale;
            targetContext.strokeStyle = isSelectedForTextDisplay ? '#007bff' : '#555';
            drawRoundedRect(targetContext, dX, dY, textItem.width, textItem.height, 5);
            targetContext.stroke();
          } else if (isSelectedForTextDisplay) {
            targetContext.lineWidth = 4 / drawScale;
            targetContext.strokeStyle = '#007bff';
            drawRoundedRect(targetContext, dX, dY, textItem.width, textItem.height, 5);
            targetContext.stroke();
          }
          targetContext.fillStyle = textItem.color;
          targetContext.font = `${textItem.fontSize / drawScale}px ${textItem.font || DEFAULT_FONT}`;
          targetContext.textAlign = 'left';
          targetContext.textBaseline = 'top';
          const textPaddingForRender_logical = TEXT_ITEM_PADDING;
          const contentMaxWidth_logical = textItem.width - (textPaddingForRender_logical * 2);

          if (contentMaxWidth_logical > 0) {
            const measured = wrapTextAndMeasure(textItem.text, contentMaxWidth_logical, textItem.fontSize, textItem.font || DEFAULT_FONT, TEXT_LINE_HEIGHT_MULTIPLIER);
            const linesToDraw = measured.linesArray;
            const lineHeightForRender_display = (textItem.fontSize * TEXT_LINE_HEIGHT_MULTIPLIER) / drawScale;
            let currentY_render_display = dY + textPaddingForRender_logical;

            for (let i = 0; i < linesToDraw.length; i++) {
              const lineText = linesToDraw[i];
              // 描画領域チェックも論理サイズで行う
              if (currentY_render_display + lineHeightForRender_display > dY + textItem.height - textPaddingForRender_logical && i < linesToDraw.length) {
                if (currentY_render_display + (textItem.fontSize / drawScale) <= dY + textItem.height - textPaddingForRender_logical) {
                  let visiblePortion = '';
                  for (let charIdx = 0; charIdx < lineText.length; charIdx++) {
                    const testPortion = visiblePortion + lineText[charIdx];
                    // measureText は現在のコンテキストのフォント設定で行われる
                    if (targetContext.measureText(testPortion + "...").width > contentMaxWidth_logical) break;
                    visiblePortion = testPortion;
                  }
                  targetContext.fillText(visiblePortion + "...", dX + textPaddingForRender_logical, currentY_render_display, contentMaxWidth_logical);
                }
                break;
              }
              if (currentY_render_display + (textItem.fontSize / drawScale) <= dY + textItem.height - textPaddingForRender_logical) {
                targetContext.fillText(lineText, dX + textPaddingForRender_logical, currentY_render_display, contentMaxWidth_logical);
              }
              currentY_render_display += lineHeightForRender_display;
            }
          }
          targetContext.restore();
        });
        targetContext.restore();
      }
      function saveDrawingState() {
        drawnPathsHistory = drawnPathsHistory.slice(0, drawnPathsHistoryIndex + 1);
        drawnPathsHistory.push(JSON.parse(JSON.stringify(drawnPaths)));
        drawnPathsHistoryIndex++;
        updateDrawingUndoRedoButtons();
      }

      function undoDrawing() {
        if (drawnPathsHistoryIndex <= 0) return;

        drawnPathsHistoryIndex--;
        drawnPaths = JSON.parse(JSON.stringify(drawnPathsHistory[drawnPathsHistoryIndex]));
        drawCanvas();
        updateDrawingUndoRedoButtons();
      }

      function redoDrawing() {
        if (drawnPathsHistoryIndex >= drawnPathsHistory.length - 1) return;

        drawnPathsHistoryIndex++;
        drawnPaths = JSON.parse(JSON.stringify(drawnPathsHistory[drawnPathsHistoryIndex]));
        drawCanvas();
        updateDrawingUndoRedoButtons();
      }

      function updateDrawingUndoRedoButtons() {
        if (drawingUndoButton) {
          drawingUndoButton.disabled = drawnPathsHistoryIndex <= 0;
        }
        if (drawingRedoButton) {
          drawingRedoButton.disabled = drawnPathsHistoryIndex >= drawnPathsHistory.length - 1;
        }
      }

      function resetDrawingHistory() {
        drawnPathsHistory = [JSON.parse(JSON.stringify(drawnPaths))];
        drawnPathsHistoryIndex = 0;
        updateDrawingUndoRedoButtons();
      }

      function performAlignment(alignType) {
        if (!alignBaseUnit || alignTargetUnits.length === 0) {
          alert("基準ユニットまたは対象ユニットが選択されていません。");
          closeModal(alignOptionsModal);
          toggleMode(null);
          return;
        }

        let changesMade = false;
        alignTargetUnits.forEach(targetUnit => {
          if (targetUnit.id === alignBaseUnit.id) return;

          if (alignType === 'horizontal') {
            if (targetUnit.y !== alignBaseUnit.y) {
              targetUnit.y = alignBaseUnit.y;
              changesMade = true;
            }
          } else if (alignType === 'vertical') {
            if (targetUnit.x !== alignBaseUnit.x) {
              targetUnit.x = alignBaseUnit.x;
              changesMade = true;
            }
          }
        });

        if (changesMade) {
          const message = alignType === 'horizontal' ? '水平方向に整列しました。' : '垂直方向に整列しました。';
          showStatusBar(message, alignButton);
          saveState();
          drawCanvas();
        } else {
          showStatusBar('ユニットは既に整列されています。変更はありませんでした。', alignButton);
        }

        closeModal(alignOptionsModal);
        toggleMode(null);
      }

      function initializeTemplateSelector() {
        if (!templateSelect) return;
        templateSelect.innerHTML = '<option value="">選択してください</option>';
        FAMILY_TREE_TEMPLATES.forEach(template => {
          const option = document.createElement('option');
          option.value = template.id;
          option.textContent = template.name;
          templateSelect.appendChild(option);
        });
      }

      function updateTemplateUI() {
        if (!templateSelect || !templateImageUpload || !templateImageInfo || !addFromTemplateButton || !templateLayoutPreviewArea) return;

        const selectedTemplateId = templateSelect.value;
        selectedTemplate = FAMILY_TREE_TEMPLATES.find(t => t.id === selectedTemplateId) || null;

        if (selectedTemplate) {
          templateImageUpload.disabled = false;
          templateImageInfo.textContent = `画像 ${templateUploadedImages.length} / ${selectedTemplate.maxImages} 枚選択中。`;
          if (templateUploadedImages.length === selectedTemplate.maxImages) {
            addFromTemplateButton.disabled = false;
            templateImageInfo.textContent += ' (必要枚数に達しました)';
          } else if (templateUploadedImages.length > selectedTemplate.maxImages) {
            addFromTemplateButton.disabled = true;
            templateImageInfo.textContent += ` (枚数超過: ${templateUploadedImages.length - selectedTemplate.maxImages}枚削除してください)`;
            templateImageInfo.style.color = 'red';
          } else {
            addFromTemplateButton.disabled = true;
            templateImageInfo.style.color = '#6c757d';
          }
          renderTemplatePreview(selectedTemplate);
        } else {
          templateImageUpload.disabled = true;
          templateImageInfo.textContent = 'テンプレートを選択すると、必要な画像枚数が表示されます。';
          addFromTemplateButton.disabled = true;
          templateUploadedImages = [];
          if (templateImagePreviews) templateImagePreviews.innerHTML = '';
          templateImageInfo.style.color = '#6c757d';
          templateLayoutPreviewArea.style.display = 'none';
          templateLayoutPreviewArea.innerHTML = '';
        }
      }

      function adjustLayoutHeight() {
        if (!container || !topArea || !bottomControls) {
          return;
        }
        const windowHeight = window.innerHeight;
        container.style.height = `${windowHeight}px`;

        const currentLeftPanel = document.getElementById('left-panel');
        const currentLeftPanelToggleButton = document.getElementById('left-panel-toggle-button');
        const isSmallScreen = window.innerWidth <= 480;

        if (currentLeftPanel && currentLeftPanelToggleButton) {
          if (!currentLeftPanel.classList.contains('collapsed')) {
            if (!isSmallScreen) {
              currentLeftPanelToggleButton.style.left = `${currentLeftPanel.offsetWidth}px`;
            } else {
              currentLeftPanelToggleButton.style.left = '0px';
            }
          } else { // パネルが閉じている時
            // .panel-is-closed のCSSで制御されるので、JSでの明示的な変更は不要な場合が多い
            // currentLeftPanelToggleButton.style.left = '0px';
          }
        }
      }

      function renderTemplatePreview(template) {
        if (!templateLayoutPreviewArea || !template || !template.layout || !template.layout.units) {
          if (templateLayoutPreviewArea) templateLayoutPreviewArea.style.display = 'none';
          return;
        }

        templateLayoutPreviewArea.innerHTML = ''; // 既存のプレビューをクリア
        templateLayoutPreviewArea.style.display = 'block';

        const units = template.layout.units;
        const connections = template.layout.connections || [];

        const previewWidth = templateLayoutPreviewArea.clientWidth;
        const previewHeight = templateLayoutPreviewArea.clientHeight;

        if (previewWidth === 0 || previewHeight === 0) {
          console.warn("Template preview area has no dimensions. Skipping render.");
          templateLayoutPreviewArea.style.display = 'none';
          return;
        }

        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        units.forEach(u => {
          minX = Math.min(minX, u.xOffset);
          maxX = Math.max(maxX, u.xOffset);
          minY = Math.min(minY, u.yOffset);
          maxY = Math.max(maxY, u.yOffset);
        });

        const rangeX = (maxX - minX === 0) ? 1 : maxX - minX;
        const rangeY = (maxY - minY === 0) ? 1 : maxY - minY;

        const padding = 20;
        const unitSize = 30;

        const scaleX = (previewWidth - padding * 2 - unitSize) / Math.max(1, rangeX);
        const scaleY = (previewHeight - padding * 2 - unitSize) / Math.max(1, rangeY);
        const scale = Math.min(scaleX, scaleY, 50);

        const offsetX = padding + (previewWidth - padding * 2 - (rangeX * scale + unitSize)) / 2 - (minX * scale);
        const offsetY = padding + (previewHeight - padding * 2 - (rangeY * scale + unitSize)) / 2 - (minY * scale);

        const unitElements = {};

        units.forEach(unitDef => {
          const unitDiv = document.createElement('div');
          unitDiv.style.position = 'absolute';
          unitDiv.style.width = `${unitSize}px`;
          unitDiv.style.height = `${unitSize}px`;
          unitDiv.style.backgroundColor = '#a9d1ff';
          unitDiv.style.border = '1px solid #4a90e2';
          unitDiv.style.borderRadius = '3px';
          unitDiv.style.display = 'flex';
          unitDiv.style.alignItems = 'center';
          unitDiv.style.justifyContent = 'center';
          unitDiv.style.fontSize = '10px';
          unitDiv.style.color = '#003366';
          unitDiv.style.overflow = 'hidden';
          unitDiv.style.boxSizing = 'border-box';

          const x = offsetX + unitDef.xOffset * scale;
          const y = offsetY + unitDef.yOffset * scale;
          unitDiv.style.left = `${x}px`;
          unitDiv.style.top = `${y}px`;

          let labelText = "";
          if (unitDef.slotMapping) {
            const slotLabels = [];
            const preferredSlots = ['qr1', 'qr2', 'birth'];
            for (const slotType of preferredSlots) {
              if (unitDef.slotMapping.hasOwnProperty(slotType)) {
                slotLabels.push(`${unitDef.slotMapping[slotType] + 1}`);
                break;
              }
            }
            if (slotLabels.length === 0 && Object.keys(unitDef.slotMapping).length > 0) {
              const firstMappedSlot = Object.keys(unitDef.slotMapping)[0];
              slotLabels.push(`${unitDef.slotMapping[firstMappedSlot] + 1}`);
            }
            labelText = slotLabels.join(', ');
          }
          unitDiv.textContent = labelText || "?";

          templateLayoutPreviewArea.appendChild(unitDiv);
          unitElements[unitDef.tempId] = { x: x + unitSize / 2, y: y + unitSize / 2, rawX: x, rawY: y, div: unitDiv };
        });

        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.style.position = 'absolute';
        svg.style.left = '0';
        svg.style.top = '0';
        svg.style.width = '100%';
        svg.style.height = '100%';
        svg.style.pointerEvents = 'none';

        // 接続を描画 (T字接続を考慮)
        connections.forEach(connDef => {
          const toUnit = unitElements[connDef.to]; // 子ユニット
          if (!toUnit) return;

          // 同じ子ユニット(toUnit)に向かう他の接続を探す (兄弟接続)
          const parentConnections = connections.filter(
            c => c.to === connDef.to && c.from !== connDef.from
          );

          const fromUnit = unitElements[connDef.from]; // 現在の接続の親ユニット
          if (!fromUnit) return;

          if (parentConnections.length === 1) {
            const otherParentUnit = unitElements[parentConnections[0].from];
            if (otherParentUnit) {
              const pairKey = [connDef.from, parentConnections[0].from].sort().join('-');
              if (svg.querySelector(`[data-t-junction-pair="${pairKey}"][data-t-junction-child="${connDef.to}"]`)) {
                return;
              }

              // 親1 (fromUnit) と 親2 (otherParentUnit) の中心座標
              const p1x = fromUnit.x;
              const p1y = fromUnit.y;
              const p2x = otherParentUnit.x;
              const p2y = otherParentUnit.y;

              // 子ユニット (toUnit) の中心座標
              const childX = toUnit.x;
              const childY = toUnit.y;
              const midParentX = (p1x + p2x) / 2;
              const midParentY = Math.min(p1y, p2y);

              // 1. 親同士を結ぶ横線
              const hLine = document.createElementNS(svgNS, "line");
              hLine.setAttribute('x1', p1x.toString());
              hLine.setAttribute('y1', midParentY.toString()); // 親のY座標を揃える
              hLine.setAttribute('x2', p2x.toString());
              hLine.setAttribute('y2', midParentY.toString()); // 親のY座標を揃える
              hLine.setAttribute('stroke', '#777');
              hLine.setAttribute('stroke-width', '1');
              hLine.dataset.tJunctionPair = pairKey; // 描画済みマーク
              hLine.dataset.tJunctionChild = connDef.to;
              svg.appendChild(hLine);

              // 2. 横線の中間点から子ユニットへ伸びる縦線
              const vLine = document.createElementNS(svgNS, "line");
              vLine.setAttribute('x1', midParentX.toString());
              vLine.setAttribute('y1', midParentY.toString());
              vLine.setAttribute('x2', childX.toString());
              vLine.setAttribute('y2', toUnit.rawY.toString()); // 子ユニットの上端
              vLine.setAttribute('stroke', '#777');
              vLine.setAttribute('stroke-width', '1');
              vLine.dataset.tJunctionPair = pairKey;
              vLine.dataset.tJunctionChild = connDef.to;
              svg.appendChild(vLine);

              return;
            }
          }

          // 通常のV字接続 (T字でない場合、または親が1つの場合)
          const line = document.createElementNS(svgNS, "line");
          line.setAttribute('x1', fromUnit.x.toString());
          line.setAttribute('y1', fromUnit.y.toString());
          line.setAttribute('x2', toUnit.x.toString());
          line.setAttribute('y2', toUnit.y.toString());
          line.setAttribute('stroke', '#555'); // 少し濃くして区別
          line.setAttribute('stroke-width', '1');
          svg.appendChild(line);
        });
        templateLayoutPreviewArea.appendChild(svg);
      }


      // ========================================
      // 5. イベントリスナー設定 (...addEventListener(...))
      // ========================================
      leftPanelToggleButton.addEventListener('click', () => {
        leftPanel.classList.toggle('collapsed');
        const isSmallScreen = window.innerWidth <= 480; // 例: 480px以下を小さい画面とする

        if (leftPanel.classList.contains('collapsed')) {
          leftPanelToggleButton.innerHTML = '＞';
          leftPanelToggleButton.title = "左パネルを展開";
          leftPanelToggleButton.classList.remove('panel-is-open');
          leftPanelToggleButton.classList.add('panel-is-closed');
          if (!isSmallScreen) {
          }
        } else {
          leftPanelToggleButton.innerHTML = '＜';
          leftPanelToggleButton.title = "左パネルを収納";
          if (!isSmallScreen) {
            leftPanelToggleButton.style.left = `${leftPanel.offsetWidth}px`;
          } else {
            leftPanelToggleButton.style.left = '0px';
          }
          leftPanelToggleButton.classList.add('panel-is-open');
          leftPanelToggleButton.classList.remove('panel-is-closed');
        }
      });

      window.addEventListener('resize', () => {
        const isSmallScreen = window.innerWidth <= 480;
        if (!leftPanel.classList.contains('collapsed')) {
          if (!isSmallScreen) {
            leftPanelToggleButton.style.left = `${leftPanel.offsetWidth}px`;
          } else {
            leftPanelToggleButton.style.left = '0px';
          }
        } else {
          // 閉まっている場合は .panel-is-closed の CSS (left: 0px !important) が効くはず
          // もし効かない場合はここで明示的に left:0px もあり
          // leftPanelToggleButton.style.left = '0px';
        }
        resizeCanvas();
        adjustLayoutHeight();
      });
      undoButton.addEventListener('click', () => {
        if (historyIndex < 0) {
          return;
        }

        const modeBeforeRestore = currentMode;

        historyIndex--;

        if (historyIndex < 0) {
          units = [];
          groups = [];
          textItems = [];
          connections = [];
          drawnPaths = [];
          nextItemId = 0;
          selectedItem = null;
          draggingItem = null;
          resizingItem = null;
          resizeHandle = null;
          connectFromItem = null;
          itemsToGroup = [];
          currentDrawingPath = [];

          if (modeBeforeRestore) {
            toggleMode(null);
          }

          // ズームやパンも初期化する場合 (必要に応じてコメント解除)
          // scale = 1.0;
          // zoomLevel = 0;
          // originX = 0;
          // originY = 0;
          // if (zoomLevelIndicator) zoomLevelIndicator.textContent = zoomLevel;
          resetDrawingHistory();
          drawCanvas();
          updateInfoModal();
        } else {
          restoreState(history[historyIndex]);
        }
        if (modeBeforeRestore === 'draw-path') {
          if (drawModeButton) {
            toggleMode('draw-path', drawModeButton);
          } else {
            currentMode = 'draw-path';
            if (drawingToolsPanel) drawingToolsPanel.style.display = 'block';
            canvas.style.cursor = 'crosshair';
            resetDrawingHistory();
          }
        } else if (currentMode === 'draw-path' && modeBeforeRestore !== 'draw-path') {
        }
        updateUndoRedoButtons();
      });
      redoButton.addEventListener('click', () => {
        if (historyIndex >= history.length - 1) return;

        const modeBeforeRestore = currentMode;

        historyIndex++;
        restoreState(history[historyIndex]);

        if (modeBeforeRestore === 'draw-path') {
          if (drawModeButton) {
            toggleMode('draw-path', drawModeButton);
          } else {
            currentMode = 'draw-path';
            if (drawingToolsPanel) drawingToolsPanel.style.display = 'block';
            canvas.style.cursor = 'crosshair';
            resetDrawingHistory();
          }
        } else if (currentMode === 'draw-path' && modeBeforeRestore !== 'draw-path') {
        }
        updateUndoRedoButtons();
      });
      imageSlots.qr1.orderSakiCheckbox.addEventListener('change', (e) => handleQrOrderChange('qr1', '先', 'left-panel'));
      imageSlots.qr1.orderAtoCheckbox.addEventListener('change', (e) => handleQrOrderChange('qr1', '後', 'left-panel'));
      imageSlots.qr2.orderSakiCheckbox.addEventListener('change', (e) => handleQrOrderChange('qr2', '先', 'left-panel'));
      imageSlots.qr2.orderAtoCheckbox.addEventListener('change', (e) => handleQrOrderChange('qr2', '後', 'left-panel'));
      Object.keys(imageSlots).forEach(slotKey => {
        const slotUI = imageSlots[slotKey];
        if (slotUI.orderSakiCheckbox) {
          slotUI.orderSakiCheckbox.addEventListener('change', (e) => { if (e.target.checked) slotUI.orderAtoCheckbox.checked = false; });
          slotUI.orderAtoCheckbox.addEventListener('change', (e) => { if (e.target.checked) slotUI.orderSakiCheckbox.checked = false; });
        }
        slotUI.uploadInput.addEventListener('change', (event) => {
          const file = event.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (e_reader) => {
              const originalDataUrl = e_reader.target.result;
              slotUI.previewImg.src = originalDataUrl; slotUI.previewImg.style.display = 'block';
              slotUI.editBtn.disabled = false; slotUI.clearBtn.classList.remove('hidden');
              const img = new Image();
              img.onload = () => { imageSlots[slotKey].data = { img: img, fileName: file.name, originalDataUrl: originalDataUrl, imgDataUrl: originalDataUrl }; checkAddUnitButtonState(); };
              img.onerror = () => { console.error("Orig img load err for slot:", slotKey); imageSlots[slotKey].data = null; slotUI.editBtn.disabled = true; slotUI.clearBtn.classList.add('hidden'); checkAddUnitButtonState(); };
              img.src = originalDataUrl;
            };
            reader.readAsDataURL(file);
          } else { slotUI.previewImg.style.display = 'none'; slotUI.previewImg.src = '#'; slotUI.editBtn.disabled = true; slotUI.clearBtn.classList.add('hidden'); imageSlots[slotKey].data = null; checkAddUnitButtonState(); }
        });
        slotUI.editBtn.addEventListener('click', () => {
          if (imageSlots[slotKey].data && imageSlots[slotKey].data.originalDataUrl) {
            currentImageSlotKeyForEditing = slotKey; currentEditingUnitContext = 'left-panel';
            imageToCrop.src = imageSlots[slotKey].data.originalDataUrl; openModal(cropperModal);
            if (cropper) cropper.destroy();
            const aspRatio = (slotKey === 'birth') ? NaN : 1; aspectRatioSelect.value = isNaN(aspRatio) ? "NaN" : aspRatio.toString();
            cropper = new Cropper(imageToCrop, { aspectRatio: aspRatio, viewMode: 1, background: false, zoomable: true, movable: true, cropBoxResizable: true, dragMode: 'move' });
            currentCropFinalizeCallback = (croppedDataUrl) => {
              const targetSlotUI = imageSlots[currentImageSlotKeyForEditing]; const targetSlotData = targetSlotUI.data;
              targetSlotUI.previewImg.src = croppedDataUrl; const img = new Image();
              img.onload = () => { targetSlotData.img = img; targetSlotData.imgDataUrl = croppedDataUrl; checkAddUnitButtonState(); };
              img.onerror = () => { console.error("Cropped img load err for slot:", currentImageSlotKeyForEditing); checkAddUnitButtonState(); };
              img.src = croppedDataUrl; closeCropperModal();
            };
          } else { alert("編集する画像がアップロードされていません。"); }
        });
        slotUI.clearBtn.addEventListener('click', () => { slotUI.previewImg.style.display = 'none'; slotUI.previewImg.src = '#'; slotUI.uploadInput.value = ''; slotUI.editBtn.disabled = true; slotUI.clearBtn.classList.add('hidden'); imageSlots[slotKey].data = null; checkAddUnitButtonState(); });
      });
      imageCollectionUploadInput.addEventListener('change', async (event) => {
        const files = event.target.files;
        if (!files || files.length === 0) { uploadedCollectionImages = []; imageCollectionPreviewsDiv.innerHTML = ''; imageCollectionDetailsDiv.innerHTML = ''; checkAddImageCollectionButtonState(); if (clearImageCollectionButton) clearImageCollectionButton.classList.add('hidden'); return; }
        if (clearImageCollectionButton) clearImageCollectionButton.classList.remove('hidden');
        if (files.length > 20) { alert('画像は最大20枚まで'); imageCollectionUploadInput.value = ''; return; }
        uploadedCollectionImages = []; imageCollectionPreviewsDiv.innerHTML = ''; imageCollectionDetailsDiv.innerHTML = ''; addImageCollectionButton.disabled = true;
        const loadImage = async (file) => { return new Promise((resolve) => { const reader = new FileReader(); reader.onload = (e_r) => { const iDU = e_r.target.result; const img = new Image(); img.onload = () => resolve({ img, imgDataUrl: iDU, originalDataUrl: iDU, fileName: file.name, name: '', food: '未選択' }); img.onerror = () => resolve(null); img.src = iDU; }; reader.onerror = () => resolve(null); reader.readAsDataURL(file); }); };
        try {
          const results = await Promise.all(Array.from(files).map(loadImage));
          uploadedCollectionImages = results.filter(r => r !== null);
          imageCollectionPreviewsDiv.innerHTML = '';
          uploadedCollectionImages.forEach((imgD, idx) => { imgD.originalIndex = idx; const pIE = document.createElement('img'); pIE.src = imgD.imgDataUrl; pIE.title = imgD.fileName; pIE.dataset.index = idx; pIE.onclick = () => selectCollectionImageForDetail(idx); imageCollectionPreviewsDiv.appendChild(pIE); });
          renderImageCollectionDetails(); checkAddImageCollectionButtonState();
        } catch (error) { console.error("Err loading collection imgs:", error); alert("画像読込エラー"); checkAddImageCollectionButtonState(); }
      });
      addImageCollectionButton.addEventListener('click', () => {
        if (addImageCollectionButton.disabled || uploadedCollectionImages.length === 0) return;
        const newCollectionImages = uploadedCollectionImages.map(imgData => ({ img: imgData.img, imgDataUrl: imgData.imgDataUrl, originalDataUrl: imgData.originalDataUrl, fileName: imgData.fileName, name: imgData.name, food: imgData.food }));
        const { width: unitWidth, height: unitHeight } = calculateImageCollectionUnitSize(newCollectionImages); // 初回はデフォルト設定
        const borderVisible = imageCollectionBorderCheckbox.checked;
        const newImageCollectionUnit = {
          id: `item-${nextItemId++}`, type: 'image-collection', images: newCollectionImages,
          x: (-originX + (mainCanvasArea.clientWidth / 2) - (unitWidth / 2)) / scale, y: (-originY + (mainCanvasArea.clientHeight / 2) - (unitHeight / 2)) / scale,
          width: unitWidth, height: unitHeight, isSelected: false, borderVisible: borderVisible, layoutSettings: null
        };
        units.push(newImageCollectionUnit); saveState(); drawCanvas(); updateInfoModal();
        resetImageUploadsAndInputs();
      });
      cropperZoomControls.addEventListener('click', (e) => { if (!cropper) return; const t = e.target; if (t.tagName === 'BUTTON') { if (t.dataset.zoom) cropper.zoomTo(parseFloat(t.dataset.zoom)); else if (t.dataset.zoomIn) cropper.zoom(0.1); else if (t.dataset.zoomOut) cropper.zoom(-0.1); } });
      aspectRatioSelect.addEventListener('change', () => { if (cropper) cropper.setAspectRatio(parseFloat(aspectRatioSelect.value)); });
      cropImageButton.addEventListener('click', () => { if (cropper && currentCropFinalizeCallback) { const cDU = cropper.getCroppedCanvas({ imageSmoothingEnabled: true, imageSmoothingQuality: 'high' }).toDataURL(); currentCropFinalizeCallback(cDU); } });
      cancelCropButton.addEventListener('click', closeCropperModal);
      cropperModalCloseButtonHeader.addEventListener('click', closeCropperModal);
      addUnitButton.addEventListener('click', () => {
        if (addUnitButton.disabled) return;

        const newUnitSlotsData = {};
        const activeSlotKeys = [];
        let imageCount = 0;

        for (const slotKey of Object.keys(imageSlots)) {
          const slotUI = imageSlots[slotKey];
          const slotLoadedData = slotUI.data;
          let orderValue = null;
          if (slotKey === 'qr1' || slotKey === 'qr2') {
            if (slotUI.orderSakiCheckbox && slotUI.orderSakiCheckbox.checked) orderValue = '先';
            else if (slotUI.orderAtoCheckbox && slotUI.orderAtoCheckbox.checked) orderValue = '後';
          }

          newUnitSlotsData[slotKey] = {
            img: null,
            imgDataUrl: null,
            originalDataUrl: null,
            fileName: null,
            name: slotUI.nameInput.value.trim(),
            food: slotUI.foodSelect.value,
            order: orderValue
          };

          if (slotLoadedData && slotLoadedData.img && slotLoadedData.imgDataUrl) {
            imageCount++;
            activeSlotKeys.push(slotKey);
            newUnitSlotsData[slotKey].img = slotLoadedData.img;
            newUnitSlotsData[slotKey].imgDataUrl = slotLoadedData.imgDataUrl; // 画像があれば上書き
            newUnitSlotsData[slotKey].originalDataUrl = slotLoadedData.originalDataUrl;
            newUnitSlotsData[slotKey].fileName = slotLoadedData.fileName;
          }
        }

        if (imageCount === 0) {
          console.warn("addUnitButton was clicked but imageCount is 0. This shouldn't happen if button is properly disabled.");
          // alert("ユニットを作成するには少なくとも1つの画像を選択してください。"); // 必要ならユーザーに通知
          return;
        }

        let unitWidth;
        if (imageCount === 1) unitWidth = UNIT_WIDTH_ONE_SLOT;
        else if (imageCount === 2) unitWidth = UNIT_WIDTH_TWO_SLOTS;
        else unitWidth = UNIT_WIDTH_THREE_SLOTS;

        const unitHeight = calculateUnitHeight(newUnitSlotsData); // newUnitSlotsData は適切に初期化されているはず
        const borderVisible = addUnitBorderVisibleCheckbox.checked;

        const newUnit = {
          id: `item-${nextItemId++}`,
          type: 'unit',
          slots: newUnitSlotsData,
          x: (-originX + (mainCanvasArea.clientWidth / 2) - (unitWidth / 2)) / scale,
          y: (-originY + (mainCanvasArea.clientHeight / 2) - (unitHeight / 2)) / scale,
          width: unitWidth,
          height: unitHeight,
          isSelected: false,
          borderVisible: borderVisible,
          activeSlotKeys: activeSlotKeys,
        };
        units.push(newUnit);
        console.log("Newly created unit with slots:", JSON.parse(JSON.stringify(newUnit.slots))); // 作成直後のスロット確認
        resetImageUploadsAndInputs();
        saveState();
        drawCanvas();
        updateInfoModal();
      });
      addTextContentInput.addEventListener('input', checkAddTextButtonState);
      addTextItemButton.addEventListener('click', () => {
        if (addTextItemButton.disabled) return; const textContent = addTextContentInput.value; if (textContent.trim() === '') return;
        const fontSize = parseInt(addTextSizeInput.value, 10); const font = DEFAULT_FONT; const textPadding = TEXT_ITEM_PADDING; const borderVisible = addTextBorderVisibleCheckbox.checked;
        const measureForWidth = wrapTextAndMeasure(textContent, Infinity, fontSize, font, TEXT_LINE_HEIGHT_MULTIPLIER);
        let calculatedWidth = measureForWidth.calculatedWidth + (textPadding * 2); calculatedWidth = Math.max(MIN_TEXT_ITEM_WIDTH, calculatedWidth);
        const finalMaxWidth = calculatedWidth - (textPadding * 2); const finalMeasured = wrapTextAndMeasure(textContent, finalMaxWidth, fontSize, font, TEXT_LINE_HEIGHT_MULTIPLIER);
        let calculatedHeight = finalMeasured.calculatedHeight + (textPadding * 2); calculatedHeight = Math.max(MIN_TEXT_ITEM_HEIGHT, calculatedHeight);
        const newTextItem = { id: `item-${nextItemId++}`, type: 'text', text: textContent, font: font, color: addTextColorInput.value, backgroundColor: addTextBgColorInput.value, fontSize: fontSize, x: (-originX + (mainCanvasArea.clientWidth / 2) - (calculatedWidth / 2)) / scale, y: (-originY + (mainCanvasArea.clientHeight / 2) - (calculatedHeight / 2)) / scale, width: calculatedWidth, height: calculatedHeight, isSelected: false, borderVisible: borderVisible, rotation: 0 };
        textItems.push(newTextItem); saveState(); drawCanvas();
        addTextContentInput.value = ''; addTextColorInput.value = "#000000"; addTextBgColorInput.value = "#ffffff"; addTextSizeInput.value = "20"; addTextBorderVisibleCheckbox.checked = true; checkAddTextButtonState();
      });
      canvas.addEventListener('mousedown', handleInteractionStart);
      canvas.addEventListener('mousemove', handleInteractionMove);
      canvas.addEventListener('mouseup', handleInteractionEnd);
      canvas.addEventListener('mouseup', handleInteractionEnd);
      canvas.addEventListener('mouseleave', handleInteractionEnd);
      canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleInteractionStart(e); }, { passive: false });
      canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleInteractionMove(e); }, { passive: false });
      canvas.addEventListener('touchend', handleInteractionEnd);
      canvas.addEventListener('touchcancel', handleInteractionEnd);
      connectButton.addEventListener('click', () => toggleMode('connect', connectButton));
      editUnitButton.addEventListener('click', () => toggleMode('edit-item', editUnitButton));
      if (drawModeButton) {
        drawModeButton.addEventListener('click', () => toggleMode('draw-path', drawModeButton));
      }
      groupButton.addEventListener('click', () => {
        if (currentMode === 'grouping') {
          if (itemsToGroup.length >= 2) {
            createGroupFromSelection();
            toggleMode(null);
          } else {
            alert("グループ化するには、少なくとも2つのユニットを選択してください。");
          }
        } else {
          toggleMode('grouping', groupButton);
        }
      });
      saveCanvasButton.addEventListener('click', () => {
        if (units.length === 0 && groups.length === 0 && textItems.length === 0 && drawnPaths.length === 0 && connections.length === 0) {
          alert("保存する内容が家系図にありません。");
          return;
        }
        if (previewResolutionOptions) { // モーダル内のセレクトボックスも初期値に設定
          previewResolutionOptions.value = currentPreviewScaleFactor.toString();
        }
        generateAndSaveImage(currentPreviewScaleFactor, true); // true はプレビューモードを示す
      });
      async function generateAndSaveImage(outputScaleFactor, isForPreviewOnly = false) {
        console.log(`画像生成処理 - スケール: ${outputScaleFactor}, プレビューのみ: ${isForPreviewOnly}`);

        const mainCanvasElement = document.getElementById('family-tree-canvas');
        console.log("保存ボタンがクリックされました！ (プレビュー表示へ)");
        if (!mainCanvasElement) {
          alert("メイン家系図が見つかりません。");
          return;
        }
        const desiredBackgroundColor = '#fdfdfd'; // 画像全体の背景色

        // 1. 家系図コンテンツのバウンディングボックス計算
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        let contentExists = false;
        const itemsToConsiderForBounds = [];
        [...units, ...groups, ...textItems].forEach(item => {
          itemsToConsiderForBounds.push({ x: item.x, y: item.y, width: item.width || 0, height: item.height || 0 });
        });
        drawnPaths.forEach(path => {
          if (path.points && path.points.length > 0) {
            path.points.forEach(p => itemsToConsiderForBounds.push({ x: p[0], y: p[1], width: 0, height: 0 }));
            if (path.startX !== undefined) { // For shapes like rectangle/circle
              itemsToConsiderForBounds.push({ x: path.startX, y: path.startY, width: 0, height: 0 });
            }
          }
        });
        connections.forEach(conn => {
          const fromItem = findItemById(conn.fromId);
          const toItem = findItemById(conn.toId);
          if (fromItem) itemsToConsiderForBounds.push({ x: fromItem.x, y: fromItem.y, width: fromItem.width, height: fromItem.height });
          if (toItem) itemsToConsiderForBounds.push({ x: toItem.x, y: toItem.y, width: toItem.width, height: toItem.height });
        });

        if (itemsToConsiderForBounds.length === 0 && drawnPaths.length === 0 && connections.length === 0) {
          alert("保存する内容が家系図にありません。");
          return;
        }

        itemsToConsiderForBounds.forEach(item => {
          contentExists = true;
          minX = Math.min(minX, item.x);
          minY = Math.min(minY, item.y);
          maxX = Math.max(maxX, item.x + (item.width || 0));
          maxY = Math.max(maxY, item.y + (item.height || 0));
        });

        if (!contentExists) {
          alert("保存する内容が家系図にありません。");
          return;
        }
        if (maxX - minX < 1) maxX = minX + 50; // 最小幅/高さを確保
        if (maxY - minY < 1) maxY = minY + 50;

        const treePadding = 30; // 家系図周囲の余白
        const treeContentWidth = maxX - minX;
        const treeContentHeight = maxY - minY;
        //const outputScaleFactor = 2.0; // n倍の解像度。値を大きくすると高画質・高負荷。1.0なら変更なし。
        const treeDrawingAreaWidth = (treeContentWidth + treePadding * 2) * outputScaleFactor;
        const treeDrawingAreaHeight = (treeContentHeight + treePadding * 2) * outputScaleFactor;

        // 2. 情報エリアのコンテンツ収集と準備
        const INFO_AREA_BACKGROUND_COLOR = '#ffffff'; // 情報エリアの背景色
        const INFO_DEFAULT_TEXT_COLOR = '#000000';
        const INFO_HEADER_TEXT_COLOR = '#000000';
        const INFO_SECONDARY_TEXT_COLOR = '#555555';
        const INFO_ERROR_TEXT_COLOR = '#e74c3c';
        const INFO_INDENT_SIZE = 15; // インデント幅

        const infoAreaMinWidth = 350; // 情報エリアの最小幅
        const infoInternalPadding = 25; // 情報エリア内のパディング
        const infoLineHeight = 24;    // テキスト1行の基本高さ
        const infoFontSize = 15;      // 基本フォントサイズ
        const infoImageSize = 20;     // 推奨捕獲順のユニット画像のサイズ
        const infoImageTextGap = 5;   // 画像とテキストの間隔

        const infoAreaContent = [];
        const captureImagesToLoad = {};

        const addInfo = (type, content, options = {}) => {
          infoAreaContent.push({
            type: type,
            content: content,
            indent: options.indent || 0,
            isBold: options.isBold || false,
            color: options.color || INFO_DEFAULT_TEXT_COLOR,
            imageUrl: options.imageUrl || null
          });
          if (type === 'imageText' && options.imageUrl && !captureImagesToLoad[options.imageUrl]) {
            captureImagesToLoad[options.imageUrl] = { img: null, loaded: false, error: false };
          }
        };

        // --- 必要作物 ---
        addInfo('header', "--- 必要作物 ---", { isBold: true, color: INFO_HEADER_TEXT_COLOR });
        const cropListItems = requiredCropsList.querySelectorAll('li.crop-list-item');
        if (cropListItems.length > 0) {
          cropListItems.forEach(item => {
            const foodTextContent = item.textContent ? item.textContent.trim() : "情報なし";
            const foodNameMatch = foodTextContent.match(/^([\u3040-\u309F\u30A0-\u30FF\uFF00-\uFFEF\w]+):/);
            const foodName = foodNameMatch ? foodNameMatch[1] : null;
            const foodColor = foodName && typeof cropColors !== 'undefined' && cropColors[foodName] ? cropColors[foodName] : INFO_DEFAULT_TEXT_COLOR;
            addInfo('bullet', foodTextContent, { indent: 1, color: foodColor });
          });
        } else {
          addInfo('text', "なし", { indent: 1 });
        }
        addInfo('separator', '');

        // --- 必要ゴールド ---
        addInfo('header', "--- 必要ゴールド ---", { isBold: true, color: INFO_HEADER_TEXT_COLOR });
        addInfo('text', document.getElementById('total-gold-cost').textContent, { indent: 1 });
        const goldDetailsNode = document.getElementById('gold-details');
        const plainGoldDetails = goldDetailsNode ? goldDetailsNode.textContent.replace(/\(\s*内訳[^)]*\)/g, '').trim() : "";
        addInfo('text', `(${plainGoldDetails})`, { indent: 1, color: INFO_SECONDARY_TEXT_COLOR });
        addInfo('separator', '');

        // --- 推奨捕獲順 ---
        const targetIndividualForSave = units.find(u => u.isTargetIndividual === true);
        if (targetIndividualForSave && targetIndividualForSave.type === 'unit' && targetIndividualForSave.activeSlotKeys?.length === 1) {
          const { sakiParent, atoParent, birthPartner, error: dtprError } = determineTargetParentRoles(targetIndividualForSave);
          if (!dtprError && sakiParent && atoParent) {
            addInfo('header', "--- 推奨捕獲順 ---", { isBold: true, color: INFO_HEADER_TEXT_COLOR });
            addInfo('text', `目標: ${getItemDisplayName(targetIndividualForSave)}`, { indent: 1 });
            if (sakiParent) addInfo('text', `先の親系統: ${getItemDisplayName(sakiParent)}`, { indent: 2 });
            if (atoParent) addInfo('text', `後の親系統: ${getItemDisplayName(atoParent)}`, { indent: 2 });
            if (birthPartner) addInfo('text', `出生の相方(参考): ${getItemDisplayName(birthPartner)}`, { indent: 2, color: INFO_SECONDARY_TEXT_COLOR });
            addInfo('separator', '');

            const capturePhasesElements = document.getElementById('recommended-capture-order-content')?.querySelectorAll('.capture-phase');
            if (capturePhasesElements && capturePhasesElements.length > 0) {
              capturePhasesElements.forEach(phaseEl => {
                const phaseTitle = phaseEl.querySelector('h5')?.textContent || "フェーズ";
                addInfo('header', phaseTitle, { indent: 1, isBold: true });
                const phaseItems = phaseEl.querySelectorAll('li');
                if (phaseItems.length > 0) {
                  phaseItems.forEach(li => {
                    const unitName = li.querySelector('strong')?.textContent || "不明";
                    const imgSrc = li.querySelector('img')?.src;
                    let attributesText = "";
                    const monoColorSpan = li.querySelector('span[style*="color:#e74c3c"]'); // 単色
                    const garaSpan = li.querySelector('span[style*="color:#2ecc71"]');    // 柄
                    if (monoColorSpan) attributesText = monoColorSpan.textContent.trim();
                    else if (garaSpan) attributesText = garaSpan.textContent.trim();

                    const roleText = li.querySelector('small') ? li.querySelector('small').textContent.trim() : "";
                    addInfo('imageText', `${unitName} ${attributesText}`, { indent: 2, imageUrl: imgSrc });
                    if (roleText) addInfo('text', `(${roleText})`, { indent: 3, color: INFO_SECONDARY_TEXT_COLOR });
                  });
                } else {
                  addInfo('text', "(該当なし)", { indent: 2, color: INFO_SECONDARY_TEXT_COLOR });
                }
                addInfo('separator', '');
              });
            } else {
              addInfo('text', "(表示できる捕獲順がありません)", { indent: 1, color: INFO_SECONDARY_TEXT_COLOR });
            }
          } else if (dtprError) {
            addInfo('header', "--- 推奨捕獲順 ---", { isBold: true, color: INFO_HEADER_TEXT_COLOR });
            addInfo('text', `(エラー: ${dtprError})`, { indent: 1, color: INFO_ERROR_TEXT_COLOR });
          }
        } else if (targetIndividualForSave) {
          addInfo('header', "--- 推奨捕獲順 ---", { isBold: true, color: INFO_HEADER_TEXT_COLOR });
          addInfo('text', "(目標個体の設定が無効です。画像1枚のユニットである必要があります)", { indent: 1, color: INFO_ERROR_TEXT_COLOR });
        }
        // ツール情報など
        addInfo('separator', '');
        addInfo('text', "Generated by DenpaKakeizuTool", { color: "#aaaaaa" });


        // 3. 情報エリアの幅と高さ計算
        let maxInfoTextWidth = 0;
        let calculatedInfoAreaHeight = infoInternalPadding;
        const tempMeasureCtx = document.createElement('canvas').getContext('2d');
        if (!tempMeasureCtx) {
          alert("画像生成のための内部処理に失敗しました。");
          return;
        }

        infoAreaContent.forEach(line => {
          tempMeasureCtx.font = line.isBold ? `bold ${infoFontSize}px ${DEFAULT_FONT}` : `${infoFontSize}px ${DEFAULT_FONT}`;
          let lineContent = "";
          let lineIndentWidth = (line.indent || 0) * INFO_INDENT_SIZE;

          if (line.type === 'imageText' && line.imageUrl) {
            lineContent = line.content || "";
            maxInfoTextWidth = Math.max(maxInfoTextWidth, lineIndentWidth + infoImageSize + infoImageTextGap + tempMeasureCtx.measureText(lineContent).width);
            calculatedInfoAreaHeight += Math.max(infoLineHeight, infoImageSize);
          } else if (line.type === 'bullet') {
            lineContent = line.content || "";
            const bulletIndent = (line.indent || 0) * INFO_INDENT_SIZE;
            const bulletRadius = infoFontSize * 0.28; // 文字サイズに対する比率で
            const bulletGap = infoInternalPadding / 4; // bulletとテキストの間
            maxInfoTextWidth = Math.max(maxInfoTextWidth, bulletIndent + bulletRadius * 2 + bulletGap + tempMeasureCtx.measureText(lineContent).width);
            calculatedInfoAreaHeight += infoLineHeight;
          } else if (line.type === 'separator') {
            calculatedInfoAreaHeight += infoLineHeight / 2; // 区切り線は少し間隔を狭く
          } else { // header or text
            lineContent = line.content || "";
            maxInfoTextWidth = Math.max(maxInfoTextWidth, lineIndentWidth + tempMeasureCtx.measureText(lineContent).width);
            calculatedInfoAreaHeight += infoLineHeight;
          }
        });
        calculatedInfoAreaHeight += infoInternalPadding;
        const calculatedInfoAreaWidth = Math.max(infoAreaMinWidth, maxInfoTextWidth + infoInternalPadding * 2);
        const calculatedInfoAreaWidth_unscaled = Math.max(infoAreaMinWidth, maxInfoTextWidth + infoInternalPadding * 2);
        const calculatedInfoAreaHeight_unscaled = calculatedInfoAreaHeight;

        // 4. 画像の事前読み込み (推奨捕獲順の画像)
        if (Object.keys(captureImagesToLoad).length > 0) {
          const loadImagePromises = Object.keys(captureImagesToLoad).map(url => {
            return new Promise((resolve) => {
              const img = new Image();
              img.crossOrigin = "Anonymous";
              img.onload = () => {
                captureImagesToLoad[url].img = img;
                captureImagesToLoad[url].loaded = true;
                resolve();
              };
              img.onerror = () => {
                captureImagesToLoad[url].error = true;
                console.warn("推奨捕獲順の画像読み込みエラー(事前):", url);
                resolve();
              };
              img.src = url;
            });
          });
          await Promise.all(loadImagePromises);
        }

        // 5. 最終出力Canvasのサイズ設定と描画
        const spaceBetweenTreeAndInfo_scaled = 25 * outputScaleFactor;
        const infoAreaDrawingWidth = calculatedInfoAreaWidth_unscaled * outputScaleFactor;
        const infoAreaDrawingHeight = calculatedInfoAreaHeight_unscaled * outputScaleFactor;

        const finalCanvasWidth = treeDrawingAreaWidth + infoAreaDrawingWidth + spaceBetweenTreeAndInfo_scaled;
        const finalCanvasHeight = Math.max(treeDrawingAreaHeight, infoAreaDrawingHeight);

        const finalOutputCanvas = document.createElement('canvas');
        finalOutputCanvas.width = finalCanvasWidth;
        finalOutputCanvas.height = finalCanvasHeight;
        const finalOutputCtx = finalOutputCanvas.getContext('2d');
        if (!finalOutputCtx) {
          alert("最終画像の生成に失敗しました。");
          return;
        }

        // 描画品質の設定
        finalOutputCtx.imageSmoothingEnabled = true;
        finalOutputCtx.imageSmoothingQuality = 'high';

        // 全体を背景色で塗りつぶし
        finalOutputCtx.fillStyle = desiredBackgroundColor;
        finalOutputCtx.fillRect(0, 0, finalCanvasWidth, finalCanvasHeight);

        // 5a. 家系図部分の描画 (オフスクリーンCanvas経由)
        const treeLayerCanvas = document.createElement('canvas');
        treeLayerCanvas.width = treeDrawingAreaWidth;
        treeLayerCanvas.height = treeDrawingAreaHeight;
        const treeLayerCtx = treeLayerCanvas.getContext('2d');
        if (!treeLayerCtx) return;

        // 描画品質の設定
        treeLayerCtx.imageSmoothingEnabled = true;
        treeLayerCtx.imageSmoothingQuality = 'high';

        // drawAllElementsOnContext は背景透明で描画するオプションが必要
        drawAllElementsOnContext(
          treeLayerCtx, treeLayerCanvas,
          { units, groups, connections, textItems, drawnPaths, drawnPathsInProgress: [], selectedItem: null, connectFromItem: null, itemsToGroup: [], isDrawing: false },
          {
            scale: outputScaleFactor,
            originX: (-minX * outputScaleFactor) + (treePadding * outputScaleFactor),
            originY: (-minY * outputScaleFactor) + (treePadding * outputScaleFactor),
            mode: null
          },
          true
        );
        finalOutputCtx.drawImage(treeLayerCanvas, 0, 0);

        // 5b. 情報エリアの描画
        const infoAreaStartX_onFinalCanvas = treeDrawingAreaWidth + spaceBetweenTreeAndInfo_scaled;
        // 情報エリアの背景 (オプション)
        // finalOutputCtx.fillStyle = INFO_AREA_BACKGROUND_COLOR;
        // finalOutputCtx.fillRect(infoAreaStartX, 0, calculatedInfoAreaWidth, finalCanvasHeight);

        finalOutputCtx.textBaseline = 'top';
        finalOutputCtx.save();
        finalOutputCtx.translate(infoAreaStartX_onFinalCanvas, 0);
        finalOutputCtx.scale(outputScaleFactor, outputScaleFactor);

        // 情報エリア内の描画ロジック（フォントサイズや座標はスケーリング前の基準で指定）
        let currentInfoY_unscaled = infoInternalPadding;
        const infoFontSize_unscaled = infoFontSize;
        const infoLineHeight_unscaled = infoLineHeight;
        const infoImageSize_unscaled = infoImageSize;
        const infoImageTextGap_unscaled = infoImageTextGap;
        const INFO_INDENT_SIZE_unscaled = INFO_INDENT_SIZE;

        infoAreaContent.forEach(line => {
          let currentLineEffectiveHeight_unscaled = infoLineHeight_unscaled;
          finalOutputCtx.font = line.isBold ? `bold ${infoFontSize_unscaled}px ${DEFAULT_FONT}` : `${infoFontSize_unscaled}px ${DEFAULT_FONT}`;
          finalOutputCtx.fillStyle = line.color;

          const indentWidth_unscaled = (line.indent || 0) * INFO_INDENT_SIZE_unscaled;
          let drawX_unscaled = infoInternalPadding + indentWidth_unscaled;

          if (line.type === 'header' || line.type === 'text') {
            finalOutputCtx.fillText(line.content, drawX_unscaled, currentInfoY_unscaled);
          } else if (line.type === 'bullet') {
            const bulletRadius_unscaled = infoFontSize_unscaled * 0.28;
            const bulletX_unscaled = drawX_unscaled;
            const bulletY_unscaled = currentInfoY_unscaled + infoLineHeight_unscaled / 2 - bulletRadius_unscaled / 2;
            const textX_unscaled = bulletX_unscaled + bulletRadius_unscaled * 2 + (infoImageTextGap_unscaled / 2);

            finalOutputCtx.beginPath();
            finalOutputCtx.arc(bulletX_unscaled + bulletRadius_unscaled, bulletY_unscaled + bulletRadius_unscaled, bulletRadius_unscaled, 0, Math.PI * 2);
            finalOutputCtx.fill();

            finalOutputCtx.fillStyle = INFO_DEFAULT_TEXT_COLOR;
            finalOutputCtx.fillText(line.content.replace(/^[\u3040-\u309F\u30A0-\u30FF\uFF00-\uFFEF\w]+:\s*/, ''), textX_unscaled, currentInfoY_unscaled);
          } else if (line.type === 'imageText' && line.imageUrl && captureImagesToLoad[line.imageUrl]) {
            const imgInfo = captureImagesToLoad[line.imageUrl];
            if (imgInfo.loaded && imgInfo.img) {
              try {
                const imageDrawY_unscaled = currentInfoY_unscaled + (infoLineHeight_unscaled - infoImageSize_unscaled) / 2;
                finalOutputCtx.drawImage(imgInfo.img, drawX_unscaled, imageDrawY_unscaled, infoImageSize_unscaled, infoImageSize_unscaled);
                drawX_unscaled += infoImageSize_unscaled + infoImageTextGap_unscaled;
              } catch (e) { console.error("情報エリアの画像描画エラー:", e, imgInfo.img.src); }
            } else if (imgInfo.error) {
              finalOutputCtx.fillStyle = INFO_ERROR_TEXT_COLOR;
              const errorTextY_unscaled = currentInfoY_unscaled + (infoLineHeight_unscaled - infoFontSize_unscaled) / 2;
              finalOutputCtx.fillText('×', drawX_unscaled + infoImageSize_unscaled / 4, errorTextY_unscaled);
              drawX_unscaled += infoImageSize_unscaled + infoImageTextGap_unscaled;
            }
            finalOutputCtx.fillStyle = line.color;
            finalOutputCtx.fillText(line.content, drawX_unscaled, currentInfoY_unscaled);
            currentLineEffectiveHeight_unscaled = Math.max(infoLineHeight_unscaled, infoImageSize_unscaled);
          } else if (line.type === 'separator') {
            currentLineEffectiveHeight_unscaled = infoLineHeight_unscaled / 2;
          }
          currentInfoY_unscaled += currentLineEffectiveHeight_unscaled;
        });
        finalOutputCtx.restore();

        // 6. プレビューモーダルに表示 または ダウンロード用データ保持
        try {
          const dataURL = finalOutputCanvas.toDataURL('image/png');
          saveImagePreview.src = dataURL; // プレビューは常に更新
          if (!isForPreviewOnly) { // ダウンロードボタンが押された時（またはダウンロード用データが必要な時）だけdatasetを更新
            saveImagePreview.dataset.fullDataUrl = dataURL;
          }
          // モーダルがまだ表示されていなければ開く (初回表示など)
          if ((isForPreviewOnly || !isForPreviewOnly) && (!imagePreviewModal.style.display || imagePreviewModal.style.display === 'none')) {
            openModal(imagePreviewModal);
          }
        } catch (e) {
          console.error("プレビュー用画像のDataURL生成中にエラー:", e);
          if (e.name === "SecurityError") {
            alert("画像の生成中にセキュリティエラーが発生しました。外部サイトの画像が家系図に含まれている場合、この問題が発生することがあります。");
          } else {
            alert("画像プレビューの生成中にエラーが発生しました。");
          }
        }
      }
      if (imagePreviewModalCloseButton) {
        imagePreviewModalCloseButton.addEventListener('click', () => {
          closeModal(imagePreviewModal);
          saveImagePreview.src = "#"; // 画像データをクリア
          saveImagePreview.removeAttribute('data-full-data-url');
        });
      }
      if (forceDownloadButton && previewResolutionOptions) { // previewResolutionOptions も条件に追加
        forceDownloadButton.addEventListener('click', async () => {
          // ▼▼▼ ここから修正 ▼▼▼
          const selectedScaleForDownload = parseFloat(previewResolutionOptions.value);
          if (isNaN(selectedScaleForDownload) || selectedScaleForDownload <= 0) {
            alert("有効な解像度が選択されていません。");
            return;
          }

          forceDownloadButton.textContent = "準備中...";
          forceDownloadButton.disabled = true;

          // 選択されている解像度で画像を再生成し、ダウンロード用データも更新
          await generateAndSaveImage(selectedScaleForDownload, false); // isForPreviewOnly を false に

          const dataURL = saveImagePreview.dataset.fullDataUrl; // 更新されたデータを取得
          // ▲▲▲ ここまで修正 ▲▲▲

          if (dataURL) {
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.-]/g, '').slice(0, -4);
            link.download = `DenpaTree_${selectedScaleForDownload.toFixed(1)}x_${timestamp}.png`;
            link.href = dataURL;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          } else {
            alert("ダウンロードする画像データが見つかりません。");
          }
          forceDownloadButton.textContent = "ファイルとしてダウンロード";
          forceDownloadButton.disabled = false;
        });
      }
      if (regeneratePreviewButton && previewResolutionOptions) {
        regeneratePreviewButton.addEventListener('click', () => {
          const selectedScale = parseFloat(previewResolutionOptions.value);
          if (!isNaN(selectedScale) && selectedScale > 0) {
            currentPreviewScaleFactor = selectedScale;

            regeneratePreviewButton.textContent = "再生成中...";
            regeneratePreviewButton.disabled = true;
            generateAndSaveImage(selectedScale, true).finally(() => {
              regeneratePreviewButton.textContent = "プレビュー再生成";
              regeneratePreviewButton.disabled = false;
            });
          } else {
            alert("有効な解像度を選択してください。");
          }
        });
      }
      document.addEventListener('keydown', (e) => {
        if ((e.key === 'Delete' || e.key === 'Backspace') && selectedItem && !currentMode) {
          if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'SELECT' && document.activeElement.tagName !== 'TEXTAREA') {
            const displayName = getItemDisplayName(selectedItem);
            if (confirm(`「${truncateText(displayName, 15)}」を削除しますか？`)) {
              if (selectedItem.type === 'unit' || selectedItem.type === 'image-collection') { units = units.filter(unit => unit.id !== selectedItem.id); groups.forEach(g => g.itemIds = g.itemIds.filter(id => id !== selectedItem.id)); }
              else if (selectedItem.type === 'group') { const uIG = [...selectedItem.itemIds]; units = units.filter(u => !uIG.includes(u.id)); connections = connections.filter(c => !uIG.includes(c.fromId) && !uIG.includes(c.toId)); groups = groups.filter(g => g.id !== selectedItem.id); }
              else if (selectedItem.type === 'text') { textItems = textItems.filter(t => t.id !== selectedItem.id); }
              connections = connections.filter(conn => conn.fromId !== selectedItem.id && conn.toId !== selectedItem.id);
              if (connectFromItem && connectFromItem.id === selectedItem.id) connectFromItem = null;
              selectedItem = null; saveState(); drawCanvas(); updateInfoModal();
            }
          }
        }
      });
      zoomInButton.addEventListener('click', () => { zoomLevel++; updateZoom(); });
      zoomOutButton.addEventListener('click', () => { zoomLevel--; updateZoom(); });
      canvas.addEventListener('wheel', (event) => { event.preventDefault(); const d = event.deltaY > 0 ? -1 : 1; const oS = scale; zoomLevel += d; scale = Math.pow(1.2, zoomLevel); zoomLevelIndicator.textContent = zoomLevel; const r = canvas.getBoundingClientRect(); const mX = event.clientX - r.left, mY = event.clientY - r.top; const mCXB = (mX - originX) / oS, mCYB = (mY - originY) / oS; originX = mX - mCXB * scale; originY = mY - mCYB * scale; drawCanvas(); }, { passive: false });
      unitEditModalCloseButton.addEventListener('click', () => {
        closeModal(unitEditModal);
        editingUnit = null;
        editingGroup = null;
        editingTextItem = null;
        editingCollectionUnit = null;
        editingLine = null;
        currentEditingUnitContext = null;
      });
      unitEditCancelButton.addEventListener('click', () => {
        closeModal(unitEditModal);
        editingUnit = null;
        editingGroup = null;
        editingTextItem = null;
        editingCollectionUnit = null;
        editingLine = null;
        currentEditingUnitContext = null;
        if (currentMode === 'edit-item') toggleMode(null);
      });
      unitEditApplyButton.addEventListener('click', () => {
        if (editingUnit) {
          const borderCheckbox = document.getElementById('unit-edit-border-visible');
          if (borderCheckbox) {
            editingUnit.borderVisible = borderCheckbox.checked;
          }

          document.querySelectorAll('#unit-edit-modal-body .unit-edit-slot-name').forEach(input => {
            const slotKey = input.dataset.slotKey;
            if (!editingUnit.slots[slotKey] && input.value.trim()) {
              editingUnit.slots[slotKey] = { name: input.value.trim(), food: '未選択', order: null, img: null, imgDataUrl: null, originalDataUrl: null, fileName: null };
            } else if (editingUnit.slots[slotKey]) {
              editingUnit.slots[slotKey].name = input.value.trim();
            } else if (!input.value.trim() && editingUnit.slots[slotKey]) {
              editingUnit.slots[slotKey].name = '';
            }
          });
          document.querySelectorAll('#unit-edit-modal-body .unit-edit-slot-food').forEach(select => {
            const slotKey = select.dataset.slotKey;
            const selectedFood = select.value;
            if (!editingUnit.slots[slotKey]) {
              if (selectedFood !== '未選択') {
                editingUnit.slots[slotKey] = { name: '', food: selectedFood, order: null, img: null, imgDataUrl: null, originalDataUrl: null, fileName: null };
              }
            } else {
              editingUnit.slots[slotKey].food = selectedFood;
            }
          });
          ['qr1', 'qr2'].forEach(sk => {
            if (editingUnit.slots[sk]) {
              const sakiChk = document.getElementById(`unit-edit-${sk}-order-先`);
              const atoChk = document.getElementById(`unit-edit-${sk}-order-後`);
              if (sakiChk && sakiChk.checked) {
                editingUnit.slots[sk].order = '先';
              } else if (atoChk && atoChk.checked) {
                editingUnit.slots[sk].order = '後';
              } else {
                editingUnit.slots[sk].order = null;
              }
            }
          });

          editingUnit.height = calculateUnitHeight(editingUnit.slots);
          editingUnit.activeSlotKeys = Object.keys(editingUnit.slots).filter(k => editingUnit.slots[k]?.img || editingUnit.slots[k]?.imgDataUrl);
          const imageCount = editingUnit.activeSlotKeys.length;
          if (imageCount === 1) editingUnit.width = UNIT_WIDTH_ONE_SLOT;
          else if (imageCount === 2) editingUnit.width = UNIT_WIDTH_TWO_SLOTS;
          else editingUnit.width = UNIT_WIDTH_THREE_SLOTS;

          saveState();
          drawCanvas();
          updateInfoModal();
          closeModal(unitEditModal);
          editingUnit = null;
          currentEditingUnitContext = null;
          if (currentMode === 'edit-item') toggleMode(null);

        } else if (editingLine) {
          const colorInput = document.getElementById('line-edit-color');
          const lineWidthInput = document.getElementById('line-edit-lineWidth');
          const lineDashSelect = document.getElementById('line-edit-dashType');

          if (colorInput) {
            editingLine.color = colorInput.value;
          }
          if (lineWidthInput) {
            const newWidth = parseInt(lineWidthInput.value, 10);
            if (!isNaN(newWidth) && newWidth >= 1 && newWidth <= 50) {
              editingLine.lineWidth = newWidth;
            } else {
              alert("線の太さの値が不正です。1から50の間で入力してください。");
              return;
            }
          }
          if (lineDashSelect) {
            try {
              editingLine.dashArray = JSON.parse(lineDashSelect.value);
            } catch (e) {
              console.error("線の種類の値のパースに失敗しました:", e);
              editingLine.dashArray = [];
            }
          }

          saveState();
          drawCanvas();
          closeModal(unitEditModal);
          editingLine = null;
          if (currentMode === 'edit-item') toggleMode(null);
        }
      });
      unitEditDuplicateButton.addEventListener('click', () => {
        if (editingUnit) {
          const newUnitData = JSON.parse(JSON.stringify({
            ...editingUnit,
            slots: Object.fromEntries(
              Object.entries(editingUnit.slots).map(([key, slot]) => [
                key,
                slot ? { ...slot, img: null } : null
              ])
            )
          }));

          newUnitData.id = `item-${nextItemId++}`;
          newUnitData.x += 30 / scale;
          newUnitData.y += 30 / scale;
          newUnitData.isSelected = false;

          const imageLoadPromises = Object.keys(newUnitData.slots).map(async slotKey => {
            const slot = newUnitData.slots[slotKey];
            if (slot && slot.imgDataUrl) {
              const img = new Image();
              img.src = slot.imgDataUrl;
              try {
                await img.decode();
                slot.img = img;
              } catch (e) {
                console.error(`複製時エラー: 画像 ${slot.fileName} の読み込みに失敗`, e);
                slot.img = null; // 読み込み失敗時はnull
              }
            }
          });

          Promise.all(imageLoadPromises).then(() => {
            newUnitData.activeSlotKeys = Object.keys(newUnitData.slots).filter(k => newUnitData.slots[k]?.img || newUnitData.slots[k]?.imgDataUrl);
            const imageCount = newUnitData.activeSlotKeys.length;
            if (imageCount === 1) newUnitData.width = UNIT_WIDTH_ONE_SLOT;
            else if (imageCount === 2) newUnitData.width = UNIT_WIDTH_TWO_SLOTS;
            else newUnitData.width = UNIT_WIDTH_THREE_SLOTS;
            newUnitData.height = calculateUnitHeight(newUnitData.slots);

            units.push(newUnitData);
            saveState();
            drawCanvas();
            closeModal(unitEditModal);
            editingUnit = null;
            currentEditingUnitContext = null;
            if (currentMode === 'edit-item') toggleMode(null);
            alert("ユニットを複製しました。");
          }).catch(err => {
            console.error("複製時の画像読み込みでエラーが発生しました:", err);
            alert("ユニットの複製中にエラーが発生しました。");
          });
        }
      });
      unitEditDeleteButton.addEventListener('click', () => {
        if (editingUnit) {
          if (confirm(`ユニット「${getItemDisplayName(editingUnit)}」を削除しますか？`)) {
            units = units.filter(u => u.id !== editingUnit.id);
            connections = connections.filter(c => c.fromId !== editingUnit.id && c.toId !== editingUnit.id);
            groups.forEach(g => g.itemIds = g.itemIds.filter(id => id !== editingUnit.id));
            if (selectedItem && selectedItem.id === editingUnit.id) selectedItem = null;

            saveState();
            drawCanvas();
            updateInfoModal();
            closeModal(unitEditModal);
            editingUnit = null;
            currentEditingUnitContext = null;
            if (currentMode === 'edit-item') toggleMode(null);
          }
        } else if (editingLine) {
          if (confirm(`選択されている接続線 (ID: ${truncateText(editingLine.id, 15)}) を削除しますか？`)) {
            connections = connections.filter(conn => conn.id !== editingLine.id);
            if (selectedItem && selectedItem.id === editingLine.id) selectedItem = null;

            saveState();
            drawCanvas();
            closeModal(unitEditModal);
            editingLine = null;
            if (currentMode === 'edit-item') toggleMode(null);
          }
        }
      });
      groupEditModalCloseButton.addEventListener('click', () => { closeModal(groupEditModal); editingGroup = null; });
      groupEditCancelButton.addEventListener('click', () => { closeModal(groupEditModal); editingGroup = null; if (currentMode === 'edit-item') toggleMode(null); });
      groupEditApplyButton.addEventListener('click', () => {
        if (editingGroup) {
          editingGroup.name = groupEditNameInput.value.trim();
          editingGroup.borderVisible = groupEditBorderVisibleCheckbox.checked;
          saveState();
          drawCanvas();
          closeModal(groupEditModal);
          editingGroup = null;
          if (currentMode === 'edit-item') toggleMode(null); // 編集モードを解除
        }
      });
      groupEditUngroupButton.addEventListener('click', () => {
        if (editingGroup && confirm(`グループ「${editingGroup.name || '選択グループ'}」のグループ化を解除しますか？ (中のユニットは残ります)`)) {
          connections = connections.filter(c => c.fromId !== editingGroup.id && c.toId !== editingGroup.id);
          groups = groups.filter(g => g.id !== editingGroup.id);
          if (selectedItem && selectedItem.id === editingGroup.id) selectedItem = null;
          saveState();
          drawCanvas();
          closeModal(groupEditModal);
          editingGroup = null;
          if (currentMode === 'edit-item') toggleMode(null);
        }
      });
      if (groupEditDuplicateButton) {
        groupEditDuplicateButton.addEventListener('click', async () => {
          if (editingGroup) {
            const newGroupData = JSON.parse(JSON.stringify({
              ...editingGroup,
              id: `item-${nextItemId++}`,
              name: editingGroup.name ? `${editingGroup.name}_コピー` : "コピーされたグループ",
              x: editingGroup.x + 30 / scale,
              y: editingGroup.y + 30 / scale,
              isSelected: false,
              itemIds: []
            }));

            const newUnitPromises = [];
            const oldToNewIdMap = {};

            // 2. グループ内の各ユニットを複製
            for (const oldUnitId of editingGroup.itemIds) {
              const originalUnit = findItemById(oldUnitId);
              if (originalUnit) {
                const newUnitCopy = JSON.parse(JSON.stringify({
                  ...originalUnit,
                  slots: Object.fromEntries(
                    Object.entries(originalUnit.slots || {}).map(([key, slot]) => [
                      key,
                      slot ? { ...slot, img: null } : null
                    ])
                  )
                }));

                const newUnitId = `item-${nextItemId++}`;
                oldToNewIdMap[oldUnitId] = newUnitId;
                newUnitCopy.id = newUnitId;
                newUnitCopy.x = newGroupData.x + (originalUnit.x - editingGroup.x);
                newUnitCopy.y = newGroupData.y + (originalUnit.y - editingGroup.y);
                newUnitCopy.isSelected = false;

                newGroupData.itemIds.push(newUnitId);
                const imageLoadPromises = Object.keys(newUnitCopy.slots || {}).map(async slotKey => {
                  const slot = newUnitCopy.slots[slotKey];
                  if (slot && slot.imgDataUrl) {
                    const img = new Image();
                    img.src = slot.imgDataUrl;
                    try {
                      await img.decode();
                      slot.img = img;
                    } catch (e) {
                      console.error(`複製時エラー(グループ内ユニット): 画像 ${slot.fileName} 読込失敗`, e);
                      slot.img = null;
                    }
                  }
                });
                newUnitPromises.push(Promise.all(imageLoadPromises).then(() => units.push(newUnitCopy)));
              }
            }

            await Promise.all(newUnitPromises);

            groups.push(newGroupData);
            saveState();
            drawCanvas();
            closeModal(groupEditModal);
            editingGroup = null;
            if (currentMode === 'edit-item') toggleMode(null);
            alert("グループを複製しました。");
          }
        });
      }
      groupEditDeleteButton.addEventListener('click', () => {
        if (editingGroup && confirm(`グループ「${editingGroup.name || '選択グループ'}」と、内部の全てのユニットを削除しますか？`)) {
          const unitIdsInGroup = [...editingGroup.itemIds];
          units = units.filter(u => !unitIdsInGroup.includes(u.id));
          connections = connections.filter(c =>
            c.fromId !== editingGroup.id && c.toId !== editingGroup.id &&
            !unitIdsInGroup.includes(c.fromId) && !unitIdsInGroup.includes(c.toId)
          );
          groups = groups.filter(g => g.id !== editingGroup.id);
          if (selectedItem && (selectedItem.id === editingGroup.id || unitIdsInGroup.includes(selectedItem.id))) {
            selectedItem = null;
          }
          saveState();
          drawCanvas();
          updateInfoModal();
          closeModal(groupEditModal);
          editingGroup = null;
          if (currentMode === 'edit-item') toggleMode(null);
        }
      });
      textEditModalCloseButton.addEventListener('click', () => { closeModal(textEditModal); editingTextItem = null; });
      textEditCancelButton.addEventListener('click', () => { closeModal(textEditModal); editingTextItem = null; if (currentMode === 'edit-item') toggleMode(null); });
      textEditApplyButton.addEventListener('click', () => {
        if (editingTextItem) {
          editingTextItem.text = document.getElementById('modal-text-content').value;
          editingTextItem.font = DEFAULT_FONT;
          editingTextItem.color = document.getElementById('modal-text-color').value;
          editingTextItem.backgroundColor = document.getElementById('modal-text-bgcolor').value;
          editingTextItem.fontSize = parseInt(document.getElementById('modal-text-size').value, 10);
          editingTextItem.borderVisible = document.getElementById('modal-text-border-visible').checked;
          editingTextItem.rotation = parseFloat(document.getElementById('modal-text-rotation').value) || 0;

          const textPaddingForCalc = TEXT_ITEM_PADDING;
          const measureForWidth = wrapTextAndMeasure(editingTextItem.text, Infinity, editingTextItem.fontSize, editingTextItem.font || DEFAULT_FONT, TEXT_LINE_HEIGHT_MULTIPLIER);
          editingTextItem.width = Math.max(MIN_TEXT_ITEM_WIDTH, measureForWidth.calculatedWidth + (textPaddingForCalc * 2));

          const finalMaxWidth = editingTextItem.width - (textPaddingForCalc * 2);
          let minHeight = Math.max(MIN_TEXT_ITEM_HEIGHT, editingTextItem.fontSize * TEXT_LINE_HEIGHT_MULTIPLIER + (textPaddingForCalc * 2));
          if (finalMaxWidth > 0) {
            const finalMeasured = wrapTextAndMeasure(editingTextItem.text, finalMaxWidth, editingTextItem.fontSize, editingTextItem.font || DEFAULT_FONT, TEXT_LINE_HEIGHT_MULTIPLIER);
            const newCalculatedHeight = finalMeasured.calculatedHeight + (textPaddingForCalc * 2);
            editingTextItem.height = Math.max(minHeight, newCalculatedHeight);
          } else {
            editingTextItem.height = minHeight;
          }

          saveState();
          drawCanvas();
          closeModal(textEditModal);
          editingTextItem = null;
          if (currentMode === 'edit-item') toggleMode(null);
        }
      });
      textEditDeleteButton.addEventListener('click', () => {
        if (editingTextItem && confirm(`テキスト「${truncateText(editingTextItem.text, 15)}」を削除しますか？`)) {
          textItems = textItems.filter(t => t.id !== editingTextItem.id);
          if (selectedItem && selectedItem.id === editingTextItem.id) selectedItem = null;
          saveState();
          drawCanvas();
          closeModal(textEditModal);
          editingTextItem = null;
          if (currentMode === 'edit-item') toggleMode(null);
        }
      });
      if (textEditDuplicateButton) { // ボタンが存在すればリスナーを設定
        textEditDuplicateButton.addEventListener('click', () => {
          if (editingTextItem) {
            const newTextItem = JSON.parse(JSON.stringify({
              ...editingTextItem,
              id: `item-${nextItemId++}`,
              x: editingTextItem.x + 20 / scale, // 少しずらす
              y: editingTextItem.y + 20 / scale,
              isSelected: false
            }));

            textItems.push(newTextItem);
            saveState();
            drawCanvas();
            closeModal(textEditModal);
            editingTextItem = null;
            if (currentMode === 'edit-item') toggleMode(null);
            alert("テキストを複製しました。");
          }
        });
      }
      showInfoModalButton.addEventListener('click', () => { updateInfoModal(); openModal(infoModal); });
      infoModalCloseButtonHeader.addEventListener('click', () => closeModal(infoModal));
      infoModalCloseButtonFooter.addEventListener('click', () => closeModal(infoModal));

      modalOverlay.addEventListener('click', (e) => {
        if (e.target === modalOverlay) {
          if (cropperModal.style.display === 'block' || cropperModal.style.display === 'flex') {
            if (currentEditingUnitContext === 'unit-edit-modal' || currentEditingUnitContext === 'collection-edit-modal') closeCropperModal(); else closeModal(cropperModal);
          } else if (unitEditModal.style.display === 'block' || unitEditModal.style.display === 'flex') {
            closeModal(unitEditModal);
            editingUnit = null;
            editingGroup = null;
            editingTextItem = null;
            editingCollectionUnit = null;
            editingLine = null;
            currentEditingUnitContext = null;
          } else if (groupEditModal.style.display === 'block' || groupEditModal.style.display === 'flex') {
            closeModal(groupEditModal); editingGroup = null;
          } else if (textEditModal.style.display === 'block' || textEditModal.style.display === 'flex') {
            closeModal(textEditModal); editingTextItem = null;
          } else if (infoModal.style.display === 'block' || infoModal.style.display === 'flex') {
            closeModal(infoModal);
          }
          if (toolInfoModal.style.display === 'block' || toolInfoModal.style.display === 'flex') {
            closeModal(toolInfoModal);
          }
        }
      });

      collectionEditModalCloseButton.addEventListener('click', () => { closeModal(collectionEditModal); editingCollectionUnit = null; });
      collectionEditCancelButton.addEventListener('click', () => { closeModal(collectionEditModal); editingCollectionUnit = null; if (currentMode === 'edit-item') toggleMode(null); });
      collectionEditApplyButton.addEventListener('click', () => {
        if (!editingCollectionUnit) return;

        editingCollectionUnit.name = collectionEditNameInput.value.trim();
        editingCollectionUnit.borderVisible = collectionEditBorderCheckbox.checked;
        editingCollectionUnit.layoutSettings = {
          maxSize: parseInt(document.getElementById('collection-edit-max-size').value, 10) || COLLECTION_IMAGE_MAX_SIZE,
          margin: parseInt(document.getElementById('collection-edit-margin').value, 10) || COLLECTION_IMAGE_MARGIN,
          padding: parseInt(document.getElementById('collection-edit-padding').value, 10) || COLLECTION_PADDING,
          textGap: parseInt(document.getElementById('collection-edit-text-gap').value, 10) || minTextGapLogical,
          perRow: parseInt(document.getElementById('collection-edit-per-row').value, 10) || COLLECTION_IMAGES_PER_ROW,
          fontSize: parseInt(document.getElementById('collection-edit-font-size').value, 10) || textFontSizeLogical
        };
        editingCollectionUnit.layoutSettings.maxSize = Math.max(10, editingCollectionUnit.layoutSettings.maxSize);
        editingCollectionUnit.layoutSettings.margin = Math.max(0, editingCollectionUnit.layoutSettings.margin);
        editingCollectionUnit.layoutSettings.padding = Math.max(0, editingCollectionUnit.layoutSettings.padding);
        editingCollectionUnit.layoutSettings.textGap = Math.max(0, editingCollectionUnit.layoutSettings.textGap);
        editingCollectionUnit.layoutSettings.perRow = Math.max(1, editingCollectionUnit.layoutSettings.perRow);
        editingCollectionUnit.layoutSettings.fontSize = Math.max(6, editingCollectionUnit.layoutSettings.fontSize);


        const updatedImagesData = [];
        const listItems = collectionEditImageList.querySelectorAll('li');

        listItems.forEach(item => {
          if (item.dataset.deleted !== 'true') {
            const originalIndex = parseInt(item.dataset.originalIndex, 10);

            if (isNaN(originalIndex) || !editingCollectionUnit.images[originalIndex]) {
              console.warn("collectionEditApplyButton: データ不整合の可能性。originalIndex:", originalIndex, "アイテム:", item, "現在の画像配列の長さ:", editingCollectionUnit.images.length);
              return;
            }

            const imageDataFromMaster = editingCollectionUnit.images[originalIndex];

            const nameInput = item.querySelector('input[data-field="name"]');
            const foodSelect = item.querySelector('select[data-field="food"]');

            updatedImagesData.push({
              img: imageDataFromMaster.img,
              imgDataUrl: imageDataFromMaster.imgDataUrl,
              originalDataUrl: imageDataFromMaster.originalDataUrl,
              fileName: imageDataFromMaster.fileName,
              name: nameInput ? nameInput.value.trim() : imageDataFromMaster.name,
              food: foodSelect ? foodSelect.value : imageDataFromMaster.food
            });
          }
        });

        editingCollectionUnit.images = updatedImagesData;


        const { width: newWidth, height: newHeight } = calculateImageCollectionUnitSize(editingCollectionUnit.images, editingCollectionUnit.layoutSettings);
        editingCollectionUnit.width = newWidth;
        editingCollectionUnit.height = newHeight;

        // 変更を保存し、UIを更新
        saveState();
        drawCanvas();
        updateInfoModal();
        closeModal(collectionEditModal);
        editingCollectionUnit = null;
        if (currentMode === 'edit-item') toggleMode(null);
      });
      collectionEditDeleteButton.addEventListener('click', () => {
        if (editingCollectionUnit && confirm(`画像集合ユニット「${getItemDisplayName(editingCollectionUnit)}」を削除しますか？ (内部の画像も全て削除されます)`)) {
          units = units.filter(u => u.id !== editingCollectionUnit.id);
          connections = connections.filter(c => c.fromId !== editingCollectionUnit.id && c.toId !== editingCollectionUnit.id);
          groups.forEach(g => g.itemIds = g.itemIds.filter(id => id !== editingCollectionUnit.id));
          if (selectedItem && selectedItem.id === editingCollectionUnit.id) selectedItem = null;
          saveState(); drawCanvas(); updateInfoModal(); closeModal(collectionEditModal);
          editingCollectionUnit = null; if (currentMode === 'edit-item') toggleMode(null);
        }
      });
      if (resetLayoutButton) {
        resetLayoutButton.addEventListener('click', () => {
          if (!editingCollectionUnit) return;
          document.getElementById('collection-edit-max-size').value = COLLECTION_IMAGE_MAX_SIZE;
          document.getElementById('collection-edit-margin').value = COLLECTION_IMAGE_MARGIN;
          document.getElementById('collection-edit-padding').value = COLLECTION_PADDING;
          document.getElementById('collection-edit-text-gap').value = minTextGapLogical;
          document.getElementById('collection-edit-per-row').value = COLLECTION_IMAGES_PER_ROW;
          document.getElementById('collection-edit-font-size').value = textFontSizeLogical;
        });
      }
      clearImageCollectionButton.addEventListener('click', () => {
        imageCollectionUploadInput.value = ''; uploadedCollectionImages = [];
        imageCollectionPreviewsDiv.innerHTML = ''; imageCollectionDetailsDiv.innerHTML = '';
        if (clearImageCollectionButton) clearImageCollectionButton.classList.add('hidden');
        checkAddImageCollectionButtonState();
      });
      if (clearStorageButton) {
        clearStorageButton.addEventListener('click', () => {
          if (confirm("保存されている家系図データを全て削除し、完全に新規の状態から開始します。よろしいですか？")) {
            try {
              localStorage.removeItem('kakeizuToolState');
              console.log("ローカルストレージのデータを削除しました。");
            } catch (e) {
              console.error("ローカルストレージのデータ削除に失敗しました:", e);
            }
            // 状態を完全に初期化
            units = []; groups = []; textItems = []; connections = []; nextItemId = 0;
            selectedItem = null; connectFromItem = null; itemsToGroup = [];
            drawnPaths = [];
            currentDrawingPath = [];
            isDrawing = false;
            if (drawingToolsPanel) drawingToolsPanel.style.display = 'none';
            if (currentMode) toggleMode(null);
            history = []; historyIndex = -1;
            scale = 1.0; zoomLevel = 0; originX = 0; originY = 0;
            zoomLevelIndicator.textContent = zoomLevel;

            drawCanvas();
            updateInfoModal();
            updateUndoRedoButtons();
            alert("データがクリアされました。ページをリロードするか、このまま新規作成を開始してください。");
          }
        });
      }
      if (drawingColorPicker) {
        drawingColorPicker.addEventListener('input', (e) => { drawingColor = e.target.value; });
      }
      if (drawingLineWidthSlider) {
        drawingLineWidthSlider.addEventListener('input', (e) => {
          drawingLineWidth = parseInt(e.target.value, 10);
          if (drawingLineWidthValue) drawingLineWidthValue.textContent = drawingLineWidth;
        });
      }
      if (drawingShapeSelect) {
        drawingShapeSelect.addEventListener('change', (e) => {
          drawingShape = e.target.value;
          updateFillOptionVisibility();
        });
      }
      if (clearAllDrawingsButton) {
        clearAllDrawingsButton.addEventListener('click', () => {
          if (confirm("家系図上のすべての手書き描画を消去しますか？")) {
            drawnPaths = [];
            resetDrawingHistory();
            drawCanvas();
          }
        });
      }
      if (drawingUndoButton) {
        drawingUndoButton.addEventListener('click', undoDrawing);
      }
      if (drawingRedoButton) {
        drawingRedoButton.addEventListener('click', redoDrawing);
      }

      if (unifySizeButton) {
        unifySizeButton.addEventListener('click', () => {
          if (currentMode && currentMode.startsWith('unify-size')) {
            toggleMode(null);
            unifySizeModeSubState = null;
            unifySizeBaseUnit = null;
            unifySizeTargetUnits.forEach(u => u.isTargetSelectedForUnify = false);
            unifySizeTargetUnits = [];
            drawCanvas();
            const unifySizeCompleteSelectionBtn = document.getElementById('unify-size-complete-selection-btn');
            if (unifySizeCompleteSelectionBtn) unifySizeCompleteSelectionBtn.style.display = 'none';

          } else {
            toggleMode('unify-size-select-base', unifySizeButton);
          }
        });
      }

      const unifyAllUnitsBtn = document.getElementById('unify-all-units-btn');
      const unifyVisibleUnitsBtn = document.getElementById('unify-visible-units-btn');
      const unifySelectTargetsBtn = document.getElementById('unify-select-targets-btn');
      const unifySizeOptionsModalCancelBtn = document.getElementById('unify-size-options-modal-cancel-btn');
      const unifySizeCompleteSelectionBtn = document.getElementById('unify-size-complete-selection-btn');
      const unifyOptionsModal = document.getElementById('unify-size-options-modal'); // モーダル要素取得

      if (unifyAllUnitsBtn) {
        unifyAllUnitsBtn.addEventListener('click', () => {
          if (!unifySizeBaseUnit) return;
          closeModal(unifyOptionsModal);
          if (confirm(`家系図上の全ての同種ユニットを「${getItemDisplayName(unifySizeBaseUnit)}」のサイズに統一しますか？`)) {
            performUnifySize(unifySizeBaseUnit, 'all');
          }
          toggleMode(null);
        });
      }

      if (unifyVisibleUnitsBtn) {
        unifyVisibleUnitsBtn.addEventListener('click', () => {
          if (!unifySizeBaseUnit) return;
          closeModal(unifyOptionsModal);
          if (confirm(`現在画面に表示されている同種ユニットを「${getItemDisplayName(unifySizeBaseUnit)}」のサイズに統一しますか？`)) {
            performUnifySize(unifySizeBaseUnit, 'visible');
          }
          toggleMode(null);
        });
      }

      if (unifySelectTargetsBtn) {
        unifySelectTargetsBtn.addEventListener('click', () => {
          if (!unifySizeBaseUnit) return;
          closeModal(unifyOptionsModal);
          unifySizeTargetUnits = [];
          units.forEach(u => u.isTargetSelectedForUnify = false);
          textItems.forEach(t => t.isTargetSelectedForUnify = false);
          toggleMode('unify-size-select-targets', unifySizeButton);
        });
      }

      if (unifySizeOptionsModalCancelBtn) {
        unifySizeOptionsModalCancelBtn.addEventListener('click', () => {
          closeModal(unifyOptionsModal);
          toggleMode(null);
        });
      }

      if (unifySizeCompleteSelectionBtn) {
        unifySizeCompleteSelectionBtn.addEventListener('click', () => {
          if (currentMode === 'unify-size-select-targets' && unifySizeBaseUnit) {
            if (unifySizeTargetUnits.length > 0) {
              if (confirm(`${unifySizeTargetUnits.length}個の選択されたユニットを「${getItemDisplayName(unifySizeBaseUnit)}」のサイズに統一しますか？`)) {
                performUnifySize(unifySizeBaseUnit, 'selected', [...unifySizeTargetUnits]);
                toggleMode(null);
              } else {
                showStatusBar(modeMessages['unify-size-select-targets'], unifySizeButton);
              }
            } else {
              alert("サイズを統一する対象ユニットが選択されていません。");
            }
          }
        });
      }
      const exportDataButton = document.getElementById('export-data-button');
      if (exportDataButton) {
        exportDataButton.addEventListener('click', () => {
          if (history.length === 0 || historyIndex < 0) {
            alert("エクスポートするデータがありません。");
            return;
          }

          // 現在の最新の状態を取得 (undoされていない最新の状態)
          const currentState = history[historyIndex]; // undo/redoを考慮してhistoryIndexのものをエクスポート

          if (!currentState) {
            alert("現在の状態を取得できませんでした。");
            return;
          }

          const exportableState = JSON.parse(JSON.stringify(currentState, (key, value) => {
            return value;
          }));

          const jsonString = JSON.stringify(exportableState, null, 2); // null, 2 で整形されたJSON文字列に
          const blob = new Blob([jsonString], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          const timestamp = new Date().toISOString().replace(/[:.-]/g, '').slice(0, -4);
          link.download = `denpa_kakeizu_data_${timestamp}.json`;
          link.href = url;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
          showStatusBar('家系図データをエクスポートしました。', exportDataButton);
        });
      }
      const importDataButton = document.getElementById('import-data-button');
      const importFileInput = document.getElementById('import-file-input');
      if (alignButton) {
        alignButton.addEventListener('click', () => {
          if (currentMode === 'align-select-base') {
            toggleMode(null);
          } else if (currentMode === 'align-select-targets') {
            if (alignBaseUnit && alignTargetUnits.length > 0) {
              alignOptionsBaseUnitName.textContent = getItemDisplayName(alignBaseUnit);
              alignOptionsTargetCount.textContent = alignTargetUnits.length;
              openModal(alignOptionsModal);
            } else if (!alignBaseUnit) {
              alert("先に基準ユニットを選択してください。");
              toggleMode('align-select-base', alignButton);
            } else {
              alert("整列する対象ユニットを1つ以上選択してください。");
            }
          } else {
            toggleMode('align-select-base', alignButton);
          }
        });
      }

      if (importDataButton && importFileInput) {
        importDataButton.addEventListener('click', () => {
          if (currentMode) {
            alert(`現在のモード (${currentMode}) をキャンセルしてからインポートしてください。`);
            return;
          }
          if (confirm("JSONファイルからデータをインポートします。\n現在の作業内容は上書きされますが、よろしいですか？")) {
            importFileInput.click();
          }
        });

        importFileInput.addEventListener('change', async (event) => {
          const file = event.target.files[0];
          if (!file) {
            return;
          }

          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const jsonString = e.target.result;
              const importedState = JSON.parse(jsonString);

              if (typeof importedState !== 'object' || importedState === null ||
                (!importedState.units && !importedState.groups && !importedState.textItems && !importedState.connections)) {
                alert("無効なファイル形式か、家系図データが含まれていません。");
                return;
              }


              history = [];
              historyIndex = -1;

              drawnPaths = [];
              currentDrawingPath = [];
              isDrawing = false;
              if (drawingToolsPanel) drawingToolsPanel.style.display = 'none';

              await restoreState(importedState);
              history = [JSON.parse(JSON.stringify(importedState))];
              historyIndex = 0;


              updateUndoRedoButtons();
              updateInfoModal();
              // resizeCanvas(); // restoreStateの最後にdrawCanvasがあるので不要な場合も
              showStatusBar('家系図データをインポートしました。', importDataButton);

            } catch (error) {
              console.error("ファイルのインポート中にエラーが発生しました:", error);
              alert("ファイルのインポートに失敗しました。ファイル形式が正しいか確認してください。");
            } finally {
              importFileInput.value = '';
            }
          };
          reader.onerror = () => {
            console.error("ファイルの読み込み中にエラーが発生しました。");
            alert("ファイルの読み込みに失敗しました。");
            importFileInput.value = '';
          };
          reader.readAsText(file);
        });
      }
      if (alignHorizontalBtn) {
        alignHorizontalBtn.addEventListener('click', () => {
          performAlignment('horizontal');
          closeModal(alignOptionsModal);
        });
      }

      if (alignVerticalBtn) {
        alignVerticalBtn.addEventListener('click', () => {
          performAlignment('vertical');
          closeModal(alignOptionsModal);
        });
      }

      if (alignOptionsModalCancelBtn) {
        alignOptionsModalCancelBtn.addEventListener('click', () => {
          closeModal(alignOptionsModal);
        });
      }

      if (templateSelect) {
        templateSelect.addEventListener('change', () => {
          templateUploadedImages = [];
          if (templateImagePreviews) templateImagePreviews.innerHTML = '';
          if (templateImageUpload) templateImageUpload.value = '';
          updateTemplateUI();
        });
      }

      if (templateImageUpload) {
        templateImageUpload.addEventListener('change', async (event) => {
          if (!selectedTemplate) return;
          const files = event.target.files;
          templateUploadedImages = [];
          templateImagePreviews.innerHTML = '';
          addFromTemplateButton.disabled = true;

          if (!files || files.length === 0) {
            updateTemplateUI();
            return;
          }

          const loadImage = async (file) => { /* ... (省略: imageCollectionUpload と同様の実装) ... */ };

          const loadedImagesPromises = [];
          for (let i = 0; i < files.length; i++) {
            if (templateUploadedImages.length >= selectedTemplate.maxImages && files.length > selectedTemplate.maxImages) {
              alert(`選択できる画像は最大 ${selectedTemplate.maxImages} 枚です。超過分は無視されます。`);
              break;
            }
            loadedImagesPromises.push(
              new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e_reader) => {
                  const imgDataUrl = e_reader.target.result;
                  const img = new Image();
                  img.onload = () => resolve({ img, imgDataUrl, fileName: files[i].name });
                  img.onerror = () => resolve(null);
                  img.src = imgDataUrl;
                };
                reader.onerror = () => resolve(null);
                reader.readAsDataURL(files[i]);
              })
            );
          }

          const results = await Promise.all(loadedImagesPromises);
          templateUploadedImages = results.filter(r => r !== null);

          templateImagePreviews.innerHTML = '';
          templateUploadedImages.forEach((imgData, index) => {
            const previewElement = document.createElement('img');
            previewElement.src = imgData.imgDataUrl;
            previewElement.title = imgData.fileName;
            previewElement.style.width = '40px';
            previewElement.style.height = '40px';
            previewElement.style.objectFit = 'contain';
            previewElement.style.border = '1px solid #ddd';
            templateImagePreviews.appendChild(previewElement);
          });

          updateTemplateUI();
        });
      }

      if (addFromTemplateButton) {
        addFromTemplateButton.addEventListener('click', () => {
          if (!selectedTemplate || !selectedTemplate.layout || templateUploadedImages.length !== selectedTemplate.maxImages) {
            alert("テンプレートと正しい枚数の画像を選択してください。");
            return;
          }

          const layout = selectedTemplate.layout;
          const newUnitsFromTemplate = [];
          const newConnectionsFromTemplate = [];
          const tempIdToNewIdMap = {}; // テンプレート内のtempIdと実際のユニットIDの対応表

          const canvasCenterX = (-originX + (mainCanvasArea.clientWidth / 2)) / scale;
          const canvasCenterY = (-originY + (mainCanvasArea.clientHeight / 2)) / scale;
          const gridSize = layout.gridSize || UNIT_WIDTH_ONE_SLOT * 1.5; // デフォルトのグリッドサイズ

          // 1. ユニットを生成
          layout.units.forEach(unitDef => {
            const newUnitId = `item-${nextItemId++}`;
            tempIdToNewIdMap[unitDef.tempId] = newUnitId;

            const unitSlotsData = {};
            const activeSlotKeysForUnit = [];
            let imageForThisUnitFound = false;

            for (const slotName in unitDef.slotMapping) {
              const imageIndex = unitDef.slotMapping[slotName];
              if (imageIndex >= 0 && imageIndex < templateUploadedImages.length) {
                const imgData = templateUploadedImages[imageIndex];
                unitSlotsData[slotName] = {
                  img: imgData.img,
                  imgDataUrl: imgData.imgDataUrl,
                  originalDataUrl: imgData.imgDataUrl,
                  fileName: imgData.fileName,
                  name: '',
                  food: '未選択',
                  order: null
                };
                activeSlotKeysForUnit.push(slotName);
                imageForThisUnitFound = true;
              } else {
                unitSlotsData[slotName] = null;
              }
            }

            if (!imageForThisUnitFound && Object.keys(unitDef.slotMapping).length > 0) {
              console.warn(`テンプレートユニット「${unitDef.tempId}」に割り当てる画像が見つかりませんでした。`);
              return;
            }


            let unitWidth = layout.defaultWidth || UNIT_WIDTH_ONE_SLOT;
            if (activeSlotKeysForUnit.length === 1) unitWidth = UNIT_WIDTH_ONE_SLOT;
            else if (activeSlotKeysForUnit.length === 2) unitWidth = UNIT_WIDTH_TWO_SLOTS;
            else if (activeSlotKeysForUnit.length >= 3) unitWidth = UNIT_WIDTH_THREE_SLOTS;

            const unitHeight = calculateUnitHeight(unitSlotsData) * (layout.defaultHeightMultiplier || 1);

            newUnitsFromTemplate.push({
              id: newUnitId,
              type: layout.unitType || 'unit',
              slots: unitSlotsData,
              x: canvasCenterX + (unitDef.xOffset * gridSize) - (unitWidth / 2),
              y: canvasCenterY + (unitDef.yOffset * gridSize) - (unitHeight / 2),
              width: unitWidth,
              height: unitHeight,
              isSelected: false,
              borderVisible: true,
              activeSlotKeys: activeSlotKeysForUnit,
              isMonocolor: false,
              isTargetIndividual: false
            });
          });

          // 2. 接続線を生成
          layout.connections.forEach(connDef => {
            const fromUnitId = tempIdToNewIdMap[connDef.from];
            const toUnitId = tempIdToNewIdMap[connDef.to];
            if (fromUnitId && toUnitId) {
              newConnectionsFromTemplate.push({
                id: `conn-${nextItemId++}`,
                fromId: fromUnitId,
                toId: toUnitId,
                color: '#555555', // デフォルト色
                lineWidth: 10,    // デフォルト太さ
                dashArray: []     // デフォルト実線
              });
            }
          });

          // 3. 生成されたユニットと接続線をグローバル配列に追加
          if (newUnitsFromTemplate.length > 0) {
            units.push(...newUnitsFromTemplate);
          }
          if (newConnectionsFromTemplate.length > 0) {
            connections.push(...newConnectionsFromTemplate);
          }

          // 4. 状態を保存し、キャンバスを再描画
          if (newUnitsFromTemplate.length > 0 || newConnectionsFromTemplate.length > 0) {
            saveState();
            drawCanvas();
            updateInfoModal();
            showStatusBar(`「${selectedTemplate.name}」テンプレートを家系図に追加しました。`, addFromTemplateButton);
          } else {
            alert("テンプレートからユニットを生成できませんでした。画像選択やテンプレート定義を確認してください。");
          }

          // 処理後はリセット
          templateSelect.value = "";
          selectedTemplate = null;
          templateUploadedImages = [];
          templateImagePreviews.innerHTML = '';
          templateImageUpload.value = '';
          updateTemplateUI();
        });
      }

      if (showToolInfoModalButton) {
        showToolInfoModalButton.addEventListener('click', () => {
          toolInfoModalBody.innerHTML = `
            <style>
              #tool-info-modal-body h4 { font-size: 1.1em; margin-top: 1.5em; margin-bottom: 0.5em; color: #333; border-bottom: 1px solid #ddd; padding-bottom: 0.3em;}
              #tool-info-modal-body h5 { font-size: 1em; margin-top: 1em; margin-bottom: 0.3em; color: #444;}
              #tool-info-modal-body p, #tool-info-modal-body ul { margin-bottom: 0.8em; line-height: 1.6; font-size: 0.9em; }
              #tool-info-modal-body ul { padding-left: 20px; }
              #tool-info-modal-body li { margin-bottom: 0.3em; }
              #tool-info-modal-body strong { color: #0056b3; }
            </style>
            <h4>「ユニット」について</h4>
            <p>このツール内では家系図内で枠で囲まれる1まとまりのことを指します(他に呼び名を思いつきませんでした)。</p>

            <h4>テンプレートから追加</h4>
            <p>家系図に含める画像を順番に選択すると家系図が完成します。一つ一つ画像を追加する手間を省くことが出来ます。</p>

            <h4>出生スロット、QRコード1、QRコード2</h4>
            <p>横移動やオリジナルなど、テンプレートが必要ない場合はここからユニットを追加してください。入居順の設定が無く推奨捕獲順機能を使う場合はQRコード1が先、QRコード2が後とみなします。</p>

            <h4>テキスト追加</h4>
            <p>家系図内に文字を追加します。文字の大きさや色を変更することもできます。長文の場合は改行を推奨します。</p>

            <h4>戻る・進む</h4>
            <p>作業の進捗状況を操作できます。また、ややこしいですが描画モード中は別途「描画戻る」「描画進む」ボタンを使用してください。</p>

            <h4>接続</h4>
            <p>ユニット同士、またはユニットと線同士を線で結びます。</p>

            <h4>編集</h4>
            <p>選択したユニットの情報を編集できます。また、「目標個体」の設定もここですることができます。</p>

            <h4>まとめる</h4>
            <p>選択したユニットをさらに1つのかたまりとして扱います。</p>

            <h4>サイズ統一</h4>
            <p>選択したユニットの大きさを基準として他のユニットのサイズを統一します。</p>

            <h4>整列</h4>
            <p>最初に選択したユニットを基準として、他に選択したユニットの位置を横か縦どちらかに統一します。</p>

            <h4>描画</h4>
            <p>指やマウスで線を引いたり図形を追加できます。</p>

            <h4>保存</h4>
            <p>完成した家系図はこのボタンから保存してください。写真アプリに保存する場合は長押しで、ファイルアプリに保存する場合は「ファイルとしてダウンロード」ボタンから保存してください。</p>

            <h4>－と＋</h4>
            <p>家系図を拡大・縮小できます。このボタンからでなくても、指で拡大・縮小することもできます。</p>

            <h4>データクリア</h4>
            <p>ここまでの進行状況を消去し、1からやり直します。「戻る」「進む」ボタンでも元に戻すことが出来ないので注意してください。</p>

            <h4>エクスポート</h4>
            <p>このボタンを押したら出てくる画面に表示されるボタンから、ファイルアプリに家系図のデータを保存します(JSONファイル)。家系図の画像ではなくデータを保存します。</p>

            <h4>インポート</h4>
            <p>エクスポートで保存したファイルを読み込むことで、作業を再開・他者と共有することができます。</p>

            <h4>家系図情報</h4>
            <p>目標の個体を作るのに必要なゴールドを計算したり、好物を設定している場合は必要な作物の種の数をカウントする機能もついています。家系図を保存する際、この欄も一緒に保存されます。</p>
          `;
          openModal(toolInfoModal);
        });
      }

      if (toolInfoModalCloseButtonHeader) {
        toolInfoModalCloseButtonHeader.addEventListener('click', () => closeModal(toolInfoModal));
      }
      if (toolInfoModalCloseButtonFooter) {
        toolInfoModalCloseButtonFooter.addEventListener('click', () => closeModal(toolInfoModal));
      }


      // ========================================
      // 6. 初期化処理呼び出し
      // ========================================
      checkAddUnitButtonState();
      checkAddTextButtonState();
      checkAddImageCollectionButtonState();
      historyIndex = -1;

      async function initializeApp() {
        console.log("アプリケーション初期化開始");
        let restored = false;
        try {
          const savedStateString = localStorage.getItem('kakeizuToolState');
          if (savedStateString) {
            console.log("ローカルストレージから状態を復元します...");
            const savedState = JSON.parse(savedStateString);
            await restoreState(savedState);
            if (savedState.scale !== undefined) scale = savedState.scale;
            if (savedState.originX !== undefined) originX = savedState.originX;
            if (savedState.originY !== undefined) originY = savedState.originY;
            if (savedState.zoomLevel !== undefined) zoomLevel = savedState.zoomLevel;
            zoomLevelIndicator.textContent = zoomLevel;

            history = [savedState];
            historyIndex = 0;

            console.log("状態の復元が完了しました。");
            restored = true;
          } else {
            console.log("保存された状態は見つかりませんでした。新規作成します。");
            history = [];
            historyIndex = -1;
          }
        } catch (e) {
          console.error("ローカルストレージからの状態復元に失敗しました:", e);
          history = [];
          historyIndex = -1;
        }

        updateUndoRedoButtons();

        requestAnimationFrame(() => {
          console.log(restored ? "復元後の初回描画" : "新規作成時の初回描画");
          resizeCanvas();
          updateInfoModal();
          updateFillOptionVisibility();
          resetDrawingHistory();
        });
      }
      initializeTemplateSelector();
      updateTemplateUI();
      initializeApp();
      adjustLayoutHeight();
      window.addEventListener('resize', adjustLayoutHeight);
      window.addEventListener('orientationchange', adjustLayoutHeight);
      let scrollTimeout;
      window.addEventListener('scroll', () => {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(adjustLayoutHeight, 150);
      }, { passive: true });
      console.log("最終的なボタン初期表示設定 開始");
      if (leftPanel.classList.contains('collapsed')) {
        leftPanelToggleButton.innerHTML = '＞';
        leftPanelToggleButton.title = "左パネルを展開";
        leftPanelToggleButton.style.left = '0px';
        leftPanelToggleButton.classList.add('panel-is-closed');
        leftPanelToggleButton.classList.remove('panel-is-open');
        console.log("最終初期状態: パネルは収納");
      } else {
        leftPanelToggleButton.innerHTML = '＜';
        leftPanelToggleButton.title = "左パネルを収納";
        leftPanelToggleButton.style.left = `${leftPanel.offsetWidth}px`;
        leftPanelToggleButton.classList.add('panel-is-open');
        leftPanelToggleButton.classList.remove('panel-is-closed');
        console.log("最終初期状態: パネルは展開、ボタンleft:", leftPanelToggleButton.style.left, "パネル幅:", leftPanel.offsetWidth);
      }

    }); // DOMContentLoaded の終わり
  </script>
</body>

</html>
