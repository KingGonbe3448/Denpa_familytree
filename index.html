<!DOCTYPE html>
<html lang="ja">

<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-12G89V2JF3"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-12G89V2JF3');
  </script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>電波人間 家系図ツール</title>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet">
  <style>
    /* --- Base Styles --- */
    body,
    html {
      margin: 0;
      padding: 0;
      font-family: 'Noto Sans JP', sans-serif;
      /*height: 100%;*/
      background-color: #f4f4f4;
      color: #333;
      touch-action: manipulation;
      -ms-touch-action: manipulation;
    }

    .container {
      display: flex;
      flex-direction: column;
      position: relative;
      overflow: hidden;
    }

    .top-area {
      display: flex;
      flex-grow: 1;
      overflow: hidden;
      position: relative;
    }

    /* --- Left Panel --- */
    #left-panel-toggle-button {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      z-index: 1010;
      color: white;
      border: none;
      padding: 25px 15px;
      cursor: pointer;
      font-size: 1em;
      line-height: 1;
      box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
      transition: left 0.3s ease, background-color 0.3s ease, border-radius 0.3s ease;
      left: 340px;
      background-color: #007bff;
      border-top-left-radius: 5px;
      border-bottom-left-radius: 5px;
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #left-panel-toggle-button.panel-is-closed {
      left: 0px !important;
      background-color: #007bff;
      border-top-right-radius: 5px;
      border-bottom-right-radius: 5px;
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
    }

    .left-panel {
      width: 340px;
      min-width: 340px;
      padding: 15px;
      background-color: #fff;
      border-right: 1px solid #ddd;
      overflow-y: auto;
      box-shadow: 2px 0 5px rgba(0, 0, 0, 0.05);
      display: flex;
      flex-direction: column;
      gap: 15px;
      z-index: 1005;
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      transform: translateX(0%);
      transition: transform 0.3s ease;
    }

    .left-panel.collapsed {
      transform: translateX(-100%);
    }

    .left-panel h2,
    .left-panel h3 {
      margin-top: 0;
      margin-bottom: 10px;
      color: #555;
      border-bottom: 1px solid #eee;
      padding-bottom: 5px;
    }

    .left-panel .panel-section small {
      display: block;
      font-size: 0.75em;
      color: #6c757d;
      margin-bottom: 10px;
      line-height: 1.4;
    }


    .left-panel .panel-section {
      background-color: #f9f9f9;
      padding: 12px;
      border-radius: 8px;
      border: 1px solid #eee;
      margin-bottom: 15px;
    }

    .left-panel .image-slot-group {
      border: 1px solid #e0e0e0;
      padding: 10px;
      margin-bottom: 15px;
      border-radius: 6px;
      background-color: #fff;
    }

    .left-panel .image-slot-group h4 {
      margin-top: 0;
      margin-bottom: 8px;
      font-size: 0.95em;
      color: #333;
    }

    .left-panel .file-input-wrapper {
      display: flex;
      flex-direction: column;
      margin-bottom: 5px;
      padding-left: 0;
    }

    .left-panel .file-input-wrapper .file-input-label {
      font-weight: bold;
      font-size: 0.8em;
      margin-bottom: 3px;
      text-align: left;
    }

    .left-panel .file-input-controls {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .left-panel .file-input-controls input[type="file"] {
      flex-grow: 1;
      font-size: 0.7em;
      padding: 4px;
      border: 1px solid #ccc;
      border-radius: 4px;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      max-width: calc(100% - 50px);
      color: #888;
    }

    .left-panel .file-input-controls input[type="file"]::file-selector-button {
      font-size: 0.9em;
      padding: 2px 6px;
      margin-right: 5px;
    }

    .left-panel .file-input-controls input[type="file"]:not(:placeholder-shown) {
      color: #333;
    }

    .left-panel .clear-image-button {
      padding: 4px 8px;
      font-size: 0.7em;
      background-color: #f8f9fa;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
      line-height: 1;
      height: fit-content;
      flex-shrink: 0;
    }

    .left-panel .clear-image-button:hover {
      background-color: #e9ecef;
    }

    .left-panel .clear-image-button.hidden {
      display: none;
    }


    .left-panel img.preview-image {
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #fff;
      display: block;
      margin: 8px auto;
      max-width: calc(100% - 16px);
      max-height: 60px;
      object-fit: contain;
    }

    .left-panel .post-preview-edit-button {
      display: block;
      width: calc(100% - 0px);
      margin: 5px 0 10px 0;
      padding: 5px 10px;
      font-size: 0.8em;
      background-color: #5bc0de;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .left-panel .post-preview-edit-button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    .left-panel .form-group {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      padding-left: 0;
    }

    .left-panel .form-group label {
      flex-basis: 70px;
      flex-shrink: 0;
      font-weight: bold;
      font-size: 0.8em;
      margin-bottom: 0;
      text-align: right;
    }

    .left-panel .form-group input[type="text"],
    .left-panel .form-group select,
    .left-panel .form-group textarea {
      flex-grow: 1;
      padding: 6px 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 0.85em;
      box-sizing: border-box;
      margin-bottom: 0;
      width: auto;
    }


    .left-panel .form-group input[type="color"] {
      padding: 2px;
      height: 30px;
      flex-basis: 50px;
      min-width: 50px;
    }

    .left-panel .form-group input[type="number"] {
      width: 60px;
      flex-grow: 0;
    }


    .left-panel .order-checkbox-group {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-bottom: 8px;
      padding-left: 0;
      font-size: 0.75em;
    }

    .left-panel .order-checkbox-group .order-label {
      font-weight: bold;
      margin-right: 5px;
      flex-basis: auto;
      white-space: nowrap;
      text-align: right;
    }

    .left-panel .order-checkbox-group label {
      font-weight: normal;
      margin-right: 5px;
    }

    .left-panel .order-checkbox-group input[type="checkbox"] {
      margin-right: 1px;
    }

    .left-panel .form-group-checkbox {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      padding-left: 0;
    }

    .left-panel .form-group-checkbox label {
      flex-basis: auto;
      flex-shrink: 1;
      text-align: left;
      font-weight: normal;
      font-size: 0.85em;
    }

    #add-unit-border-visible-group label,
    #add-text-border-visible-group label,
    #image-collection-border-group label {
      flex-basis: 70px;
      flex-shrink: 0;
      font-weight: bold;
      font-size: 0.8em;
      text-align: right;
    }


    .left-panel .form-group-checkbox input[type="checkbox"] {
      margin-right: 1px;
    }


    .left-panel button.action-button {
      display: block;
      width: 100%;
      padding: 12px 15px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1em;
      transition: background-color 0.2s;
      margin-top: 15px;
    }

    .left-panel button.action-button:hover:not(:disabled) {
      background-color: #0056b3;
    }

    .left-panel button.action-button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    #image-collection-previews {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 10px;
      max-height: 150px;
      overflow-y: auto;
      border: 1px dashed #eee;
      padding: 5px;
      background-color: #f0f0f0;
    }

    #image-collection-previews img {
      width: 40px;
      height: 40px;
      object-fit: contain;
      border: 1px solid #ddd;
      background-color: white;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.2s;
    }

    #image-collection-previews img.selected-preview {
      opacity: 1.0;
      border-color: #007bff;
      box-shadow: 0 0 3px rgba(0, 123, 255, 0.5);
    }

    #image-collection-details {
      margin-top: 15px;
      border-top: 1px solid #eee;
      padding-top: 15px;
      max-height: 200px;
      overflow-y: auto;
    }

    #image-collection-details .detail-item {
      border: 1px dashed #ccc;
      padding: 8px;
      margin-bottom: 10px;
      border-radius: 4px;
      background-color: #fff;
    }

    #image-collection-details .detail-item p {
      font-size: 0.8em;
      margin: 0 0 5px 0;
      word-break: break-all;
      color: #555;
    }

    #image-collection-details .detail-item .form-group label {
      flex-basis: 50px;
    }

    #image-collection-details .detail-item .form-group input[type="text"] {
      font-size: 0.8em;
      padding: 4px 5px;
    }

    #image-collection-details .detail-item .form-group select {
      font-size: 0.8em;
      padding: 4px 5px;
    }


    /* --- Status Bar --- */
    #status-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      color: white;
      padding: 8px 15px;
      font-size: 0.9em;
      text-align: center;
      z-index: 1000;
      display: none;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      transition: background-color 0.3s ease;
    }

    /* --- Main Canvas Area --- */
    .main-canvas-area {
      flex-grow: 1;
      position: relative;
      overflow: auto;
      background-color: #e0e0e0;
    }

    #family-tree-canvas {
      display: block;
      background-color: #fdfdfd;
      cursor: grab;
    }

    #family-tree-canvas.dragging,
    #family-tree-canvas.connecting,
    #family-tree-canvas.grouping {
      cursor: grabbing;
    }

    #family-tree-canvas.mode-active {
      cursor: crosshair;
    }

    #family-tree-canvas.edit-mode {
      cursor: pointer;
    }

    /* --- Bottom Controls --- */
    .bottom-controls {
      padding: 8px 10px;
      background-color: #fff;
      border-top: 1px solid #ddd;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.05);
      flex-wrap: wrap;
      flex-shrink: 0;
      flex-wrap: nowrap;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      justify-content: flex-start;
      padding-bottom: calc(8px + env(safe-area-inset-bottom));
    }

    .bottom-controls button {
      padding: 8px 10px;
      background-color: #555;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.85em;
      min-width: 70px;
      transition: background-color 0.2s;
    }

    .bottom-controls button:hover:not(:disabled) {
      filter: brightness(1.2);
    }

    .bottom-controls button:disabled {
      filter: grayscale(50%);
      cursor: not-allowed;
      opacity: 0.7;
    }


    .bottom-controls button.active-mode-button {
      background-color: #dc3545 !important;
      color: white;
    }

    .bottom-controls button.active-mode-button:disabled {
      background-color: #f5c6cb !important;
      color: #721c24;
      filter: none;
      opacity: 0.8;
    }


    .bottom-controls button#undo-button,
    .bottom-controls button#redo-button {
      background-color: #ffc107;
      color: #333;
    }

    .bottom-controls button#undo-button:disabled,
    .bottom-controls button#redo-button:disabled {
      background-color: #ffeeba;
      color: #856404;
    }

    .bottom-controls button#connect-button {
      background-color: #17a2b8;
    }

    .bottom-controls button#edit-unit-button {
      background-color: #fd7e14;
    }

    .bottom-controls button#group-button {
      background-color: #6f42c1;
    }

    .bottom-controls button#unify-size-button {
      background-color: #20c997;
    }

    .bottom-controls button#align-button {
      background-color: #6A5ACD;
    }

    .bottom-controls button#draw-mode-button {
      background-color: #DA70D6;
    }

    .bottom-controls button#save-canvas-button {
      background-color: #28a745;
    }

    .bottom-controls button#zoom-in-button,
    .bottom-controls button#zoom-out-button {
      background-color: #6c757d;
    }

    #zoom-level-indicator {
      display: inline-block;
      min-width: 30px;
      padding: 0 5px;
      font-size: 0.9em;
      font-weight: bold;
      text-align: center;
      color: #555;
      border: 1px solid #ccc;
      border-radius: 4px;
      margin: 0 5px;
      line-height: 1.5;
    }

    /* --- Info Button --- */
    #info-button-container {
      position: fixed;
      top: 10px;
      right: 15px;
      z-index: 1001;
      transition: top 0.3s ease;
    }

    #info-button-container button {
      padding: 8px 12px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    /* --- Modal Styles --- */
    .modal-overlay {
      display: none;
      position: fixed;
      z-index: 1040;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
    }

    .modal {
      display: none;
      position: fixed;
      z-index: 1050;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background-color: #fff;
      padding: 20px;
      border: 1px solid #888;
      width: 80%;
      max-width: 500px;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      max-height: 90vh;
      overflow-y: auto;
    }

    #unit-edit-modal {
      z-index: 1050;
    }

    #cropper-modal {
      z-index: 1060;
    }

    #text-edit-modal {
      z-index: 1050;
    }


    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
      margin-bottom: 15px;
    }

    .modal-header h2 {
      margin: 0;
      font-size: 1.2em;
    }

    .modal-close-button {
      color: #aaa;
      font-size: 28px;
      font-weight: bold;
      background: none;
      border: none;
      cursor: pointer;
    }

    .modal-close-button:hover,
    .modal-close-button:focus {
      color: black;
    }

    .modal-body {
      padding-bottom: 15px;
    }

    .modal-footer {
      border-top: 1px solid #eee;
      padding-top: 15px;
      text-align: right;
    }

    .modal-footer button {
      padding: 8px 15px;
      margin-left: 10px;
      border-radius: 4px;
      cursor: pointer;
    }

    .modal-footer button.primary {
      background-color: #007bff;
      color: white;
      border: none;
    }

    .modal-footer button.secondary {
      background-color: #6c757d;
      color: white;
      border: none;
    }

    .modal-footer button.danger {
      background-color: #dc3545;
      color: white;
      border: none;
    }

    .modal-footer button.duplicate {
      background-color: #17a2b8;
      color: white;
      border: none;
    }

    .modal-footer button.duplicate:hover {
      background-color: #117a8b;
    }

    /* --- Cropper Modal Specific --- */
    #cropper-modal-content img {
      max-width: 100%;
      display: block;
    }

    #cropper-modal-controls {
      margin-top: 15px;
      text-align: center;
    }

    #cropper-modal-controls button,
    #cropper-modal-controls select {
      margin: 0 5px;
      padding: 8px 12px;
    }

    #cropper-zoom-controls {
      margin-top: 10px;
      text-align: center;
    }

    #cropper-zoom-controls button {
      font-size: 0.8em;
      padding: 5px 8px;
      margin: 2px;
    }

    /* --- Edit Modals Specific --- */
    #unit-edit-modal .form-group,
    #group-edit-modal .form-group,
    #text-edit-modal .form-group {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }

    #unit-edit-modal .form-group label,
    #group-edit-modal .form-group label,
    #text-edit-modal .form-group label {
      width: 100px;
      margin-right: 10px;
      text-align: right;
      font-size: 0.9em;
      flex-shrink: 0;
    }

    #unit-edit-modal .form-group input,
    #unit-edit-modal .form-group select,
    #group-edit-modal .form-group input,
    #text-edit-modal .form-group input,
    #text-edit-modal .form-group select,
    #text-edit-modal .form-group textarea {
      flex-grow: 1;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    #text-edit-modal .form-group input[type="color"] {
      padding: 2px;
      height: 30px;
      flex-basis: 50px;
      min-width: 50px;
    }

    #text-edit-modal .form-group input[type="number"] {
      width: 70px;
      flex-grow: 0;
    }


    #unit-edit-modal .slot-edit-section {
      border: 1px dashed #ccc;
      padding: 10px;
      margin-bottom: 10px;
      border-radius: 4px;
    }

    #unit-edit-modal .slot-edit-section h5 {
      margin-top: 0;
    }

    #unit-edit-modal .slot-edit-section img {
      max-width: 100px;
      max-height: 50px;
      display: block;
      margin-bottom: 5px;
    }

    #unit-edit-modal .slot-edit-section button {
      font-size: 0.8em;
      padding: 4px 8px;
      margin-top: 5px;
    }

    #unit-edit-modal .order-checkbox-group {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-bottom: 8px;
      padding-left: 0;
      font-size: 0.75em;
    }

    #unit-edit-modal .order-checkbox-group .order-label {
      font-weight: bold;
      margin-right: 5px;
      flex-basis: auto;
      white-space: nowrap;
      text-align: right;
    }

    #unit-edit-modal .order-checkbox-group label:not(.order-label) {
      font-weight: normal;
      margin-right: 5px;
    }

    #unit-edit-modal .order-checkbox-group input[type="checkbox"] {
      margin-right: 1px;
    }

    .form-group-checkbox {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }

    .form-group-checkbox label {
      width: 100px;
      margin-right: 10px;
      text-align: right;
      font-size: 0.9em;
      flex-shrink: 0;
    }

    .form-group-checkbox input[type="checkbox"] {
      margin-right: 5px;
    }


    /* --- Info Modal Specific --- */
    #info-modal .crop-list-item {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }

    .crop-color-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
      display: inline-block;
    }

    /* --- Responsive --- */
    @media (max-width: 768px) {
      .bottom-controls {
        height: auto;
        padding-top: 10px;
        padding-left: 10px;
        padding-right: 10px;
        padding-bottom: calc(10px + env(safe-area-inset-bottom));
        justify-content: space-around;
      }

      .bottom-controls button {
        font-size: 0.8em;
        min-width: 60px;
        padding: 6px 8px;
        margin-bottom: 5px;
      }

      .bottom-controls button:disabled {
        filter: grayscale(50%);
        cursor: not-allowed;
        opacity: 0.7;
      }

      .bottom-controls button.active-mode-button:disabled {
        background-color: #f5c6cb !important;
        color: #721c24;
        filter: none;
        opacity: 0.8;
      }

      .bottom-controls button#undo-button:disabled,
      .bottom-controls button#redo-button:disabled {
        background-color: #ffeeba;
        color: #856404;
      }


      #info-button-container {
        top: 5px;
        right: 10px;
      }

      #info-button-container button {
        padding: 6px 10px;
        font-size: 0.9em;
      }

      .modal {
        width: 90%;
        max-width: 90%;
      }
    }

    .accordion-section {
      border: 1px solid #eee;
      border-radius: 4px;
      margin-bottom: 15px;
      background-color: #fdfdfd;
    }

    .accordion-header {
      padding: 10px;
      cursor: pointer;
      font-weight: bold;
      background-color: #f7f7f7;
      border-bottom: 1px solid #eee;
      list-style: none;
      /* summaryのデフォルトマーカーを消す */
    }

    .accordion-header::-webkit-details-marker {
      display: none;
    }

    /* Chrome/Safariのマーカーを消す */
    .accordion-header::before {
      /* 簡単な開閉アイコン */
      content: '▶ ';
      font-size: 0.8em;
      margin-right: 5px;
      display: inline-block;
      transition: transform 0.2s ease-in-out;
    }

    details[open]>summary.accordion-header::before {
      transform: rotate(90deg);
    }

    .accordion-content {
      padding: 15px;
      border-top: 1px solid #eee;
      /* ヘッダーとの境界線 */
    }

    .accordion-content .form-group {
      margin-bottom: 12px;
      /* 設定項目間のスペース */
    }

    .accordion-content .form-group label {
      width: 100px;
      /* ラベル幅を少し広げる */
    }

    .accordion-content small {
      margin-left: 8px;
      font-size: 0.8em;
      color: #777;
    }

    /* 画像集合ユニット編集モーダルのリストスタイル */
    #collection-edit-image-list li {
      display: flex;
      align-items: center;
      border: 1px solid #eee;
      padding: 8px;
      margin-bottom: 8px;
      border-radius: 4px;
      background-color: #f9f9f9;
      cursor: grab;
      /* ドラッグ可能を示すカーソル */
    }

    #collection-edit-image-list li.dragging {
      /* ドラッグ中のスタイル */
      opacity: 0.5;
      background-color: #e0e0e0;
    }

    /* 削除マーク用スタイル (オプション) */
    #collection-edit-image-list li[data-deleted="true"] {
      opacity: 0.5;
      text-decoration: line-through;
      background-color: #ffe0e0;
    }


    #collection-edit-image-list img {
      width: 40px;
      height: 40px;
      object-fit: contain;
      border: 1px solid #ddd;
      margin-right: 10px;
      background-color: white;
    }

    #collection-edit-image-list .image-details {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      gap: 5px;
      /* 詳細項目間のギャップ */
    }

    #collection-edit-image-list .image-details p {
      margin: 0;
      font-size: 0.75em;
      color: #666;
      word-break: break-all;
      /* ファイル名が長い場合 */
    }

    #collection-edit-image-list .detail-form-group {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    #collection-edit-image-list .detail-form-group label {
      font-size: 0.8em;
      width: 40px;
      /* ラベル幅を調整 */
      text-align: right;
      flex-shrink: 0;
    }

    #collection-edit-image-list .detail-form-group input[type="text"],
    #collection-edit-image-list .detail-form-group select {
      font-size: 0.8em;
      padding: 3px 4px;
      border: 1px solid #ccc;
      border-radius: 3px;
      flex-grow: 1;
    }

    #collection-edit-image-list .delete-image-btn {
      background: none;
      border: none;
      color: #dc3545;
      font-size: 1.2em;
      cursor: pointer;
      padding: 5px;
      margin-left: 10px;
    }

    #collection-edit-image-list .delete-image-btn:hover {
      color: #a71d2a;
    }

    .checkbox-row-container {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .checkbox-item-container {
      display: flex;
      align-items: center;
      margin-right: 20px;
    }

    .checkbox-item-container:last-child {
      margin-right: 0;
    }

    .checkbox-item-container input[type="checkbox"] {
      margin-right: 4px;
    }

    .checkbox-item-container label {
      font-weight: normal;
      white-space: nowrap;
    }

    .capture-phase {
      border: 1px solid #e0e0e0;
      border-radius: 5px;
      margin-bottom: 12px;
      padding: 12px;
      background-color: #f9f9f9;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }

    .capture-phase h5 {
      margin-top: 0;
      margin-bottom: 10px;
      color: #2c3e50;
      border-bottom: 1px solid #ecf0f1;
      padding-bottom: 6px;
      font-size: 1.05em;
    }

    .capture-phase ul {
      list-style-type: none;
      padding-left: 0;
      margin-bottom: 0;
    }

    .capture-phase li {
      padding: 10px 5px;
      border-bottom: 1px dashed #ecf0f1;
      display: flex;
      /* flexboxで画像とテキストを横並び */
      align-items: center;
      /* 上下中央揃え */
    }

    .capture-phase li:last-child {
      border-bottom: none;
    }

    .capture-phase li img {
      /* renderCaptureList内のスタイル指定をこちらに集約しても良い */
      flex-shrink: 0;
      /* 画像が縮まないように */
    }

    .capture-phase li div {
      /* テキストコンテンツを囲むdivを追加する場合 */
      margin-left: 10px;
    }

    .capture-phase li strong {
      font-size: 0.95em;
    }

    .capture-phase li small {
      font-size: 0.8em;
      display: block;
      margin-top: 2px;
    }

    .drawing-undo-redo-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      margin-bottom: 5px;
    }

    .drawing-undo-redo-controls button {
      flex-grow: 1;
      font-size: 0.85em;
      padding: 6px 10px;
      background-color: #6c757d;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .drawing-undo-redo-controls button:hover:not(:disabled) {
      filter: brightness(1.15);
    }

    .drawing-undo-redo-controls button:disabled {
      background-color: #adb5bd;
      cursor: not-allowed;
      opacity: 0.7;
    }
  </style>
</head>

<body>
  <div id="status-bar">ステータスメッセージがここに表示されます</div>
  <div class="modal-overlay" id="modal-overlay"></div>

  <div class="container">
    <div class="top-area">
      <button id="left-panel-toggle-button" title="左パネルを開閉">＜</button>
      <div class="left-panel" id="left-panel">
        <div class="panel-section upload-main-section">
          <h2>ユニット追加</h2>
        </div>

        <div class="panel-section template-add-section">
          <h3>テンプレートから追加</h3>
          <div class="form-group">
            <label for="template-select">テンプレート:</label>
            <select id="template-select">
              <option value="">選択してください</option>
              <!-- JavaScriptでテンプレート名をここに追加 -->
            </select>
          </div>
          <div class="file-input-wrapper">
            <label class="file-input-label" for="template-image-upload">画像を一括選択:</label>
            <div class="file-input-controls">
              <input type="file" id="template-image-upload" accept="image/*" multiple disabled>
              <!-- 初期状態はdisabled -->
            </div>
          </div>
          <small id="template-image-info">テンプレートを選択すると、必要な画像枚数が表示されます。</small>
          <div id="template-image-previews"
            style="display: flex; flex-wrap: wrap; gap: 5px; margin-top: 10px; max-height: 100px; overflow-y: auto; border: 1px dashed #eee; padding: 5px; background-color: #f0f0f0;">
            <!-- 選択された画像のプレビューがここに表示される -->
          </div>
          <button id="add-from-template-button" class="action-button" disabled
            style="margin-top: 10px;">テンプレートをキャンバスに追加</button>
        </div>

        <div class="image-slot-group">
          <h4>出生スロット</h4>
          <div class="file-input-wrapper">
            <label class="file-input-label" for="birth-image-upload">画像を選択:</label>
            <div class="file-input-controls">
              <input type="file" id="birth-image-upload" accept="image/*">
              <button class="clear-image-button hidden" id="clear-birth-image-button" title="画像をクリア">×</button>
            </div>
          </div>
          <img id="birth-image-preview" src="#" alt="出生画像プレビュー" class="preview-image" style="display:none;">
          <button class="post-preview-edit-button" id="edit-birth-image-button" disabled>この画像を編集</button>
          <div class="form-group">
            <label for="birth-name">名前:</label>
            <input type="text" id="birth-name" maxlength="10" placeholder="名前を入力(任意)">
          </div>
          <div class="form-group">
            <label for="birth-favorite-food">好物:</label>
            <select id="birth-favorite-food">
              <option value="未選択">選択してください(任意)</option>
              <option value="いちご">いちご</option>
              <option value="にがうり">にがうり</option>
              <option value="とうがらし">とうがらし</option>
              <option value="バナナ">バナナ</option>
              <option value="レモン">レモン</option>
              <option value="ぶどう">ぶどう</option>
              <option value="かき">かき</option>
            </select>
          </div>
        </div>

        <div class="image-slot-group">
          <h4>QR1スロット</h4>
          <div class="file-input-wrapper">
            <label class="file-input-label" for="qr1-image-upload">画像を選択:</label>
            <div class="file-input-controls">
              <input type="file" id="qr1-image-upload" accept="image/*">
              <button class="clear-image-button hidden" id="clear-qr1-image-button" title="画像をクリア">×</button>
            </div>
          </div>
          <img id="qr1-image-preview" src="#" alt="QR1画像プレビュー" class="preview-image" style="display:none;">
          <button class="post-preview-edit-button" id="edit-qr1-image-button" disabled>この画像を編集</button>
          <div class="order-checkbox-group">
            <label class="order-label">入居順(任意):</label>
            <input type="checkbox" id="qr1-order-saki" name="qr1-order" value="先"> <label for="qr1-order-saki">先</label>
            <input type="checkbox" id="qr1-order-ato" name="qr1-order" value="後"> <label for="qr1-order-ato">後</label>
          </div>
          <div class="form-group">
            <label for="qr1-name">名前:</label>
            <input type="text" id="qr1-name" maxlength="10" placeholder="名前を入力(任意)">
          </div>
          <div class="form-group">
            <label for="qr1-favorite-food">好物:</label>
            <select id="qr1-favorite-food">
              <option value="未選択">選択してください(任意)</option>
              <option value="いちご">いちご</option>
              <option value="にがうり">にがうり</option>
              <option value="とうがらし">とうがらし</option>
              <option value="バナナ">バナナ</option>
              <option value="レモン">レモン</option>
              <option value="ぶどう">ぶどう</option>
              <option value="かき">かき</option>
            </select>
          </div>
        </div>

        <div class="image-slot-group">
          <h4>QR2スロット</h4>
          <div class="file-input-wrapper">
            <label class="file-input-label" for="qr2-image-upload">画像を選択:</label>
            <div class="file-input-controls">
              <input type="file" id="qr2-image-upload" accept="image/*">
              <button class="clear-image-button hidden" id="clear-qr2-image-button" title="画像をクリア">×</button>
            </div>
          </div>
          <img id="qr2-image-preview" src="#" alt="QR2画像プレビュー" class="preview-image" style="display:none;">
          <button class="post-preview-edit-button" id="edit-qr2-image-button" disabled>この画像を編集</button>
          <div class="order-checkbox-group">
            <label class="order-label">入居順(任意):</label>
            <input type="checkbox" id="qr2-order-saki" name="qr2-order" value="先"> <label for="qr2-order-saki">先</label>
            <input type="checkbox" id="qr2-order-ato" name="qr2-order" value="後"> <label for="qr2-order-ato">後</label>
          </div>
          <div class="form-group">
            <label for="qr2-name">名前:</label>
            <input type="text" id="qr2-name" maxlength="10" placeholder="名前を入力(任意)">
          </div>
          <div class="form-group">
            <label for="qr2-favorite-food">好物:</label>
            <select id="qr2-favorite-food">
              <option value="未選択">選択してください(任意)</option>
              <option value="いちご">いちご</option>
              <option value="にがうり">にがうり</option>
              <option value="とうがらし">とうがらし</option>
              <option value="バナナ">バナナ</option>
              <option value="レモン">レモン</option>
              <option value="ぶどう">ぶどう</option>
              <option value="かき">かき</option>
            </select>
          </div>
        </div>

        <div class="form-group-checkbox" id="add-unit-border-visible-group">
          <label for="add-unit-border-visible">枠を表示:</label>
          <input type="checkbox" id="add-unit-border-visible" checked>
        </div>
        <button id="add-unit-button" class="action-button" disabled>ユニットをキャンバスに追加</button>

        <div class="panel-section image-collection-section">
          <h3>画像集合ユニット追加</h3>
          <div class="file-input-wrapper">
            <label class="file-input-label" for="image-collection-upload">画像を一括選択 (最大20枚):</label>
            <div class="file-input-controls">
              <input type="file" id="image-collection-upload" accept="image/*" multiple>
              <button class="clear-image-button hidden" id="clear-image-collection-button" title="選択画像をクリア">×</button>
            </div>
          </div>
          <div id="image-collection-previews"></div>
          <div id="image-collection-details" style="max-height: 200px; overflow-y: auto;"></div>
          <div class="form-group-checkbox" id="image-collection-border-group">
            <label for="image-collection-border-visible">枠を表示:</label>
            <input type="checkbox" id="image-collection-border-visible" checked>
          </div>
          <button id="add-image-collection-button" class="action-button" disabled>画像集合ユニットを追加</button>
        </div>


        <div class="panel-section text-add-section">
          <h3>テキスト追加</h3>
          <p>
            <small>※文章が長い・文字サイズを大きく設定した場合は改行することをおすすめします。また場合によっては家系図上での表示がおかしくなってしまう場合がありますが、追加後に枠のサイズを変更していただければ解決する可能性があります。</small>
          </p>
          <div class="form-group">
            <label for="add-text-content">内容:</label>
            <textarea id="add-text-content" rows="3" placeholder="表示したいテキスト"></textarea>
          </div>
          <div class="form-group">
            <label for="add-text-color">文字色:</label>
            <input type="color" id="add-text-color" value="#000000">
          </div>
          <div class="form-group">
            <label for="add-text-bgcolor">背景色:</label>
            <input type="color" id="add-text-bgcolor" value="#ffffff">
          </div>
          <div class="form-group">
            <label for="add-text-size">サイズ:</label>
            <input type="number" id="add-text-size" value="20" min="8">
          </div>
          <div class="form-group-checkbox" id="add-text-border-visible-group">
            <label for="add-text-border-visible">枠を表示:</label>
            <input type="checkbox" id="add-text-border-visible" checked>
          </div>
          <button id="add-text-item-button" class="action-button" disabled>テキストをキャンバスに追加</button>
        </div>
        <div class="panel-section drawing-tools-section" id="drawing-tools-panel" style="display: none;">
          <h3>手書きツール</h3>
          <div class="form-group">
            <label for="drawing-color-picker">色:</label> <!-- id変更: drawing-color -> drawing-color-picker -->
            <input type="color" id="drawing-color-picker" value="#000000">
          </div>
          <div class="form-group">
            <label for="drawing-line-width-slider">太さ:</label>
            <!-- id変更: drawing-line-width -> drawing-line-width-slider -->
            <input type="range" id="drawing-line-width-slider" min="1" max="20" value="3">
            <span id="drawing-line-width-value">3</span>px
          </div>
          <div class="form-group">
            <label for="drawing-shape-select">ツール:</label> <!-- id変更: drawing-shape -> drawing-shape-select -->
            <select id="drawing-shape-select">
              <option value="line" selected>線</option>
              <option value="rectangle">四角</option>
              <option value="circle">円</option>
              <option value="arrow">矢印</option>
              <option value="eraser">消しゴム</option>
            </select>
          </div>
          <div class="form-group" id="drawing-fill-group" style="display:none;">
            <label for="drawing-fill-checkbox">塗りつぶし:</label>
            <input type="checkbox" id="drawing-fill-checkbox">
          </div>
          <div class="drawing-undo-redo-controls">
            <button id="drawing-undo-button" title="描画を元に戻す" disabled>描画戻す</button>
            <button id="drawing-redo-button" title="描画をやり直す" disabled>描画進む</button>
          </div>
          <button id="clear-all-drawings-button" class="action-button"
            style="margin-top: 5px; background-color: #dc3545;">全描画消去</button>
        </div>
      </div>

      <div class="main-canvas-area" id="main-canvas-area">
        <canvas id="family-tree-canvas"></canvas>
      </div>
    </div>

    <div class="bottom-controls">
      <button id="undo-button" title="元に戻す">戻す</button>
      <button id="redo-button" title="やり直す">進む</button>
      <button id="connect-button" title="ユニット間を接続">接続</button>
      <button id="edit-unit-button" title="ユニット/グループ/テキストを編集">編集</button>
      <button id="group-button" title="選択した2つをまとめる">まとめる</button>
      <button id="unify-size-button" title="サイズを合わせる (未実装)">サイズ統一</button>
      <button id="unify-size-complete-selection-btn" title="選択したユニットにサイズ統一を適用"
        style="display: none; background-color: #28a745;">選択完了</button>
      <button id="align-button" title="ユニットを整列">整列</button>
      <button id="draw-mode-button" title="手書き描画モード">描画</button>
      <button id="save-canvas-button" title="家系図を画像で保存">保存</button>
      <button id="zoom-out-button" title="縮小">-</button>
      <span id="zoom-level-indicator">0</span> <button id="zoom-in-button" title="拡大">+</button>
      <button id="clear-storage-button" title="保存データを削除して新規作成"
        style="background-color: #ffc107; color: #333;">データクリア</button>
      <button id="export-data-button" title="家系図データをJSONファイルでエクスポート" style="background-color: #007bff;">エクスポート</button>
      <button id="import-data-button" title="JSONファイルから家系図データをインポート" style="background-color: #28a745;">インポート</button>
      <input type="file" id="import-file-input" accept=".json" style="display: none;">
    </div>
  </div>

  <div id="info-button-container">
    <button id="show-info-modal-button">家系図情報</button>
  </div>

  <div id="cropper-modal" class="modal">
    <div class="modal-header">
      <h2>画像の編集</h2>
      <button class="modal-close-button" id="cropper-modal-close-button-header">&times;</button>
    </div>
    <div class="modal-body">
      <div>
        <img id="image-to-crop" src="" alt="切り抜き対象" style="max-height: 50vh;">
      </div>
      <div id="cropper-zoom-controls">
        <label>ズーム:</label>
        <button data-zoom="0.01">1%</button>
        <button data-zoom="0.1">10%</button>
        <button data-zoom="0.25">25%</button>
        <button data-zoom="0.5">50%</button>
        <button data-zoom="1">100%</button>
        <button data-zoom-in>+</button>
        <button data-zoom-out>-</button>
      </div>
      <div id="cropper-modal-controls">
        <label for="aspect-ratio-select">アスペクト比:</label>
        <select id="aspect-ratio-select">
          <option value="NaN">自由</option>
          <option value="1">正方形 (1:1)</option>
        </select>
      </div>
    </div>
    <div class="modal-footer">
      <button id="cancel-crop-button" class="secondary">キャンセル</button>
      <button id="crop-image-button" class="primary">適用</button>
    </div>
  </div>

  <div id="unit-edit-modal" class="modal">
    <div class="modal-header">
      <h2 id="unit-edit-modal-title">ユニット編集</h2>
      <button class="modal-close-button" id="unit-edit-modal-close-button">&times;</button>
    </div>
    <div class="modal-body" id="unit-edit-modal-body">
    </div>
    <div class="modal-footer">
      <button id="unit-edit-delete-button" class="danger">ユニット削除</button>
      <button id="unit-edit-duplicate-button" class="duplicate">ユニット複製</button>
      <button id="unit-edit-cancel-button" class="secondary">キャンセル</button>
      <button id="unit-edit-apply-button" class="primary">適用</button>
    </div>
  </div>

  <div id="group-edit-modal" class="modal">
    <div class="modal-header">
      <h2 id="group-edit-modal-title">グループ編集</h2>
      <button class="modal-close-button" id="group-edit-modal-close-button">&times;</button>
    </div>
    <div class="modal-body" id="group-edit-modal-body">
      <div class="form-group">
        <label for="group-edit-name">グループ名:</label>
        <input type="text" id="group-edit-name" placeholder="グループ名 (任意)">
      </div>
      <div class="form-group-checkbox">
        <label for="group-edit-border-visible">枠を表示:</label>
        <input type="checkbox" id="group-edit-border-visible">
      </div>
      <p><small>グループ内のユニットの編集は、一度グループ化を解除するか、各ユニットを個別に編集モードで選択してください。</small></p>
    </div>
    <div class="modal-footer">
      <button id="group-edit-delete-button" class="danger">グループ削除</button>
      <button id="group-edit-ungroup-button" class="secondary">グループ化解除</button>
      <button id="group-edit-duplicate-button" class="duplicate">グループ複製</button>
      <button id="group-edit-cancel-button" class="secondary">キャンセル</button>
      <button id="group-edit-apply-button" class="primary">適用</button>
    </div>
  </div>

  <div id="text-edit-modal" class="modal">
    <div class="modal-header">
      <h2 id="text-edit-modal-title">テキスト編集</h2>
      <button class="modal-close-button" id="text-edit-modal-close-button">&times;</button>
    </div>
    <div class="modal-body" id="text-edit-modal-body">
    </div>
    <div class="modal-footer">
      <button id="text-edit-delete-button" class="danger">テキスト削除</button>
      <button id="text-edit-duplicate-button" class="duplicate">テキスト複製</button>
      <button id="text-edit-cancel-button" class="secondary">キャンセル</button>
      <button id="text-edit-apply-button" class="primary">適用</button>
    </div>
  </div>


  <div id="info-modal" class="modal" style="max-width: 650px;">
    <div class="modal-header">
      <h2>家系図情報</h2>
      <button class="modal-close-button" id="info-modal-close-button-header">&times;</button>
    </div>
    <div class="modal-body">
      <p>
        <small>※必要ゴールド及び作物は、スタミナ1で20までレベルを上げてふれあいで幸せを8にした後に好物を7個使い上限突破可能になるまでしあわせを上げることを想定しています。好物が未設定の場合はその分が反映されません。またこちらの設定ミスでおかしな数値になっている可能性があるのであまりアテにしないでください。</small>
      </p>
      <h3>必要作物</h3>
      <ul id="required-crops-list" style="list-style-type: none; padding-left: 0;">
      </ul>
      <h3>必要ゴールド</h3>
      <p id="total-gold-cost">0 G</p>
      <p><small id="gold-details">上限突破0回 0G、出生0回 0G、作物の種0個 0G</small></p>
      <h3>推奨捕獲順</h3>
      <div id="recommended-capture-order-content">
        <p>この機能は目標個体が設定されている場合のみ使用可能です。<br>(ユニット編集から「最終目標にする」にチェックを入れてください)</p>
      </div>
    </div>
    <div class="modal-footer">
      <button id="info-modal-close-button-footer" class="secondary">閉じる</button>
    </div>

  </div>

  <div id="image-collection-edit-modal" class="modal" style="max-width: 600px;">
    <div class="modal-header">
      <h2 id="collection-edit-modal-title">画像集合ユニット編集</h2>
      <button class="modal-close-button" id="collection-edit-modal-close-button">×</button>
    </div>
    <div class="modal-body" id="collection-edit-modal-body">
      <div class="form-group">
        <label for="collection-edit-name">ユニット名:</label>
        <input type="text" id="collection-edit-name" placeholder="ユニット名 (任意)">
      </div>
      <div class="form-group-checkbox">
        <label for="collection-edit-border-visible">枠を表示:</label>
        <input type="checkbox" id="collection-edit-border-visible">
      </div>
      <hr>

      <details class="accordion-section" id="collection-layout-settings">
        <summary class="accordion-header">ユニット内の配置設定</summary>
        <div class="accordion-content">
          <div class="form-group">
            <label for="collection-edit-max-size">画像サイズ:</label>
            <input type="number" id="collection-edit-max-size" min="10" step="1">
            <small> (基本: 50)</small>
          </div>
          <div class="form-group">
            <label for="collection-edit-margin">基本マージン:</label>
            <input type="number" id="collection-edit-margin" min="0" step="1">
            <small> (基本: 5)</small>
          </div>
          <div class="form-group">
            <label for="collection-edit-padding">パディング:</label>
            <input type="number" id="collection-edit-padding" min="0" step="1">
            <small> (基本: 10)</small>
          </div>
          <div class="form-group">
            <label for="collection-edit-text-gap">テキスト間隔:</label>
            <input type="number" id="collection-edit-text-gap" min="0" step="1">
            <small> (基本: 8)</small>
          </div>
          <div class="form-group">
            <label for="collection-edit-per-row">1行の画像数:</label>
            <input type="number" id="collection-edit-per-row" min="1" step="1">
            <small> (基本: 3)</small>
          </div>
          <div class="form-group">
            <label for="collection-edit-font-size">文字サイズ:</label>
            <input type="number" id="collection-edit-font-size" min="6" step="1">
            <small> (基本: 10)</small>
          </div>
          <button id="reset-layout-settings-button" type="button"
            style="font-size: 0.8em; padding: 3px 6px; margin-left: 110px;">基本設定に戻す</button>
        </div>
      </details>
      <hr>


      <h4>内部の画像 (<span id="collection-edit-image-count">0</span>枚)</h4>
      <p><small>ドラッグ＆ドロップで並び替え、各項目を編集、削除ボタン(<span
            style="color:#dc3545; font-weight:bold;">×</span>)で削除リストに追加できます。</small>
      </p>
      <ul id="collection-edit-image-list" style="list-style: none; padding: 0; max-height: 40vh; overflow-y: auto;">
      </ul>
    </div>
    <div class="modal-footer">
      <button id="collection-edit-delete-button" class="danger">ユニット削除</button>
      <button id="collection-edit-cancel-button" class="secondary">キャンセル</button>
      <button id="collection-edit-apply-button" class="primary">適用</button>
    </div>
  </div>
  <div id="unify-size-options-modal" class="modal" style="max-width: 400px; display: none;">
    <div class="modal-header">
      <h2>サイズ統一の範囲を選択</h2>
    </div>
    <div class="modal-body">
      <p>基準ユニット: <strong id="unify-base-unit-name">未選択</strong> (<span id="unify-base-unit-size">0x0</span>)</p>
      <hr>
      <button id="unify-all-units-btn" class="action-button"
        style="margin-bottom: 10px; width: 100%;">家系図上の全ユニット</button>
      <button id="unify-visible-units-btn" class="action-button"
        style="margin-bottom: 10px; width: 100%;">画面内のユニットのみ</button>
      <button id="unify-select-targets-btn" class="action-button" style="width: 100%;">適用するユニットを選択する</button>
    </div>
    <div class="modal-footer">
      <button id="unify-size-options-modal-cancel-btn" class="secondary">キャンセル</button>
    </div>
  </div>
  <div id="align-options-modal" class="modal" style="max-width: 350px; display: none;">
    <div class="modal-header">
      <h2>整列方法を選択</h2>
    </div>
    <div class="modal-body">
      <p>基準ユニット: <strong id="align-options-base-unit-name">未選択</strong></p>
      <p>対象ユニット数: <span id="align-options-target-count">0</span>個</p>
      <hr>
      <button id="align-horizontal-btn" class="action-button"
        style="margin-bottom: 10px; width: 100%; background-color: #17a2b8;">水平方向に整列 (Y座標を揃える)</button>
      <button id="align-vertical-btn" class="action-button" style="width: 100%; background-color: #fd7e14;">垂直方向に整列
        (X座標を揃える)</button>
    </div>
    <div class="modal-footer">
      <button id="align-options-modal-cancel-btn" class="secondary">キャンセル</button>
    </div>
  </div>
  <div id="image-preview-modal" class="modal"
    style="max-width: 90%; max-height: 90vh; display: none; background-color: rgba(0,0,0,0.7);">
    <div class="modal-header" style="border-bottom: none; padding-bottom: 5px;">
      <h2 style="color: white;">画像のプレビュー</h2>
      <button class="modal-close-button" id="image-preview-modal-close-button"
        style="color: white; font-size: 32px;">×</button>
    </div>
    <div class="modal-body" style="text-align: center; padding: 10px;">
      <img id="save-image-preview" src="#" alt="生成された家系図のプレビュー"
        style="max-width: 100%; max-height: 75vh; border: 2px solid white; background-color: white; object-fit: contain;">
      <p id="image-preview-instruction" style="color: white; margin-top: 15px; font-size: 0.9em;">
        画像を長押しして「写真に追加」または「画像を保存」を選択してください。</p>
    </div>
    <div class="modal-footer" style="border-top: none; padding-top: 5px;">
      <button id="force-download-button" class="secondary" style="background-color: #5bc0de;">ファイルとしてダウンロード</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {


      // ========================================
      // 1. 定数宣言 (const)
      // ========================================
      const container = document.querySelector('.container');
      const topArea = document.querySelector('.top-area');
      const bottomControls = document.querySelector('.bottom-controls');
      const BASE_SCALE_FACTOR = 1.2;
      const DEFAULT_FONT = "'Noto Sans JP', sans-serif";
      const SLOT_WIDTH_BASE = 110;
      const SLOT_IMAGE_HEIGHT_BASE = 60 * BASE_SCALE_FACTOR;
      const SLOT_QR_IMAGE_SIZE_BASE = SLOT_IMAGE_HEIGHT_BASE;
      const SLOT_TEXT_LINE_HEIGHT_BASE = 16 * BASE_SCALE_FACTOR;
      const SLOT_PADDING_BASE = 8 * BASE_SCALE_FACTOR;
      const UNIT_INTERNAL_PADDING_BASE = 5 * BASE_SCALE_FACTOR;
      const IMAGE_TEXT_PADDING = SLOT_PADDING_BASE;
      const TEXT_LINE_HEIGHT_MULTIPLIER = 1.2;
      const RESIZE_HANDLE_SIZE = 10;
      const MIN_SLOT_WIDTH_FOR_DRAWING = 30;
      const BORDER_RESIZE_THRESHOLD = 8;
      const UNIT_WIDTH_ONE_SLOT = SLOT_WIDTH_BASE + (SLOT_PADDING_BASE * 2);
      const UNIT_WIDTH_TWO_SLOTS = (SLOT_WIDTH_BASE * 2) + UNIT_INTERNAL_PADDING_BASE + (SLOT_PADDING_BASE * 2);
      const UNIT_WIDTH_THREE_SLOTS = (SLOT_WIDTH_BASE * 3) + (UNIT_INTERNAL_PADDING_BASE * 2) + (SLOT_PADDING_BASE * 2);
      const GROUP_PADDING = 20;
      const TEXT_ITEM_PADDING = 5;
      const MIN_TEXT_ITEM_WIDTH = 30 + (TEXT_ITEM_PADDING * 2);
      const MIN_TEXT_ITEM_HEIGHT = 20 + (TEXT_ITEM_PADDING * 2);
      const COLLECTION_IMAGE_MAX_SIZE = 50;
      const COLLECTION_IMAGE_MARGIN = 5;
      const COLLECTION_PADDING = 10;
      const COLLECTION_IMAGES_PER_ROW = 3;
      const textFontSizeLogical = 10;
      const minTextGapLogical = 8;
      const cropColors = {
        'いちご': '#e73562', 'にがうり': '#47885e', 'とうがらし': '#ff0000',
        'バナナ': '#ffe135', 'レモン': '#fffcbf', 'ぶどう': '#522f60', 'かき': '#ed6d3d'
      };
      const SNAP_THRESHOLD = 15;
      const SNAP_RATIO = 5;
      const FAMILY_TREE_TEMPLATES = [
        {
          id: 'template-3step',
          name: '3手(太陽等)',
          maxImages: 15,
          layout: {
            units: [
              // 第四世代 (最下層の子孫) - G3_P1とG3_P2の中間X、G3より下
              { tempId: 'g4_child1', xOffset: 0, yOffset: 2, slotMapping: { birth: 14 } },

              // 第三世代 - G2ペアの中間X、G2より下、Y座標を揃える
              { tempId: 'g3_parent1', xOffset: -2, yOffset: 1, slotMapping: { birth: 12 } }, // G2_GP1とG2_GP2の中間
              { tempId: 'g3_parent2', xOffset: 2, yOffset: 1, slotMapping: { birth: 13 } }, // G2_GP3とG2_GP4の中間

              // 第二世代 - G1ペアの中間X、G1より下、Y座標を揃える
              { tempId: 'g2_grandparent1', xOffset: -3, yOffset: 0, slotMapping: { birth: 8 } },  // G1_A1とG1_A2の中間
              { tempId: 'g2_grandparent2', xOffset: -1, yOffset: 0, slotMapping: { birth: 9 } },  // G1_A3とG1_A4の中間
              { tempId: 'g2_grandparent3', xOffset: 1, yOffset: 0, slotMapping: { birth: 10 } }, // G1_A5とG1_A6の中間
              { tempId: 'g2_grandparent4', xOffset: 3, yOffset: 0, slotMapping: { birth: 11 } }, // G1_A7とG1_A8の中間

              // 第一世代 (最上位の先祖) - Y座標を揃える、ペアでXを調整
              { tempId: 'g1_ancestor1', xOffset: -3.5, yOffset: -1, slotMapping: { qr1: 0 } },
              { tempId: 'g1_ancestor2', xOffset: -2.5, yOffset: -1, slotMapping: { qr1: 1 } },
              { tempId: 'g1_ancestor3', xOffset: -1.5, yOffset: -1, slotMapping: { qr1: 2 } },
              { tempId: 'g1_ancestor4', xOffset: -0.5, yOffset: -1, slotMapping: { qr1: 3 } },
              { tempId: 'g1_ancestor5', xOffset: 0.5, yOffset: -1, slotMapping: { qr1: 4 } },
              { tempId: 'g1_ancestor6', xOffset: 1.5, yOffset: -1, slotMapping: { qr1: 5 } },
              { tempId: 'g1_ancestor7', xOffset: 2.5, yOffset: -1, slotMapping: { qr1: 6 } },
              { tempId: 'g1_ancestor8', xOffset: 3.5, yOffset: -1, slotMapping: { qr1: 7 } },
            ],
            connections: [
              // G3_P1 と G3_P2 から G4_C1 へ (T字の上辺と縦棒)
              { from: 'g3_parent1', to: 'g4_child1' }, { from: 'g3_parent2', to: 'g4_child1' },
              // G2_GP1/2 から G3_P1 へ
              { from: 'g2_grandparent1', to: 'g3_parent1' }, { from: 'g2_grandparent2', to: 'g3_parent1' },
              // G2_GP3/4 から G3_P2 へ
              { from: 'g2_grandparent3', to: 'g3_parent2' }, { from: 'g2_grandparent4', to: 'g3_parent2' },
              // G1_A1/2 から G2_GP1 へ
              { from: 'g1_ancestor1', to: 'g2_grandparent1' }, { from: 'g1_ancestor2', to: 'g2_grandparent1' },
              // G1_A3/4 から G2_GP2 へ
              { from: 'g1_ancestor3', to: 'g2_grandparent2' }, { from: 'g1_ancestor4', to: 'g2_grandparent2' },
              // G1_A5/6 から G2_GP3 へ
              { from: 'g1_ancestor5', to: 'g2_grandparent3' }, { from: 'g1_ancestor6', to: 'g2_grandparent3' },
              // G1_A7/8 から G2_GP4 へ
              { from: 'g1_ancestor7', to: 'g2_grandparent4' }, { from: 'g1_ancestor8', to: 'g2_grandparent4' },
            ],
            unitType: 'unit',
            defaultWidth: UNIT_WIDTH_ONE_SLOT,
            defaultHeightMultiplier: 1.0, // 高さを標準に
            gridSize: UNIT_WIDTH_ONE_SLOT * 1.5 // X方向の配置間隔の基準 (Y方向は yOffset で調整)
            // Y方向の世代間隔は yOffset の差で表現
          }
        },
        {
          id: 'template-2step-mozart',
          name: '2手(モーツァルト等)',
          maxImages: 7,
          layout: {
            units: [
              // 第三世代
              { tempId: 'g3_child1', xOffset: 0, yOffset: 1, slotMapping: { birth: 6 } },
              // 第二世代
              { tempId: 'g2_parent1', xOffset: -1.5, yOffset: 0, slotMapping: { birth: 4 } },
              { tempId: 'g2_parent2', xOffset: 1.5, yOffset: 0, slotMapping: { birth: 5 } },
              // 第一世代
              { tempId: 'g1_ancestor1', xOffset: -2.5, yOffset: -1, slotMapping: { qr1: 0 } },
              { tempId: 'g1_ancestor2', xOffset: -0.5, yOffset: -1, slotMapping: { qr1: 1 } },
              { tempId: 'g1_ancestor3', xOffset: 0.5, yOffset: -1, slotMapping: { qr1: 2 } },
              { tempId: 'g1_ancestor4', xOffset: 2.5, yOffset: -1, slotMapping: { qr1: 3 } },
            ],
            connections: [
              { from: 'g2_parent1', to: 'g3_child1' }, { from: 'g2_parent2', to: 'g3_child1' },
              { from: 'g1_ancestor1', to: 'g2_parent1' }, { from: 'g1_ancestor2', to: 'g2_parent1' },
              { from: 'g1_ancestor3', to: 'g2_parent2' }, { from: 'g1_ancestor4', to: 'g2_parent2' },
            ],
            unitType: 'unit',
            defaultWidth: UNIT_WIDTH_ONE_SLOT,
            defaultHeightMultiplier: 1.0,
            gridSize: UNIT_WIDTH_ONE_SLOT * 1.5
          }
        },
        {
          id: 'template-1step-item',
          name: '1手(おにぎり、ヘッドホン等)',
          maxImages: 3,
          layout: {
            units: [
              // 第二世代
              { tempId: 'g2_child1', xOffset: 0, yOffset: 0.5, slotMapping: { birth: 2 } },
              // 第一世代
              { tempId: 'g1_parent1', xOffset: -1, yOffset: -0.5, slotMapping: { qr1: 0 } },
              { tempId: 'g1_parent2', xOffset: 1, yOffset: -0.5, slotMapping: { qr1: 1 } },
            ],
            connections: [
              { from: 'g1_parent1', to: 'g2_child1' }, { from: 'g1_parent2', to: 'g2_child1' },
            ],
            unitType: 'unit',
            defaultWidth: UNIT_WIDTH_ONE_SLOT,
            defaultHeightMultiplier: 1.0,
            gridSize: UNIT_WIDTH_ONE_SLOT * 1.5
          }
        }
      ];

      // ========================================
      // 2. グローバル変数宣言 (let)
      // ========================================
      let units = [];
      let groups = [];
      let textItems = [];
      let connections = [];
      let nextItemId = 0;
      let selectedItem = null;
      let draggingItem = null;
      let resizingItem = null;
      let resizeHandle = null;
      let dragOffsetX, dragOffsetY;
      let currentMode = null;
      let currentModeButtonElement = null;
      let connectFromItem = null;
      let itemsToGroup = [];
      let scale = 1.0;
      let zoomLevel = 0;
      let originX = 0;
      let originY = 0;
      let isPanning = false;
      let lastPanX, lastPanY;
      let history = [];
      let historyIndex = -1;
      let cropper = null;
      let currentCropFinalizeCallback = null;
      let currentImageSlotKeyForEditing = null;
      let currentEditingUnitContext = null;
      let editingUnit = null;
      let editingGroup = null;
      let editingTextItem = null;
      let uploadedCollectionImages = [];
      let editingCollectionUnit = null;
      let editingCollectionImageIndex = null;
      let draggedItem = null;
      let isDrawing = false;
      let lastDrawX, lastDrawY;
      let currentDrawingPath = [];
      let drawnPaths = [];
      let drawingColor = '#000000';
      let drawingLineWidth = 3;
      let drawingShape = 'line';
      let drawnPathsHistory = [];
      let drawnPathsHistoryIndex = -1;
      let unifySizeModeSubState = null;
      let unifySizeBaseUnit = null;
      let unifySizeTargetUnits = [];
      let editingLine = null;
      let alignBaseUnit = null;
      let alignTargetUnits = [];
      let selectedTemplate = null;
      let templateUploadedImages = [];
      let pinchStartCanvasCenterX = 0;
      let pinchStartCanvasCenterY = 0;
      let pinchStartScreenCenterX = 0;
      let pinchStartScreenCenterY = 0;

      // ========================================
      // 3. HTML要素取得 (const ... = document.getElementById(...))
      // ========================================
      const leftPanel = document.getElementById('left-panel');
      const leftPanelToggleButton = document.getElementById('left-panel-toggle-button');
      const mainCanvasArea = document.getElementById('main-canvas-area');
      const modalOverlay = document.getElementById('modal-overlay');
      const addUnitBorderVisibleCheckbox = document.getElementById('add-unit-border-visible');
      const imageSlots = {
        birth: {
          uploadInput: document.getElementById('birth-image-upload'),
          previewImg: document.getElementById('birth-image-preview'),
          editBtn: document.getElementById('edit-birth-image-button'),
          clearBtn: document.getElementById('clear-birth-image-button'),
          nameInput: document.getElementById('birth-name'),
          foodSelect: document.getElementById('birth-favorite-food'),
          orderSakiCheckbox: null, orderAtoCheckbox: null, data: null
        },
        qr1: {
          uploadInput: document.getElementById('qr1-image-upload'),
          previewImg: document.getElementById('qr1-image-preview'),
          editBtn: document.getElementById('edit-qr1-image-button'),
          clearBtn: document.getElementById('clear-qr1-image-button'),
          nameInput: document.getElementById('qr1-name'),
          foodSelect: document.getElementById('qr1-favorite-food'),
          orderSakiCheckbox: document.getElementById('qr1-order-saki'),
          orderAtoCheckbox: document.getElementById('qr1-order-ato'), data: null
        },
        qr2: {
          uploadInput: document.getElementById('qr2-image-upload'),
          previewImg: document.getElementById('qr2-image-preview'),
          editBtn: document.getElementById('edit-qr2-image-button'),
          clearBtn: document.getElementById('clear-qr2-image-button'),
          nameInput: document.getElementById('qr2-name'),
          foodSelect: document.getElementById('qr2-favorite-food'),
          orderSakiCheckbox: document.getElementById('qr2-order-saki'),
          orderAtoCheckbox: document.getElementById('qr2-order-ato'), data: null
        }
      };
      const addUnitButton = document.getElementById('add-unit-button');
      const canvas = document.getElementById('family-tree-canvas');
      const ctx = canvas.getContext('2d');
      const statusBar = document.getElementById('status-bar');
      const infoButtonContainer = document.getElementById('info-button-container');
      const addTextContentInput = document.getElementById('add-text-content');
      const addTextColorInput = document.getElementById('add-text-color');
      const addTextBgColorInput = document.getElementById('add-text-bgcolor');
      const addTextSizeInput = document.getElementById('add-text-size');
      const addTextBorderVisibleCheckbox = document.getElementById('add-text-border-visible');
      const addTextItemButton = document.getElementById('add-text-item-button');
      const imageCollectionUploadInput = document.getElementById('image-collection-upload');
      const imageCollectionPreviewsDiv = document.getElementById('image-collection-previews');
      const imageCollectionDetailsDiv = document.getElementById('image-collection-details');
      const imageCollectionBorderCheckbox = document.getElementById('image-collection-border-visible');
      const addImageCollectionButton = document.getElementById('add-image-collection-button');
      const clearImageCollectionButton = document.getElementById('clear-image-collection-button');
      const undoButton = document.getElementById('undo-button');
      const redoButton = document.getElementById('redo-button');
      const connectButton = document.getElementById('connect-button');
      const editUnitButton = document.getElementById('edit-unit-button');
      const groupButton = document.getElementById('group-button');
      const unifySizeButton = document.getElementById('unify-size-button');
      const saveCanvasButton = document.getElementById('save-canvas-button');
      const zoomInButton = document.getElementById('zoom-in-button');
      const zoomOutButton = document.getElementById('zoom-out-button');
      const zoomLevelIndicator = document.getElementById('zoom-level-indicator');
      const cropperModal = document.getElementById('cropper-modal');
      const cropperModalCloseButtonHeader = document.getElementById('cropper-modal-close-button-header');
      const imageToCrop = document.getElementById('image-to-crop');
      const aspectRatioSelect = document.getElementById('aspect-ratio-select');
      const cropImageButton = document.getElementById('crop-image-button');
      const cancelCropButton = document.getElementById('cancel-crop-button');
      const cropperZoomControls = document.getElementById('cropper-zoom-controls');
      const unitEditModal = document.getElementById('unit-edit-modal');
      const unitEditModalTitle = document.getElementById('unit-edit-modal-title');
      const unitEditModalBody = document.getElementById('unit-edit-modal-body');
      const unitEditModalCloseButton = document.getElementById('unit-edit-modal-close-button');
      const unitEditApplyButton = document.getElementById('unit-edit-apply-button');
      const unitEditCancelButton = document.getElementById('unit-edit-cancel-button');
      const unitEditDuplicateButton = document.getElementById('unit-edit-duplicate-button');
      const unitEditDeleteButton = document.getElementById('unit-edit-delete-button');
      const groupEditModal = document.getElementById('group-edit-modal');
      const groupEditModalTitle = document.getElementById('group-edit-modal-title');
      const groupEditModalCloseButton = document.getElementById('group-edit-modal-close-button');
      const groupEditNameInput = document.getElementById('group-edit-name');
      const groupEditBorderVisibleCheckbox = document.getElementById('group-edit-border-visible');
      const groupEditApplyButton = document.getElementById('group-edit-apply-button');
      const groupEditCancelButton = document.getElementById('group-edit-cancel-button');
      const groupEditUngroupButton = document.getElementById('group-edit-ungroup-button');
      const groupEditDuplicateButton = document.getElementById('group-edit-duplicate-button');
      const groupEditDeleteButton = document.getElementById('group-edit-delete-button');
      const textEditModal = document.getElementById('text-edit-modal');
      const textEditModalTitle = document.getElementById('text-edit-modal-title');
      const textEditModalBody = document.getElementById('text-edit-modal-body');
      const textEditModalCloseButton = document.getElementById('text-edit-modal-close-button');
      const textEditApplyButton = document.getElementById('text-edit-apply-button');
      const textEditCancelButton = document.getElementById('text-edit-cancel-button');
      const textEditDeleteButton = document.getElementById('text-edit-delete-button');
      const textEditDuplicateButton = document.getElementById('text-edit-duplicate-button');
      const infoModal = document.getElementById('info-modal');
      const showInfoModalButton = document.getElementById('show-info-modal-button');
      const infoModalCloseButtonHeader = document.getElementById('info-modal-close-button-header');
      const infoModalCloseButtonFooter = document.getElementById('info-modal-close-button-footer');
      const requiredCropsList = document.getElementById('required-crops-list');
      const collectionEditModal = document.getElementById('image-collection-edit-modal');
      const collectionEditModalTitle = document.getElementById('collection-edit-modal-title');
      const collectionEditNameInput = document.getElementById('collection-edit-name');
      const collectionEditBorderCheckbox = document.getElementById('collection-edit-border-visible');
      const collectionEditImageList = document.getElementById('collection-edit-image-list');
      const collectionEditImageCount = document.getElementById('collection-edit-image-count');
      const collectionEditApplyButton = document.getElementById('collection-edit-apply-button');
      const collectionEditCancelButton = document.getElementById('collection-edit-cancel-button');
      const collectionEditDeleteButton = document.getElementById('collection-edit-delete-button');
      const collectionEditModalCloseButton = document.getElementById('collection-edit-modal-close-button');
      const resetLayoutButton = document.getElementById('reset-layout-settings-button');
      const clearStorageButton = document.getElementById('clear-storage-button');
      const drawModeButton = document.getElementById('draw-mode-button');
      const drawingToolsPanel = document.getElementById('drawing-tools-panel');
      const drawingColorPicker = document.getElementById('drawing-color-picker');
      const drawingLineWidthSlider = document.getElementById('drawing-line-width-slider');
      const drawingLineWidthValue = document.getElementById('drawing-line-width-value');
      const drawingShapeSelect = document.getElementById('drawing-shape-select');
      const drawingFillGroup = document.getElementById('drawing-fill-group');
      const drawingFillCheckbox = document.getElementById('drawing-fill-checkbox');
      const clearAllDrawingsButton = document.getElementById('clear-all-drawings-button');
      const drawingUndoButton = document.getElementById('drawing-undo-button');
      const drawingRedoButton = document.getElementById('drawing-redo-button');
      const alignButton = document.getElementById('align-button');
      const alignOptionsModal = document.getElementById('align-options-modal');
      const alignOptionsBaseUnitName = document.getElementById('align-options-base-unit-name');
      const alignOptionsTargetCount = document.getElementById('align-options-target-count');
      const alignHorizontalBtn = document.getElementById('align-horizontal-btn');
      const alignVerticalBtn = document.getElementById('align-vertical-btn');
      const alignOptionsModalCancelBtn = document.getElementById('align-options-modal-cancel-btn');
      const templateSelect = document.getElementById('template-select');
      const templateImageUpload = document.getElementById('template-image-upload');
      const templateImageInfo = document.getElementById('template-image-info');
      const templateImagePreviews = document.getElementById('template-image-previews');
      const addFromTemplateButton = document.getElementById('add-from-template-button');
      const imagePreviewModal = document.getElementById('image-preview-modal');
      const saveImagePreview = document.getElementById('save-image-preview');
      const imagePreviewModalCloseButton = document.getElementById('image-preview-modal-close-button');
      const forceDownloadButton = document.getElementById('force-download-button');

      const modeButtons = {
        'connect': connectButton,
        'edit-item': editUnitButton,
        'grouping': groupButton,
        'unify-size': unifySizeButton,
        'align': alignButton
      };
      const modeMessages = {
        'connect': '接続モード: 接続元のユニットまたは線を選択し、次に対象のユニットまたは線を選択してください。',
        'edit-item': '編集モード: 編集したいユニット、グループ、またはテキストを選択してください。',
        'grouping': 'グループ化モード: ユニットを2つ以上選択し「決定」でグループ化。',
        'unify-size-select-base': 'サイズ統一: 基準となるユニットを選択してください。',
        'unify-size-select-targets': 'サイズ統一: 対象ユニットを選択 (クリックで選択/解除)。完了後「選択完了」ボタン。',
        'draw-path': '手書き描画モード: キャンバスに直接描画します。',
        'align-select-base': '整列モード: 基準となるユニットを1つ選択してください。',
        'align-select-targets': '整列モード: 対象ユニットを選択 (クリックで選択/解除)。その後、再度「整列」ボタンを押して整列方法を選択。'
      };

      console.log("canvas 要素 (初期化時):", canvas);
      console.log("leftPanelToggleButton 要素 (初期化時):", leftPanelToggleButton);


      // ========================================
      // 4. 関数定義 (function ...() { ... })
      // ========================================

      function resizeCanvas() {
        canvas.width = 3000;
        canvas.height = 2000;
        drawCanvas();
      }

      function saveState() {
        const state = {
          units: JSON.parse(JSON.stringify(units.map(u => {
            if (u.type === 'image-collection') {
              return {
                ...u,
                layoutSettings: u.layoutSettings ? { ...u.layoutSettings } : null,
                images: u.images.map(imgInfo => ({
                  imgDataUrl: imgInfo.imgDataUrl,
                  originalDataUrl: imgInfo.originalDataUrl,
                  fileName: imgInfo.fileName,
                  name: imgInfo.name,
                  food: imgInfo.food
                }))
              };
            }
            const serializableSlots = {};
            for (const key in u.slots) {
              const slot = u.slots[key];
              serializableSlots[key] = slot ? {
                imgDataUrl: slot.imgDataUrl || null,
                originalDataUrl: slot.originalDataUrl || null,
                fileName: slot.fileName || null,
                name: slot.name || '',
                food: slot.food || '未選択',
                order: slot.order || null
              } : null;
            }
            return { ...u, width: u.width, height: u.height, slots: serializableSlots, borderVisible: u.borderVisible, activeSlotKeys: u.activeSlotKeys };

          }))),
          groups: JSON.parse(JSON.stringify(groups.map(g => ({ ...g, itemIds: [...g.itemIds], borderVisible: g.borderVisible })))),
          textItems: JSON.parse(JSON.stringify(textItems.map(t => ({ ...t, borderVisible: t.borderVisible, font: t.font || DEFAULT_FONT, rotation: t.rotation || 0 })))),
          connections: JSON.parse(JSON.stringify(connections.map(conn => ({
            id: conn.id,
            fromId: conn.fromId,
            toId: conn.toId,
            isUnitToLine: conn.isUnitToLine,
            isLineToUnit: conn.isLineToUnit,
            color: conn.color || '#555555',
            lineWidth: conn.lineWidth || 10,
            dashArray: conn.dashArray || [],
          })))),
          drawnPaths: JSON.parse(JSON.stringify(drawnPaths)),
          nextItemId: nextItemId,
          scale: scale,
          originX: originX,
          originY: originY,
          zoomLevel: zoomLevel

        };
        history = history.slice(0, historyIndex + 1);
        history.push(state);
        historyIndex++;
        updateUndoRedoButtons();

        try {
          localStorage.setItem('kakeizuToolState', JSON.stringify(state));
          console.log("状態をローカルストレージに保存しました。");
        } catch (e) {
          console.error("ローカルストレージへの保存に失敗しました:", e);
          // クォータ超過などの可能性をユーザーに通知することも検討
        }
      }

      function calculateUnitHeight(unitSlots) {
        let neededHeight = 0;
        let hasImage = false;
        let maxTextLines = 0;
        Object.entries(unitSlots).forEach(([slotKey, slotData]) => {
          let currentSlotLines = 0;
          if (slotData) {
            if (slotData.img || slotData.imgDataUrl) hasImage = true;
            if (slotData.name) currentSlotLines++;
            if (slotData.food && slotData.food !== '未選択') currentSlotLines++;
            if ((slotKey === 'qr1' || slotKey === 'qr2') && slotData.order) currentSlotLines++;
          }
          maxTextLines = Math.max(maxTextLines, currentSlotLines);
        });
        neededHeight += SLOT_PADDING_BASE;
        if (hasImage) {
          neededHeight += Math.max(SLOT_IMAGE_HEIGHT_BASE, SLOT_QR_IMAGE_SIZE_BASE);
          if (maxTextLines > 0) neededHeight += IMAGE_TEXT_PADDING;
        } else if (maxTextLines > 0) {
          neededHeight += SLOT_PADDING_BASE / 2;
        }
        neededHeight += maxTextLines * SLOT_TEXT_LINE_HEIGHT_BASE * TEXT_LINE_HEIGHT_MULTIPLIER;
        neededHeight += SLOT_PADDING_BASE;
        let minHeight;
        if (hasImage) {
          minHeight = SLOT_PADDING_BASE * 2 + Math.max(SLOT_IMAGE_HEIGHT_BASE, SLOT_QR_IMAGE_SIZE_BASE) + (maxTextLines > 0 ? IMAGE_TEXT_PADDING : 0) + (maxTextLines * SLOT_TEXT_LINE_HEIGHT_BASE * TEXT_LINE_HEIGHT_MULTIPLIER);
        } else {
          minHeight = SLOT_PADDING_BASE * 2 + (maxTextLines > 0 ? SLOT_PADDING_BASE / 2 : 0) + (maxTextLines * TEXT_LINE_HEIGHT_MULTIPLIER * SLOT_TEXT_LINE_HEIGHT_BASE);
        }
        minHeight = Math.max(minHeight, SLOT_PADDING_BASE * 2 + (maxTextLines > 0 ? SLOT_TEXT_LINE_HEIGHT_BASE * TEXT_LINE_HEIGHT_MULTIPLIER : SLOT_IMAGE_HEIGHT_BASE * 0.5));
        return Math.max(minHeight, neededHeight);
      }

      async function restoreState(state) {
        const restoredUnits = [];
        const loadImage = async (url) => {
          if (!url) return null;
          return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = () => { console.error(`Error loading image: ${url}`); resolve(null); };
            img.src = url;
          });
        };
        if (state.units) {
          for (const savedItem of state.units) {
            if (savedItem.type === 'image-collection') {
              const restoredImages = [];
              if (savedItem.images && Array.isArray(savedItem.images)) {
                for (const imgInfo of savedItem.images) {
                  restoredImages.push({ ...imgInfo, img: await loadImage(imgInfo.imgDataUrl) });
                }
              }
              restoredUnits.push({ ...savedItem, images: restoredImages, layoutSettings: savedItem.layoutSettings || null });
            } else {
              const newUnitSlots = {};
              if (savedItem.slots) {
                for (const key in savedItem.slots) {
                  const savedSlot = savedItem.slots[key];
                  if (savedSlot) {
                    newUnitSlots[key] = {
                      img: await loadImage(savedSlot.imgDataUrl),
                      imgDataUrl: savedSlot.imgDataUrl,
                      originalDataUrl: savedSlot.originalDataUrl,
                      fileName: savedSlot.fileName,
                      name: savedSlot.name,
                      food: savedSlot.food,
                      order: savedSlot.order || null
                    };
                  } else { newUnitSlots[key] = null; }
                }
              }
              const unitWidth = savedItem.width;
              const unitHeight = savedItem.height;
              const activeSlotKeys = savedItem.activeSlotKeys || Object.keys(newUnitSlots).filter(k => newUnitSlots[k]?.img || newUnitSlots[k]?.imgDataUrl);
              restoredUnits.push({
                ...savedItem, width: unitWidth, height: unitHeight, slots: newUnitSlots,
                borderVisible: savedItem.borderVisible !== undefined ? savedItem.borderVisible : true,
                activeSlotKeys: activeSlotKeys
              });
            }
          }
        }
        units = restoredUnits;
        groups = JSON.parse(JSON.stringify(state.groups || [])).map(g => ({ ...g, borderVisible: g.borderVisible !== undefined ? g.borderVisible : true }));
        textItems = JSON.parse(JSON.stringify(state.textItems || [])).map(t => ({ ...t, borderVisible: t.borderVisible !== undefined ? t.borderVisible : true, font: t.font || DEFAULT_FONT, rotation: t.rotation || 0 }));
        connections = JSON.parse(JSON.stringify(state.connections || [])).map(conn => ({
          ...conn,
          color: conn.color || '#555555',
          lineWidth: conn.lineWidth || 10,
          dashArray: conn.dashArray || [],
        }));
        nextItemId = state.nextItemId || 0;
        selectedItem = null; connectFromItem = null; itemsToGroup = [];
        drawCanvas(); updateUndoRedoButtons(); updateInfoModal();
        if (state.drawnPaths) {
          drawnPaths = JSON.parse(JSON.stringify(state.drawnPaths));
        } else {
          drawnPaths = [];
        }
        resetDrawingHistory();
        if (state.scale !== undefined) scale = state.scale;
        if (state.originX !== undefined) originX = state.originX;
        if (state.originY !== undefined) originY = state.originY;
        if (state.zoomLevel !== undefined) zoomLevel = state.zoomLevel;
        if (zoomLevelIndicator) zoomLevelIndicator.textContent = zoomLevel;

        selectedItem = null; connectFromItem = null; itemsToGroup = [];
        updateUndoRedoButtons();
        updateInfoModal();
        drawCanvas();
      }

      function updateUndoRedoButtons() {
        undoButton.disabled = historyIndex < 0;
        redoButton.disabled = historyIndex >= history.length - 1;
      }

      function checkAddUnitButtonState() {
        let hasAtLeastOneImage = false;
        Object.values(imageSlots).forEach(slot => {
          if (slot.data && slot.data.img) hasAtLeastOneImage = true;
        });
        addUnitButton.disabled = !hasAtLeastOneImage;
      }

      function checkAddTextButtonState() {
        addTextItemButton.disabled = addTextContentInput.value.trim() === '';
      }

      function checkAddImageCollectionButtonState() {
        addImageCollectionButton.disabled = uploadedCollectionImages.length === 0;
      }

      function handleQrOrderChange(changedSlotKey, changedValue, source) {
        const prefix = source === 'left-panel' ? '' : 'unit-edit-';
        const sakiSuffix = (source === 'left-panel') ? 'saki' : '先';
        const atoSuffix = (source === 'left-panel') ? 'ato' : '後';
        const qr1Saki = document.getElementById(`${prefix}qr1-order-${sakiSuffix}`);
        const qr1Ato = document.getElementById(`${prefix}qr1-order-${atoSuffix}`);
        const qr2Saki = document.getElementById(`${prefix}qr2-order-${sakiSuffix}`);
        const qr2Ato = document.getElementById(`${prefix}qr2-order-${atoSuffix}`);
        if (!qr1Saki || !qr1Ato || !qr2Saki || !qr2Ato) return;
        let operatedCheckbox;
        if (changedSlotKey.includes('qr1')) operatedCheckbox = (changedValue === '先') ? qr1Saki : qr1Ato;
        else operatedCheckbox = (changedValue === '先') ? qr2Saki : qr2Ato;
        const isChecked = operatedCheckbox.checked;
        if (isChecked) {
          if (changedSlotKey.includes('qr1')) {
            if (changedValue === '先') { qr1Ato.checked = false; qr2Saki.checked = false; qr2Ato.checked = true; }
            else { qr1Saki.checked = false; qr2Ato.checked = false; qr2Saki.checked = true; }
          } else {
            if (changedValue === '先') { qr2Ato.checked = false; qr1Saki.checked = false; qr1Ato.checked = true; }
            else { qr2Saki.checked = false; qr1Ato.checked = false; qr1Saki.checked = true; }
          }
        } else {
          if (changedSlotKey.includes('qr1')) { if (changedValue === '先') qr2Ato.checked = false; else qr2Saki.checked = false; }
          else { if (changedValue === '先') qr1Ato.checked = false; else qr1Saki.checked = false; }
        }
      }

      function selectCollectionImageForDetail(index) {
        imageCollectionPreviewsDiv.querySelectorAll('img').forEach(img => img.classList.remove('selected-preview'));
        imageCollectionDetailsDiv.querySelectorAll('.detail-item').forEach(item => item.style.display = 'none');
        const selectedPreview = imageCollectionPreviewsDiv.querySelector(`img[data-index="${index}"]`);
        if (selectedPreview) selectedPreview.classList.add('selected-preview');
        const selectedDetail = imageCollectionDetailsDiv.querySelector(`.detail-item[data-index="${index}"]`);
        if (selectedDetail) selectedDetail.style.display = 'block';
      }

      function renderImageCollectionDetails() {
        imageCollectionDetailsDiv.innerHTML = '';
        uploadedCollectionImages.forEach((imgData, index) => {
          const detailDiv = document.createElement('div'); detailDiv.className = 'detail-item'; detailDiv.dataset.index = index; detailDiv.style.display = 'none';
          const fileNameP = document.createElement('p'); fileNameP.textContent = `ファイル名: ${imgData.fileName}`; detailDiv.appendChild(fileNameP);
          const nameGroup = document.createElement('div'); nameGroup.className = 'form-group';
          const nameLabel = document.createElement('label'); nameLabel.textContent = '名前:'; nameLabel.style.flexBasis = '50px';
          const nameInput = document.createElement('input'); nameInput.type = 'text'; nameInput.value = imgData.name; nameInput.maxLength = 10; nameInput.placeholder = '名前(任意)'; nameInput.oninput = (e) => { uploadedCollectionImages[index].name = e.target.value; };
          nameGroup.appendChild(nameLabel); nameGroup.appendChild(nameInput); detailDiv.appendChild(nameGroup);
          const foodGroup = document.createElement('div'); foodGroup.className = 'form-group';
          const foodLabel = document.createElement('label'); foodLabel.textContent = '好物:'; foodLabel.style.flexBasis = '50px';
          const foodSelect = document.createElement('select');
          ['未選択', 'いちご', 'にがうり', 'とうがらし', 'バナナ', 'レモン', 'ぶどう', 'かき'].forEach(food => { const option = document.createElement('option'); option.value = food; option.textContent = food === '未選択' ? '選択(任意)' : food; foodSelect.appendChild(option); });
          foodSelect.value = imgData.food; foodSelect.onchange = (e) => { uploadedCollectionImages[index].food = e.target.value; };
          foodGroup.appendChild(foodLabel); foodGroup.appendChild(foodSelect); detailDiv.appendChild(foodGroup);
          imageCollectionDetailsDiv.appendChild(detailDiv);
        });
        if (uploadedCollectionImages.length > 0) selectCollectionImageForDetail(0);
      }

      function closeCropperModal() {
        cropperModal.style.display = 'none';
        if (currentEditingUnitContext === 'unit-edit-modal' || currentEditingUnitContext === 'collection-edit-modal') modalOverlay.style.zIndex = '1040';
        else modalOverlay.style.display = 'none';
        if (cropper) cropper.destroy(); cropper = null; currentCropFinalizeCallback = null;
      }

      function resetImageUploadsAndInputs() {
        Object.keys(imageSlots).forEach(slotKey => {
          const slotUI = imageSlots[slotKey];
          slotUI.previewImg.style.display = 'none'; slotUI.previewImg.src = '#'; slotUI.uploadInput.value = '';
          slotUI.editBtn.disabled = true; slotUI.clearBtn.classList.add('hidden');
          slotUI.nameInput.value = ''; slotUI.foodSelect.value = '未選択';
          if (slotUI.orderSakiCheckbox) slotUI.orderSakiCheckbox.checked = false;
          if (slotUI.orderAtoCheckbox) slotUI.orderAtoCheckbox.checked = false;
          slotUI.data = null;
        });
        addUnitBorderVisibleCheckbox.checked = true; checkAddUnitButtonState();
        imageCollectionUploadInput.value = ''; uploadedCollectionImages = [];
        imageCollectionPreviewsDiv.innerHTML = ''; imageCollectionDetailsDiv.innerHTML = '';
        imageCollectionBorderCheckbox.checked = true; checkAddImageCollectionButtonState();
        if (clearImageCollectionButton) clearImageCollectionButton.classList.add('hidden');
      }

      function wrapTextAndMeasure(text, maxWidth, fontSize, font, lineHeightMultiplier) {
        const words = text.split(/(\s+|\n)/); const lines = []; let currentLine = ''; let maxLineWidth = 0;
        const originalFont = ctx.font; ctx.font = `${fontSize}px ${font}`;
        for (const word of words) {
          if (word === '\n') { lines.push(currentLine); maxLineWidth = Math.max(maxLineWidth, ctx.measureText(currentLine).width); currentLine = ''; continue; }
          if (word.trim() === '' && word.length > 0) { currentLine += word; continue; }
          const testLine = currentLine + word; const testWidth = ctx.measureText(testLine).width;
          if (testWidth > maxWidth && currentLine !== '' && maxWidth > 0) {
            const wordWidth = ctx.measureText(word).width;
            if (wordWidth > maxWidth) { lines.push(currentLine); maxLineWidth = Math.max(maxLineWidth, ctx.measureText(currentLine).width); lines.push(word); maxLineWidth = Math.max(maxLineWidth, wordWidth); currentLine = ''; }
            else { lines.push(currentLine); maxLineWidth = Math.max(maxLineWidth, ctx.measureText(currentLine).width); currentLine = word.trimStart(); }
          } else { currentLine = testLine; }
        }
        lines.push(currentLine); maxLineWidth = Math.max(maxLineWidth, ctx.measureText(currentLine).width);
        ctx.font = originalFont;
        const nonEmptyLines = lines.filter((line, index) => line.trim() !== '' || index < lines.length - 1 || lines.length === 1);
        const calculatedHeight = nonEmptyLines.length * fontSize * lineHeightMultiplier;
        return { linesArray: nonEmptyLines, calculatedWidth: maxLineWidth, calculatedHeight: calculatedHeight };
      }

      function drawCanvas() {
        const itemsToDraw = {
          units: units,
          groups: groups,
          connections: connections,
          textItems: textItems,
          drawnPaths: drawnPaths,
          drawnPathsInProgress: currentDrawingPath, // 現在描画中のパスも渡す
          selectedItem: selectedItem,
          connectFromItem: connectFromItem,
          itemsToGroup: itemsToGroup,
          isDrawing: isDrawing // 現在描画モードかどうか
        };
        const currentSettings = {
          scale: scale,
          originX: originX,
          originY: originY,
          mode: currentMode // 必要であれば現在の操作モードも渡す
        };
        drawAllElementsOnContext(ctx, canvas, itemsToDraw, currentSettings);
      }
      function performUnifySize(baseUnit, scope, targetUnitsArray = null) {
        if (!baseUnit) {
          console.error("performUnifySize: 基準ユニットが指定されていません。");
          return;
        }
        const baseWidth = baseUnit.width;
        const baseHeight = baseUnit.height;
        let affectedUnits = [];
        let unifiedCount = 0;

        console.log(`performUnifySize: scope=${scope}, baseUnit=${getItemDisplayName(baseUnit)}`);

        if (scope === 'all') {
          affectedUnits = units.filter(u => u.id !== baseUnit.id && u.type === baseUnit.type);
        } else if (scope === 'visible') {
          affectedUnits = units.filter(u => {
            if (u.id === baseUnit.id || u.type !== baseUnit.type) return false;
            const unitRect = { // ユニットの表示上の矩形
              left: u.x * scale + originX,
              top: u.y * scale + originY,
              right: (u.x + u.width) * scale + originX,
              bottom: (u.y + u.height) * scale + originY
            };
            const canvasRect = { // キャンバスの表示領域
              left: 0,
              top: 0,
              right: mainCanvasArea.clientWidth, // mainCanvasArea を使用
              bottom: mainCanvasArea.clientHeight
            };
            // 矩形が一部でも重なっていれば表示されているとみなす
            return unitRect.left < canvasRect.right && unitRect.right > canvasRect.left &&
              unitRect.top < canvasRect.bottom && unitRect.bottom > canvasRect.top;
          });
        } else if (scope === 'selected' && targetUnitsArray && targetUnitsArray.length > 0) {
          // targetUnitsArray は既に isTargetSelectedForUnify でフィルタリングされたものを受け取る想定だが、
          // 念のため、ここでも baseUnit とタイプが同じか確認する
          affectedUnits = targetUnitsArray.filter(u => u.id !== baseUnit.id && u.type === baseUnit.type);
        }

        if (affectedUnits.length === 0) {
          showStatusBar('対象となるユニットがありませんでした。', unifySizeButton);
          // 選択解除
          unifySizeTargetUnits.forEach(u => u.isTargetSelectedForUnify = false);
          unifySizeTargetUnits = [];
          drawCanvas();
          return;
        }

        affectedUnits.forEach(unit => {
          unit.width = baseWidth;
          // アスペクト比を無視して基準ユニットの高さに一旦合わせる
          unit.height = baseHeight;

          // 画像集合ユニットの場合、高さは内容に応じて再計算（オプション）
          if (unit.type === 'image-collection') {
            const newSize = calculateImageCollectionUnitSize(unit.images, unit.layoutSettings);
            // 幅はbaseWidthのまま、高さだけ内容に合わせる
            unit.height = newSize.height;
          }
          // 通常ユニットの場合も、最小高さを下回らないようにする (オプション)
          else if (unit.type === 'unit') {
            const minRequiredHeight = calculateUnitHeight(unit.slots);
            unit.height = Math.max(unit.height, minRequiredHeight);
          }

          if (unit.isTargetSelectedForUnify) { // isTargetSelectedForUnify が設定されていれば解除
            unit.isTargetSelectedForUnify = false;
          }
          unifiedCount++;
        });

        if (unifiedCount > 0) {
          showStatusBar(`${unifiedCount}個のユニットのサイズを統一しました。`, unifySizeButton);
          saveState();
          drawCanvas();
        }
        unifySizeTargetUnits.forEach(u => u.isTargetSelectedForUnify = false);
        unifySizeTargetUnits = [];
      }
      function drawArrowhead(ctx, fromX, fromY, toX, toY, lineWidth) {

        // 矢じりの翼の長さを調整
        const baseHeadLength = 20; // 矢じりの基本的な長さ
        const headLengthFactor = 4; // 線の太さに対する倍率
        const headLength = Math.max(baseHeadLength, lineWidth * headLengthFactor);

        // 矢じりの翼の開く角度 (ラジアン)。小さいほど鋭角に、大きいほど鈍角に。
        const arrowAngle = Math.PI / 7; // (Math.PI / 6 は30度)

        // 線分の角度を計算
        const angle = Math.atan2(toY - fromY, toX - fromX);

        const x1 = toX - headLength * Math.cos(angle - arrowAngle);
        const y1 = toY - headLength * Math.sin(angle - arrowAngle);

        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(x1, y1);
        ctx.stroke();

        const x2 = toX - headLength * Math.cos(angle + arrowAngle);
        const y2 = toY - headLength * Math.sin(angle + arrowAngle);

        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }

      function drawRoundedRect(ctx, x, y, width, height, radius) {
        ctx.beginPath(); ctx.moveTo(x + radius, y); ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius); ctx.quadraticCurveTo(x, y, x + radius, y); ctx.closePath();
      }

      function truncateText(text, maxLength) {
        if (!text) return '';
        return text.length > maxLength ? text.substring(0, maxLength - 1) + '…' : text;
      }

      function findItemById(id) {
        return units.find(u => u.id === id) || groups.find(g => g.id === id) || textItems.find(t => t.id === id);
      }

      function getCanvasCoordinates(event) {
        const rect = canvas.getBoundingClientRect(); let clientX, clientY;
        if (event.touches && event.touches.length > 0) { clientX = event.touches[0].clientX; clientY = event.touches[0].clientY; }
        else { clientX = event.clientX; clientY = event.clientY; }
        const canvasElementX = clientX - rect.left; const canvasElementY = clientY - rect.top;
        return { x: (canvasElementX - originX) / scale, y: (canvasElementY - originY) / scale };
      }

      function getResizeHandle(item, x, y) {
        if (!item || (item.type !== 'unit' && item.type !== 'group' && item.type !== 'text' && item.type !== 'image-collection')) return null;
        if (!selectedItem || selectedItem.id !== item.id) return null;
        const handleSize = BORDER_RESIZE_THRESHOLD / scale;
        const right = item.x + item.width; const bottom = item.y + item.height;
        const left = item.x; const top = item.y;
        const onRight = Math.abs(x - right) < handleSize; const onBottom = Math.abs(y - bottom) < handleSize;
        const onLeft = Math.abs(x - left) < handleSize; const onTop = Math.abs(y - top) < handleSize;
        if (onRight && onBottom) return 'bottom-right'; if (onLeft && onBottom) return 'bottom-left';
        if (onRight && onTop) return 'top-right'; if (onLeft && onTop) return 'top-left';
        if (onRight) return 'right'; if (onBottom) return 'bottom';
        if (onLeft) return 'left'; if (onTop) return 'top';
        return null;
      }
      function getLineMidpoint(lineId) {
        const line = connections.find(conn => conn.id === lineId);
        if (!line) {
          console.warn(`getLineMidpoint: Line with id ${lineId} not found.`);
          return null;
        }

        const fromItem = findItemById(line.fromId);
        const toItem = findItemById(line.toId);

        // 今回の制限では、元の線(lineId)のfromItemとtoItemは必ずユニットのはず
        if (!fromItem || !toItem || fromItem.id.startsWith('conn-') || toItem.id.startsWith('conn-')) {
          console.warn(`getLineMidpoint: Original line ${lineId} does not connect two non-line items.`);
          return null;
        }

        const startX = fromItem.x + fromItem.width / 2;
        const startY = fromItem.y + fromItem.height / 2;
        const endX = toItem.x + toItem.width / 2;
        const endY = toItem.y + toItem.height / 2;

        return { x: (startX + endX) / 2, y: (startY + endY) / 2, originalLineId: lineId }; // 元の線IDも返す
      }

      function handleInteractionStart(event) {
        if (event.touches && event.touches.length === 2 && !currentMode) {
          isPanning = false;
          draggingItem = null;
          resizingItem = null;
          selectedItem = null;

          isPinching = true;

          const t0 = event.touches[0];
          const t1 = event.touches[1];

          lastPinchDistance = Math.hypot(t1.clientX - t0.clientX, t1.clientY - t0.clientY);

          // ピンチ中心のスクリーン座標
          pinchStartScreenCenterX = (t0.clientX + t1.clientX) / 2;
          pinchStartScreenCenterY = (t0.clientY + t1.clientY) / 2;

          // ピンチ中心の現在のキャンバス座標 (ズームの中心を固定するため)
          const rect = canvas.getBoundingClientRect();
          const pinchStartCanvasX_onScreen = pinchStartScreenCenterX - rect.left;
          const pinchStartCanvasY_onScreen = pinchStartScreenCenterY - rect.top;
          pinchStartCanvasCenterX = (pinchStartCanvasX_onScreen - originX) / scale;
          pinchStartCanvasCenterY = (pinchStartCanvasY_onScreen - originY) / scale;

          canvas.style.cursor = 'move';
          return;
        }
        const coords = getCanvasCoordinates(event);
        let clickedItem = null;
        let clickedResizeHandleType = null;
        let clickedLine = null;

        if (!currentMode || currentMode !== 'draw-path') {
          let foundItem = null;
          const checkOrder = [...groups, ...units, ...textItems];

          for (let i = 0; i < checkOrder.length; i++) {
            const item = checkOrder[i];
            let itemBoundary = { x: item.x, y: item.y, width: item.width, height: item.height };

            if (item.type === 'group') {
              if (coords.x >= itemBoundary.x && coords.x <= itemBoundary.x + itemBoundary.width &&
                coords.y >= itemBoundary.y && coords.y <= itemBoundary.y + itemBoundary.height) {
                let unitInGroupClicked = false;
                for (const unitId of item.itemIds) {
                  const unitInGroup = findItemById(unitId);
                  if (unitInGroup &&
                    coords.x >= unitInGroup.x && coords.x <= unitInGroup.x + unitInGroup.width &&
                    coords.y >= unitInGroup.y && coords.y <= unitInGroup.y + unitInGroup.height) {
                    foundItem = unitInGroup;
                    unitInGroupClicked = true;
                    break;
                  }
                }
                if (!unitInGroupClicked) {
                  foundItem = item;
                }
                if (foundItem) break;
              }
            } else {
              const isItemInAGroup = groups.some(g => g.itemIds.includes(item.id));
              if (!isItemInAGroup ||
                currentMode === 'edit-item' ||
                (currentMode && currentMode.startsWith('unify-size'))
              ) {
                if (coords.x >= itemBoundary.x && coords.x <= itemBoundary.x + itemBoundary.width &&
                  coords.y >= itemBoundary.y && coords.y <= itemBoundary.y + itemBoundary.height) {
                  foundItem = item;
                  break;
                }
              }
            }
          }
          clickedItem = foundItem;
        }


        if (!clickedItem && (!currentMode || currentMode !== 'draw-path')) {
          let minDistanceSq = Infinity;
          const clickThresholdRadius = 10 / scale;
          const clickThresholdSq = clickThresholdRadius * clickThresholdRadius;

          for (const conn of connections) {
            if (conn.fromId.startsWith('conn-') || conn.toId.startsWith('conn-')) {
              continue;
            }

            const fromItem = findItemById(conn.fromId);
            const toItem = findItemById(conn.toId);

            if (fromItem && toItem) {
              const p1 = { x: fromItem.x + fromItem.width / 2, y: fromItem.y + fromItem.height / 2 };
              const p2 = { x: toItem.x + toItem.width / 2, y: toItem.y + toItem.height / 2 };

              const lenSq = (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
              if (lenSq === 0) continue;

              let t = ((coords.x - p1.x) * (p2.x - p1.x) + (coords.y - p1.y) * (p2.y - p1.y)) / lenSq;
              t = Math.max(0, Math.min(1, t));

              const closestPoint = {
                x: p1.x + t * (p2.x - p1.x),
                y: p1.y + t * (p2.y - p1.y)
              };
              const distanceSq = (coords.x - closestPoint.x) ** 2 + (coords.y - closestPoint.y) ** 2;

              if (distanceSq < minDistanceSq && distanceSq < clickThresholdSq) {
                minDistanceSq = distanceSq;
                clickedLine = conn;
              }
            }
          }
          if (clickedLine) {
            console.log("Clicked on line:", clickedLine.id);
          }
        }

        const targetForItemOrLine = clickedItem || clickedLine;

        if (currentMode === 'unify-size-select-base') {
          if (targetForItemOrLine && (targetForItemOrLine.type === 'unit' || targetForItemOrLine.type === 'image-collection')) {
            unifySizeBaseUnit = targetForItemOrLine;
            document.getElementById('unify-base-unit-name').textContent = getItemDisplayName(unifySizeBaseUnit);
            document.getElementById('unify-base-unit-size').textContent = `${unifySizeBaseUnit.width.toFixed(0)}x${unifySizeBaseUnit.height.toFixed(0)}`;
            openModal(document.getElementById('unify-size-options-modal'));
            unifySizeModeSubState = 'show-options';
            hideStatusBar();
          } else if (targetForItemOrLine) {
            showStatusBar('基準としてユニットまたは画像集合ユニットを選択してください。', unifySizeButton);
          }
          return;
        } else if (currentMode === 'unify-size-select-targets') {
          if (targetForItemOrLine && (targetForItemOrLine.type === 'unit' || targetForItemOrLine.type === 'image-collection')) {
            if (unifySizeBaseUnit && targetForItemOrLine.id === unifySizeBaseUnit.id) {
              showStatusBar('基準ユニット自身は対象として選択できません。', unifySizeButton);
            } else {
              const index = unifySizeTargetUnits.findIndex(u => u.id === targetForItemOrLine.id);
              if (index > -1) {
                unifySizeTargetUnits.splice(index, 1);
                targetForItemOrLine.isTargetSelectedForUnify = false;
              } else {
                unifySizeTargetUnits.push(targetForItemOrLine);
                targetForItemOrLine.isTargetSelectedForUnify = true;
              }
              showStatusBar(`${unifySizeTargetUnits.length}個のユニットを選択中。完了したら「選択完了」ボタン。`, unifySizeButton);
              drawCanvas();
            }
          } else if (targetForItemOrLine) {
            showStatusBar('対象としてユニットまたは画像集合ユニットを選択してください。', unifySizeButton);
          }
          return;
        }
        if (currentMode === 'align-select-base') {
          if (clickedItem && (clickedItem.type === 'unit' || clickedItem.type === 'image-collection')) {
            alignBaseUnit = clickedItem;
            alignBaseUnit.isAlignmentBase = true;

            currentMode = 'align-select-targets';
            if (alignButton) {
              alignButton.textContent = '整列方法選択';
              alignButton.dataset.originalText = "整列";
            }
            showStatusBar(
              modeMessages['align-select-targets'] + ` (基準: ${getItemDisplayName(alignBaseUnit)})`,
              alignButton
            );
            console.log("基準ユニット選択:", getItemDisplayName(alignBaseUnit));
          } else if (targetForItemOrLine) {
            showStatusBar('整列の基準としてユニットまたは画像集合ユニットを選択してください。', alignButton);
          } else { // 背景クリック
            // 何もしないか、モードをキャンセルするか選べる (今回は何もしない)
          }
          drawCanvas();
          return;
        }
        else if (currentMode === 'align-select-targets') {
          if (clickedItem && (clickedItem.type === 'unit' || clickedItem.type === 'image-collection')) {
            if (alignBaseUnit && clickedItem.id === alignBaseUnit.id) {
              showStatusBar('基準ユニット自身は対象として選択できません。', alignButton);
            } else {
              const index = alignTargetUnits.findIndex(u => u.id === clickedItem.id);
              if (index > -1) {
                alignTargetUnits.splice(index, 1);
                clickedItem.isTargetForAlignment = false;
              } else {
                alignTargetUnits.push(clickedItem);
                clickedItem.isTargetForAlignment = true;
              }
              showStatusBar(
                `対象 ${alignTargetUnits.length}個選択中。基準: ${getItemDisplayName(alignBaseUnit)}`,
                alignButton
              );
              console.log("対象ユニット選択:", alignTargetUnits.map(u => getItemDisplayName(u)));
            }
          } else if (targetForItemOrLine) {
            showStatusBar('整列の対象としてユニットまたは画像集合ユニットを選択してください。', alignButton);
          }
          drawCanvas();
          return;
        }

        if (currentMode === 'draw-path') {
          isDrawing = true;
          currentDrawingPath = [{
            type: drawingShape,
            color: drawingShape === 'eraser' ? (canvas.style.backgroundColor || '#fdfdfd') : drawingColor,
            lineWidth: drawingLineWidth,
            points: [[coords.x, coords.y]],
            isFilled: (drawingShape === 'rectangle' || drawingShape === 'circle') ? drawingFillCheckbox.checked : false,
            startX: coords.x,
            startY: coords.y
          }];
          drawCanvas();
          return;
        }

        if (selectedItem && !currentMode && !targetForItemOrLine) {
          clickedResizeHandleType = getResizeHandle(selectedItem, coords.x, coords.y);
          if (clickedResizeHandleType) {
            resizingItem = selectedItem;
            resizeHandle = clickedResizeHandleType;
            canvas.style.cursor = getResizeCursor(resizeHandle);
            canvas.classList.add('resizing');
            dragOffsetX = coords.x;
            dragOffsetY = coords.y;
            return;
          }
        }


        if (!resizingItem) {
          if (currentMode === 'connect') {
            // ... (前回の connect モードの処理はここにそのまま入ります) ...
            if (!connectFromItem) { // 接続元がまだ選択されていない場合
              if (targetForItemOrLine) { // 何かアイテムか線がクリックされた
                if (targetForItemOrLine.type === 'text') {
                  showStatusBar('テキストアイテムは接続元にできません。', connectButton);
                } else {
                  connectFromItem = targetForItemOrLine;
                  const fromType = targetForItemOrLine.id.startsWith('conn-') ? `線(${truncateText(targetForItemOrLine.id, 10)})` : getItemDisplayName(targetForItemOrLine);
                  showStatusBar(`接続元(${fromType})選択 - 接続先のユニットまたは線を選択`, connectButton);
                }
              }
            } else { // 接続元(connectFromItem)が既に選択されている場合 (これから接続先を選択する)
              if (targetForItemOrLine) {
                if (targetForItemOrLine.id === connectFromItem.id) {
                  showStatusBar('同じアイテム(または線)には接続できません。', connectButton);
                } else if (connectFromItem.id.startsWith('conn-') && targetForItemOrLine.id.startsWith('conn-')) {
                  showStatusBar('線と線を直接接続することはできません。ユニットを選択してください。', connectButton);
                } else if (targetForItemOrLine.type === 'text') {
                  showStatusBar('テキストアイテムは接続先にできません。', connectButton);
                } else {
                  let newConnectionMade = false;
                  let connectionStatusMessage = "";
                  if (!connectFromItem.id.startsWith('conn-') && targetForItemOrLine.id.startsWith('conn-')) {
                    const unitToConnect = connectFromItem;
                    const lineToConnectTo = targetForItemOrLine;
                    const lineMidpoint = getLineMidpoint(lineToConnectTo.id);
                    if (unitToConnect && unitToConnect.type !== 'text' && lineMidpoint) {
                      const newConnectionId = `conn-${nextItemId++}`;
                      connections.push({ id: newConnectionId, fromId: unitToConnect.id, toId: lineToConnectTo.id, isUnitToLine: true, color: '#555555', lineWidth: 10, dashArray: [] });
                      connectionStatusMessage = `接続(U→L): ${getItemDisplayName(unitToConnect)} -> 線(${truncateText(lineToConnectTo.id, 10)})`;
                      newConnectionMade = true;
                    } else { connectionStatusMessage = 'エラー: U→L 接続情報不足'; if (unitToConnect && unitToConnect.type === 'text') connectionStatusMessage = 'エラー: U→L テキスト不可'; }
                  } else if (connectFromItem.id.startsWith('conn-') && targetForItemOrLine && !targetForItemOrLine.id.startsWith('conn-')) {
                    const lineToConnectFrom = connectFromItem;
                    const unitToConnectTo = targetForItemOrLine;
                    const lineMidpoint = getLineMidpoint(lineToConnectFrom.id);
                    if (lineMidpoint && unitToConnectTo && unitToConnectTo.type !== 'text') {
                      const newConnectionId = `conn-${nextItemId++}`;
                      connections.push({ id: newConnectionId, fromId: lineToConnectFrom.id, toId: unitToConnectTo.id, isLineToUnit: true, color: '#555555', lineWidth: 10, dashArray: [] });
                      connectionStatusMessage = `接続(L→U): 線(${truncateText(lineToConnectFrom.id, 10)}) -> ${getItemDisplayName(unitToConnectTo)}`;
                      newConnectionMade = true;
                    } else { connectionStatusMessage = 'エラー: L→U 接続情報不足'; if (unitToConnectTo && unitToConnectTo.type === 'text') connectionStatusMessage = 'エラー: L→U テキスト不可'; }
                  } else if (!connectFromItem.id.startsWith('conn-') && targetForItemOrLine && !targetForItemOrLine.id.startsWith('conn-')) {
                    const unitFrom = connectFromItem;
                    const unitTo = targetForItemOrLine;
                    if (unitFrom.type !== 'text' && unitTo.type !== 'text' && unitFrom.type && unitTo.type) {
                      const newConnectionId = `conn-${nextItemId++}`;
                      connections.push({ id: newConnectionId, fromId: unitFrom.id, toId: unitTo.id, color: '#555555', lineWidth: 10, dashArray: [] });
                      connectionStatusMessage = `接続(U→U): ${getItemDisplayName(unitFrom)} -> ${getItemDisplayName(unitTo)}`;
                      newConnectionMade = true;
                    } else { connectionStatusMessage = "エラー: U→U 不明なアイテムタイプです。"; }
                  } else { connectionStatusMessage = "無効な接続の組み合わせです。"; console.warn("Invalid connection combination attempt:", connectFromItem, targetForItemOrLine); }

                  if (newConnectionMade) {
                    showStatusBar(connectionStatusMessage, connectButton);
                    saveState();
                    connectFromItem = null;
                  } else {
                    if (connectionStatusMessage) showStatusBar(connectionStatusMessage, connectButton);
                    else showStatusBar("接続できませんでした。対象を確認してください。", connectButton);
                  }
                }
              } else {
                if (connectFromItem) {
                  const fromType = connectFromItem.id.startsWith('conn-') ? `線(${truncateText(connectFromItem.id, 10)})` : getItemDisplayName(connectFromItem);
                  showStatusBar(`接続元(${fromType})の選択を解除。再度接続元を選択してください。`, connectButton);
                  connectFromItem = null;
                }
              }
            }
            // connect モードの処理はここまで。drawCanvasは関数の最後に。
          }
          else if (currentMode === 'grouping') {
            if (clickedItem && (clickedItem.type === 'unit' || clickedItem.type === 'image-collection' || clickedItem.type === 'text')) {
              const index = itemsToGroup.findIndex(item => item.id === clickedItem.id);
              if (index > -1) {
                itemsToGroup.splice(index, 1);
                if (clickedItem.isBeingGrouped) clickedItem.isBeingGrouped = false;
              } else {
                itemsToGroup.push(clickedItem);
                clickedItem.isBeingGrouped = true;
              }
              showStatusBar(
                `${itemsToGroup.length}個選択中。${itemsToGroup.length >= 2 ? '「決定」ボタンでグループ化。' : '2個以上選択して「決定」ボタン。'}`,
                groupButton
              );
            } else if (targetForItemOrLine) {
              showStatusBar("グループ化対象外です。ユニット、画像集合、またはテキストを選択してください。", groupButton);
            }
            // 背景クリック時は何もしない
          }
          // ▼▼▼ ここに edit-item モードの処理を正しく挿入 ▼▼▼
          else if (currentMode === 'edit-item') {
            if (clickedItem) { // アイテムがクリックされた場合
              if (clickedItem.type === 'unit') openUnitEditModal(clickedItem);
              else if (clickedItem.type === 'group') openGroupEditModal(clickedItem);
              else if (clickedItem.type === 'text') openTextEditModal(clickedItem);
              else if (clickedItem.type === 'image-collection') openImageCollectionEditModal(clickedItem);
            } else if (clickedLine) { // 線がクリックされた場合
              openLineStyleEditModal(clickedLine);
            }
            // 背景クリック時は何もしない (モード継続)
          }
          // ▲▲▲ ここまで edit-item モードの処理 ▲▲▲
          else if (targetForItemOrLine) { // 通常モードでアイテムがクリックされた場合
            selectedItem = targetForItemOrLine;
            if (!currentMode) { // currentMode が null (通常モード) の場合のみドラッグ開始
              if (clickedItem) { // アイテムが実際に存在する場合
                draggingItem = clickedItem;
                dragOffsetX = coords.x - clickedItem.x;
                dragOffsetY = coords.y - clickedItem.y;
                canvas.classList.add('dragging');
                canvas.style.cursor = 'grabbing';
              }
            }
            // 他のモード(align, unify-size)は関数の前半でreturnしているので、ここは主に通常モードの処理
          } else { // 背景クリック (かつ、上記どのモードでもない or モード中のアイテム外クリック)
            if (!currentMode) { // 通常モードで背景クリック
              selectedItem = null;
              isPanning = true;
              lastPanX = event.touches ? event.touches[0].clientX : event.clientX;
              lastPanY = event.touches ? event.touches[0].clientY : event.clientY;
              canvas.style.cursor = 'grabbing';
            }
            // 他のモード中の背景クリックは、それぞれのモードの先頭で処理されているか、
            // ここに来る場合は特に何もしない（モード継続）ことが多い。
          }
        }
        drawCanvas();
      }

      function handleInteractionMove(event) {
        if (isPinching && event.touches && event.touches.length === 2 && !currentMode) {
          event.preventDefault();
          const t0 = event.touches[0];
          const t1 = event.touches[1];

          const currentPinchDistance = Math.hypot(t1.clientX - t0.clientX, t1.clientY - t0.clientY);

          if (lastPinchDistance > 0) {
            const scaleFactor = currentPinchDistance / lastPinchDistance;
            const newScale = scale * scaleFactor;

            // スケールの制限（例）
            // const minScale = 0.1;
            // const maxScale = 10.0;
            // scale = Math.max(minScale, Math.min(maxScale, newScale));
            scale = newScale;

            const currentScreenCenterX = (t0.clientX + t1.clientX) / 2;
            const currentScreenCenterY = (t0.clientY + t1.clientY) / 2;

            const rect = canvas.getBoundingClientRect();
            originX = (currentScreenCenterX - rect.left) - (pinchStartCanvasCenterX * scale);
            originY = (currentScreenCenterY - rect.top) - (pinchStartCanvasCenterY * scale);

            lastPinchDistance = currentPinchDistance;

            const base = 1.2;
            zoomLevel = Math.log(scale) / Math.log(base);
            zoomLevelIndicator.textContent = Math.round(zoomLevel);
          } else {
            lastPinchDistance = currentPinchDistance;
          }

          drawCanvas();
          return;
        }
        if (currentMode === 'draw-path') {
          if (!isDrawing) {
            return;
          }
          event.preventDefault();

          const coords = getCanvasCoordinates(event);

          if (currentDrawingPath.length > 0) {
            const currentPathObject = currentDrawingPath[0];
            if (currentPathObject && currentPathObject.points) {

              if (currentPathObject.type === 'line' || currentPathObject.type === 'eraser' || currentPathObject.type === 'arrow') {
                currentPathObject.points.push([coords.x, coords.y]);
              } else if (currentPathObject.type === 'rectangle' || currentPathObject.type === 'circle') {
                if (currentPathObject.points.length === 1) {
                  currentPathObject.points.push([coords.x, coords.y]);
                } else if (currentPathObject.points.length === 2) {
                  currentPathObject.points[1] = [coords.x, coords.y];
                }
              }
            }
          }
          drawCanvas();
          return;
        }

        event.preventDefault();
        const coords = getCanvasCoordinates(event);

        if (resizingItem && resizeHandle) {
          const dx = coords.x - dragOffsetX; const dy = coords.y - dragOffsetY;
          let minWidth, minHeight; const textPadding = TEXT_ITEM_PADDING;
          if (resizingItem.type === 'text') { minWidth = MIN_TEXT_ITEM_WIDTH; minHeight = MIN_TEXT_ITEM_HEIGHT; }
          else if (resizingItem.type === 'unit') { minWidth = UNIT_WIDTH_ONE_SLOT; minHeight = calculateUnitHeight(resizingItem.slots); }
          else if (resizingItem.type === 'image-collection') { const minSize = calculateImageCollectionUnitSize(resizingItem.images || [], resizingItem.layoutSettings); minWidth = minSize.width; minHeight = minSize.height; }
          else { minWidth = 50; minHeight = 50; } // group
          let newWidth = resizingItem.width, newHeight = resizingItem.height, newX = resizingItem.x, newY = resizingItem.y;
          switch (resizeHandle) {
            case 'bottom-right': newWidth = Math.max(resizingItem.width + dx, minWidth); newHeight = Math.max(resizingItem.height + dy, minHeight); break;
            case 'right': newWidth = Math.max(resizingItem.width + dx, minWidth); break;
            case 'left': const pLW = resizingItem.width - dx; if (pLW >= minWidth) { newWidth = pLW; newX = resizingItem.x + dx; } else { newWidth = minWidth; newX = resizingItem.x + (resizingItem.width - minWidth); } break;
            case 'bottom': newHeight = Math.max(resizingItem.height + dy, minHeight); break;
            case 'top': const pTH = resizingItem.height - dy; if (pTH >= minHeight) { newHeight = pTH; newY = resizingItem.y + dy; } else { newHeight = minHeight; newY = resizingItem.y + (resizingItem.height - minHeight); } break;
            case 'top-left': const ptlW = resizingItem.width - dx, ptlH = resizingItem.height - dy; if (ptlW >= minWidth) { newWidth = ptlW; newX = resizingItem.x + dx; } else { newWidth = minWidth; newX = resizingItem.x + (resizingItem.width - minWidth); } if (ptlH >= minHeight) { newHeight = ptlH; newY = resizingItem.y + dy; } else { newHeight = minHeight; newY = resizingItem.y + (resizingItem.height - minHeight); } break;
            case 'top-right': newWidth = Math.max(resizingItem.width + dx, minWidth); const ptrH = resizingItem.height - dy; if (ptrH >= minHeight) { newHeight = ptrH; newY = resizingItem.y + dy; } else { newHeight = minHeight; newY = resizingItem.y + (resizingItem.height - minHeight); } break;
            case 'bottom-left': const pblW = resizingItem.width - dx; newHeight = Math.max(resizingItem.height + dy, minHeight); if (pblW >= minWidth) { newWidth = pblW; newX = resizingItem.x + dx; } else { newWidth = minWidth; newX = resizingItem.x + (resizingItem.width - minWidth); } break;
          }
          if (resizingItem.type === 'group') {
            let cMinX = Infinity, cMinY = Infinity, cMaxX = -Infinity, cMaxY = -Infinity; let hUIG = false;
            resizingItem.itemIds.forEach(id => { const uIG = findItemById(id); if (uIG) { hUIG = true; cMinX = Math.min(cMinX, uIG.x); cMinY = Math.min(cMinY, uIG.y); cMaxX = Math.max(cMaxX, uIG.x + uIG.width); cMaxY = Math.max(cMaxY, uIG.y + uIG.height); } });
            if (hUIG) { const rCW = cMaxX - cMinX; const rCH = cMaxY - cMinY; const mGW = rCW + GROUP_PADDING * 2; const mGH = rCH + GROUP_PADDING * 2; newWidth = Math.max(newWidth, mGW); newHeight = Math.max(newHeight, mGH); if (resizeHandle.includes('left')) { newX = Math.min(newX, cMinX - GROUP_PADDING); if (newX + newWidth < cMaxX + GROUP_PADDING) newWidth = cMaxX + GROUP_PADDING - newX; } else { if (newX + newWidth < cMaxX + GROUP_PADDING) newWidth = cMaxX + GROUP_PADDING - newX; } if (resizeHandle.includes('top')) { newY = Math.min(newY, cMinY - GROUP_PADDING); if (newY + newHeight < cMaxY + GROUP_PADDING) newHeight = cMaxY + GROUP_PADDING - newY; } else { if (newY + newHeight < cMaxY + GROUP_PADDING) newHeight = cMaxY + GROUP_PADDING - newY; } newWidth = Math.max(newWidth, mGW); newHeight = Math.max(newHeight, mGH); }
          } else if (resizingItem.type === 'unit') {
            const pG = groups.find(g => g.itemIds.includes(resizingItem.id));
            if (pG) { const gIL = pG.x + GROUP_PADDING, gIT = pG.y + GROUP_PADDING, gIR = pG.x + pG.width - GROUP_PADDING, gIB = pG.y + pG.height - GROUP_PADDING; if (newX < gIL) { newWidth = resizingItem.x + resizingItem.width - gIL; newX = gIL; } if (newY < gIT) { newHeight = resizingItem.y + resizingItem.height - gIT; newY = gIT; } if (newX + newWidth > gIR) newWidth = gIR - newX; if (newY + newHeight > gIB) newHeight = gIB - newY; newWidth = Math.max(newWidth, minWidth); newHeight = Math.max(newHeight, minHeight); if (newX + newWidth > gIR) newX = gIR - newWidth; if (newY + newHeight > gIB) newY = gIB - newHeight; if (newX < gIL) newX = gIL; if (newY < gIT) newY = gIT; }
          } else if (resizingItem.type === 'image-collection') {
            const newCalculatedSize = calculateImageCollectionUnitSize(resizingItem.images, resizingItem.layoutSettings);
            if (resizeHandle.includes('right') || resizeHandle.includes('left')) newHeight = newCalculatedSize.height;
            else if (resizeHandle.includes('top') || resizeHandle.includes('bottom')) newWidth = newCalculatedSize.width;
            else { newWidth = Math.max(newWidth, newCalculatedSize.width); newHeight = newCalculatedSize.height; }
          }
          resizingItem.width = newWidth; resizingItem.height = newHeight; resizingItem.x = newX; resizingItem.y = newY;
          if (resizingItem.type === 'text' && ['left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right'].includes(resizeHandle)) { const cMW = resizingItem.width - (textPadding * 2); if (cMW > 0) { const m = wrapTextAndMeasure(resizingItem.text, cMW, resizingItem.fontSize, resizingItem.font || DEFAULT_FONT, TEXT_LINE_HEIGHT_MULTIPLIER); const nCH = m.calculatedHeight + (textPadding * 2); resizingItem.height = Math.max(minHeight, nCH); } else { resizingItem.height = minHeight; } }
          dragOffsetX = coords.x; dragOffsetY = coords.y; drawCanvas();
        } else if (draggingItem && !currentMode) {
          const targetX = coords.x - dragOffsetX; const targetY = coords.y - dragOffsetY;
          let snappedX = targetX; let snappedY = targetY;
          if (draggingItem.type === 'unit' || draggingItem.type === 'image-collection') {
            const itemConnections = connections.filter(c => c.fromId === draggingItem.id || c.toId === draggingItem.id);
            if (itemConnections.length > 0) {
              const conn = itemConnections[0]; const otherItemId = conn.fromId === draggingItem.id ? conn.toId : conn.fromId;
              const otherItem = findItemById(otherItemId);
              if (otherItem) {
                const dC = { x: targetX + draggingItem.width / 2, y: targetY + draggingItem.height / 2 }; const oC = { x: otherItem.x + otherItem.width / 2, y: otherItem.y + otherItem.height / 2 };
                const dXAbs = Math.abs(dC.x - oC.x); const dYAbs = Math.abs(dC.y - oC.y);
                const currentSnapThreshold = SNAP_THRESHOLD / scale;
                if (dYAbs < currentSnapThreshold && dXAbs > dYAbs * SNAP_RATIO) snappedY = oC.y - draggingItem.height / 2;
                else if (dXAbs < currentSnapThreshold && dYAbs > dXAbs * SNAP_RATIO) snappedX = oC.x - draggingItem.width / 2;
              }
            }
          }
          const finalDeltaX = snappedX - draggingItem.x; const finalDeltaY = snappedY - draggingItem.y;
          if (draggingItem.type === 'unit' || draggingItem.type === 'image-collection' || draggingItem.type === 'text') {
            const parentGroup = groups.find(g => g.itemIds.includes(draggingItem.id));
            if (parentGroup) {
              snappedX = Math.max(parentGroup.x + GROUP_PADDING, Math.min(snappedX, parentGroup.x + parentGroup.width - GROUP_PADDING - draggingItem.width));
              snappedY = Math.max(parentGroup.y + GROUP_PADDING, Math.min(snappedY, parentGroup.y + parentGroup.height - GROUP_PADDING - draggingItem.height));
            }
          }
          draggingItem.x = snappedX; draggingItem.y = snappedY;
          if (draggingItem.type === 'group') { draggingItem.itemIds.forEach(unitId => { const uIG = findItemById(unitId); if (uIG) { uIG.x += finalDeltaX; uIG.y += finalDeltaY; } }); }
          drawCanvas();
        }
        else if (isPanning) { const cX = event.touches ? event.touches[0].clientX : event.clientX; const cY = event.touches ? event.touches[0].clientY : event.clientY; originX += cX - lastPanX; originY += cY - lastPanY; lastPanX = cX; lastPanY = cY; drawCanvas(); }
        else if (selectedItem && !currentMode) { const hT = getResizeHandle(selectedItem, coords.x, coords.y); if (hT) { canvas.style.cursor = getResizeCursor(hT); canvas.classList.add('resize-handle-hover'); } else { canvas.style.cursor = 'grab'; canvas.classList.remove('resize-handle-hover'); } }
      }

      function handleInteractionEnd(event) {
        if (isPinching && (!event.touches || event.touches.length < 2)) {
          isPinching = false;
          canvas.style.cursor = currentMode ? (currentMode === 'edit-item' ? 'pointer' : (currentMode === 'draw-path' ? 'crosshair' : 'crosshair')) : 'grab';
          saveState();
        }
        if (isDrawing && currentMode === 'draw-path') {
          isDrawing = false;
          if (currentDrawingPath.length > 0 && currentDrawingPath[0].points.length >= 1) {
            const pathObj = currentDrawingPath[0];
            if ((pathObj.type === 'line' || pathObj.type === 'eraser') && pathObj.points.length < 2) {
              currentDrawingPath = [];
            }
            else if ((pathObj.type === 'rectangle' || pathObj.type === 'circle') &&
              pathObj.points.length === 2 &&
              pathObj.points[0][0] === pathObj.points[1][0] &&
              pathObj.points[0][1] === pathObj.points[1][1]) {
              currentDrawingPath = [];
            }

            if (currentDrawingPath.length > 0) {
              drawnPaths.push(...currentDrawingPath);
              currentDrawingPath = [];
              saveDrawingState();
            }
          } else {
            currentDrawingPath = [];
          }
        } else {
          if (resizingItem && resizingItem.type === 'image-collection') {
            const finalSize = calculateImageCollectionUnitSize(resizingItem.images, resizingItem.layoutSettings);
            resizingItem.width = Math.max(finalSize.width, resizingItem.width);
            resizingItem.height = finalSize.height;
          }
          else if (resizingItem && resizingItem.type === 'text' && ['left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right'].includes(resizeHandle)) {
            const textPaddingForCalc = TEXT_ITEM_PADDING;
            const contentMaxWidth = resizingItem.width - (textPaddingForCalc * 2);
            let minHeight = Math.max(MIN_TEXT_ITEM_HEIGHT, resizingItem.fontSize * TEXT_LINE_HEIGHT_MULTIPLIER + (textPaddingForCalc * 2));
            if (contentMaxWidth > 0) {
              const m = wrapTextAndMeasure(resizingItem.text, contentMaxWidth, resizingItem.fontSize, resizingItem.font || DEFAULT_FONT, TEXT_LINE_HEIGHT_MULTIPLIER);
              const finalHeight = m.calculatedHeight + (textPaddingForCalc * 2);
              resizingItem.height = Math.max(minHeight, finalHeight);
            } else { resizingItem.height = minHeight; }
          }
          else if (resizingItem && resizingItem.type === 'unit') {
            const minRequiredHeight = calculateUnitHeight(resizingItem.slots);
            resizingItem.height = Math.max(resizingItem.height, minRequiredHeight);
            const parentGroup = groups.find(g => g.itemIds.includes(resizingItem.id));
            if (parentGroup) { /* ... (unit in group resize end limits) ... */ }
          }
          else if (resizingItem && resizingItem.type === 'group') {
            let cMinX = Infinity, cMinY = Infinity, cMaxX = -Infinity, cMaxY = -Infinity; let hUIG = false;
            resizingItem.itemIds.forEach(id => { const uIG = findItemById(id); if (uIG) { hUIG = true; cMinX = Math.min(cMinX, uIG.x); cMinY = Math.min(cMinY, uIG.y); cMaxX = Math.max(cMaxX, uIG.x + uIG.width); cMaxY = Math.max(cMaxY, uIG.y + uIG.height); } });
            if (hUIG) { const rCW = cMaxX - cMinX, rCH = cMaxY - cMinY; const mGW = rCW + GROUP_PADDING * 2, mGH = rCH + GROUP_PADDING * 2; resizingItem.width = Math.max(resizingItem.width, mGW); resizingItem.height = Math.max(resizingItem.height, mGH); if (resizingItem.x + GROUP_PADDING > cMinX) resizingItem.x = cMinX - GROUP_PADDING; if (resizingItem.y + GROUP_PADDING > cMinY) resizingItem.y = cMinY - GROUP_PADDING; if (resizingItem.x + resizingItem.width - GROUP_PADDING < cMaxX) resizingItem.x = cMaxX + GROUP_PADDING - resizingItem.width; if (resizingItem.y + resizingItem.height - GROUP_PADDING < cMaxY) resizingItem.y = cMaxY + GROUP_PADDING - resizingItem.height; resizingItem.width = Math.max(resizingItem.width, mGW); resizingItem.height = Math.max(resizingItem.height, mGH); }
          }

          if ((draggingItem || resizingItem) && !currentMode) {
            saveState();
          }
        }

        isDrawing = false;
        if (draggingItem) canvas.classList.remove('dragging');
        if (resizingItem) canvas.classList.remove('resizing');
        draggingItem = null; resizingItem = null; resizeHandle = null;
        if (isPanning) isPanning = false;
        canvas.classList.remove('resize-handle-hover');
        canvas.style.cursor = currentMode ? (currentMode === 'edit-item' ? 'pointer' : (currentMode === 'draw-path' ? 'crosshair' : 'crosshair')) : 'grab';
        drawCanvas();
      }

      function toggleMode(newMode, buttonElement) {
        const unifySizeButton = document.getElementById('unify-size-button');
        const unifySizeCompleteSelectionBtn = document.getElementById('unify-size-complete-selection-btn');
        const unifyOptionsModal = document.getElementById('unify-size-options-modal');

        if (currentModeButtonElement) {
          if (currentModeButtonElement.dataset.originalText) {
            currentModeButtonElement.textContent = currentModeButtonElement.dataset.originalText;
          } else if (currentModeButtonElement.title) {
            currentModeButtonElement.textContent = currentModeButtonElement.title.split('(')[0].trim();
          } else {
            let originalText = "ボタン";
            const btnId = currentModeButtonElement.id;
            if (btnId === 'connect-button') originalText = "接続";
            else if (btnId === 'edit-unit-button') originalText = "編集";
            else if (btnId === 'group-button') originalText = "まとめる";
            else if (btnId === 'unify-size-button') originalText = "サイズ統一";
            else if (btnId === 'draw-mode-button') originalText = "描画";
            else if (btnId === 'align-button') originalText = "整列";
            currentModeButtonElement.textContent = originalText;
          }
          currentModeButtonElement.classList.remove('active-mode-button');
        }

        if (currentMode && currentMode.startsWith('unify-size') && (!newMode || !newMode.startsWith('unify-size'))) {
          unifySizeModeSubState = null;
          unifySizeBaseUnit = null;
          unifySizeTargetUnits.forEach(u => u.isTargetSelectedForUnify = false);
          unifySizeTargetUnits = [];
          if (unifySizeCompleteSelectionBtn) unifySizeCompleteSelectionBtn.style.display = 'none';
          if (unifyOptionsModal && unifyOptionsModal.style.display !== 'none') closeModal(unifyOptionsModal);
        }

        if (currentMode && currentMode.startsWith('align') && (!newMode || !newMode.startsWith('align'))) {
          if (alignBaseUnit) {
            alignBaseUnit.isAlignmentBase = false;
          }
          alignBaseUnit = null;

          if (alignTargetUnits.length > 0) {
            alignTargetUnits.forEach(u => {
              if (u) u.isTargetForAlignment = false;
            });
          }
          alignTargetUnits = [];

          if (alignButton && alignButton.dataset.originalText) {
            alignButton.textContent = alignButton.dataset.originalText;
            alignButton.classList.remove('active-mode-button');
          }
        }

        canvas.classList.remove('mode-active', 'connect-mode-active', 'edit-mode', 'grouping');
        if (drawingToolsPanel && (!newMode || newMode !== 'draw-path')) {
          drawingToolsPanel.style.display = 'none';
        }

        if (currentMode === newMode || newMode === null) {
          currentMode = null;
          currentModeButtonElement = null;
          connectFromItem = null;
          itemsToGroup = [];
          hideStatusBar();
          canvas.style.cursor = 'grab';
        } else {
          currentMode = newMode;
          currentModeButtonElement = buttonElement;

          if (buttonElement) {
            if (!buttonElement.dataset.originalText) {
              buttonElement.dataset.originalText = buttonElement.textContent;
            }
            if (newMode === 'grouping') {
              buttonElement.textContent = '決定'; // グループ化モードなら「決定」
            } else if (newMode && (newMode.startsWith('align') || newMode === 'connect' || newMode === 'edit-item' || newMode === 'draw-path' || newMode.startsWith('unify-size'))) {
              // align, connect, edit-item, draw-path, unify-size モードなら「キャンセル」
              buttonElement.textContent = 'キャンセル';
            } else {
              // その他の場合や、もしものためにデフォルトの「キャンセル」
              buttonElement.textContent = 'キャンセル';
            }
            buttonElement.classList.add('active-mode-button');
          }

          showStatusBar(modeMessages[currentMode] || `モード: ${currentMode}`, buttonElement);
          canvas.classList.add('mode-active');

          if (newMode === 'draw-path') {
            if (drawingToolsPanel) drawingToolsPanel.style.display = 'block';
            canvas.style.cursor = 'crosshair';
            updateFillOptionVisibility();
            resetDrawingHistory();
          } else if (newMode === 'edit-item') {
            canvas.classList.add('edit-mode');
            canvas.style.cursor = 'pointer';
          } else if (newMode === 'grouping') {
            canvas.classList.add('grouping');
            canvas.style.cursor = 'cell';
            itemsToGroup.forEach(it => it.isBeingGrouped = false);
            itemsToGroup = [];
          } else if (newMode.startsWith('unify-size')) {
            canvas.style.cursor = 'pointer';
            if (newMode === 'unify-size-select-base') {
              unifySizeModeSubState = 'select-base';
            }
            if (unifySizeCompleteSelectionBtn) {
              if (newMode === 'unify-size-select-targets') {
                unifySizeCompleteSelectionBtn.style.display = 'inline-block';
              } else {
                unifySizeCompleteSelectionBtn.style.display = 'none';
              }
            }
          } else if (newMode.startsWith('align')) {
            canvas.style.cursor = 'pointer';
            if (newMode === 'align-select-base') {
              // 基準選択開始時の特別な処理は今のところなし
            }
          } else {
            canvas.style.cursor = 'crosshair';
          }
        }
        drawCanvas();
      }

      function showStatusBar(message, buttonElement) {
        statusBar.textContent = message;
        if (buttonElement) {
          const buttonStyle = window.getComputedStyle(buttonElement);
          statusBar.style.backgroundColor = buttonStyle.backgroundColor;
          const bgColor = buttonStyle.backgroundColor;
          if (bgColor.includes('rgb')) {
            try { const rgb = bgColor.match(/\d+/g).map(Number); const luminance = 0.299 * rgb[0] + 0.587 * rgb[1] + 0.114 * rgb[2]; statusBar.style.color = luminance > 128 ? '#333' : '#fff'; }
            catch (e) { statusBar.style.color = '#fff'; }
          } else { statusBar.style.color = '#fff'; }
        } else { statusBar.style.backgroundColor = 'rgba(0,123,255,0.9)'; statusBar.style.color = '#fff'; }
        statusBar.style.display = 'block'; infoButtonContainer.style.top = `${statusBar.offsetHeight + 10}px`;
      }
      function hideStatusBar() { statusBar.style.display = 'none'; infoButtonContainer.style.top = '10px'; }

      function drawUnitForSave(targetContext, unit) {
        targetContext.save(); targetContext.translate(unit.x, unit.y);
        targetContext.fillStyle = '#fff'; drawRoundedRect(targetContext, 0, 0, unit.width, unit.height, 8); targetContext.fill();
        if (unit.borderVisible) { targetContext.strokeStyle = '#333'; targetContext.lineWidth = 2; drawRoundedRect(targetContext, 0, 0, unit.width, unit.height, 8); targetContext.stroke(); }
        const cSP = SLOT_PADDING_BASE, cIP = UNIT_INTERNAL_PADDING_BASE, fS = 11 * BASE_SCALE_FACTOR, tLH = SLOT_TEXT_LINE_HEIGHT_BASE * TEXT_LINE_HEIGHT_MULTIPLIER, bIH = SLOT_IMAGE_HEIGHT_BASE, qIMSH = SLOT_QR_IMAGE_SIZE_BASE;
        let hI = Object.values(unit.slots).some(s => s && s.img), hTI = Object.entries(unit.slots).some(([k, s]) => s && (s.name || (s.food && s.food !== '未選択') || ((k === 'qr1' || k === 'qr2') && s.order)));
        let tSY = cSP; if (hI) { tSY += Math.max(bIH, qIMSH) + (hTI ? IMAGE_TEXT_PADDING : 0); } else if (hTI) { tSY += cSP / 2; }
        const aSK = unit.activeSlotKeys || [], iC = aSK.length; let sW, sSX = cSP; const dSK = [];
        if (iC === 1) { sW = SLOT_WIDTH_BASE; sSX = (unit.width - sW) / 2; if (aSK.length > 0) dSK.push(aSK[0]); }
        else if (iC === 2) { sW = SLOT_WIDTH_BASE; const p = ['qr1', 'birth', 'qr2']; const srtK = [...aSK].sort((a, b) => p.indexOf(a) - p.indexOf(b)); if (srtK.length >= 2) { dSK.push(srtK[0]); dSK.push(srtK[1]); sSX = (unit.width - (sW * 2 + cIP)) / 2; } else if (srtK.length === 1) { dSK.push(srtK[0]); sSX = (unit.width - sW) / 2; } }
        else { sW = SLOT_WIDTH_BASE; const p = ['qr1', 'birth', 'qr2']; dSK.push(...p.filter(k => activeSlotKeys.includes(k))); p.forEach(k => { if (dSK.length < 3 && !dSK.includes(k) && unit.slots[k] && (unit.slots[k].img || unit.slots[k].name || (unit.slots[k].food && unit.slots[k].food !== '未選択') || unit.slots[k].order)) dSK.push(k); }); if (unit.width !== UNIT_WIDTH_THREE_SLOTS && dSK.length > 0 && dSK.length < 3) { const nTD = dSK.length; const tIPN = nTD > 1 ? cIP * (nTD - 1) : 0; const tPN = cSP * 2 + tIPN; sW = nTD > 0 ? (unit.width - tPN) / nTD : SLOT_WIDTH_BASE; sSX = cSP; } else if (dSK.length === 0 && hTI) { sW = unit.width - cSP * 2; sSX = cSP; const fTSlot = p.find(k => unit.slots[k] && (unit.slots[k].name || (unit.slots[k].food && unit.slots[k].food !== '未選択') || ((k === 'qr1' || k === 'qr2') && unit.slots[k].order))); if (fTSlot) dSK.push(fTSlot); } else { sSX = cSP; const nSTC = Math.max(dSK.length, 3); const tP3C = cSP * 2 + cIP * (nSTC - 1); sW = (UNIT_WIDTH_THREE_SLOTS - tP3C) / nSTC; if (dSK.length < 3 && unit.width !== UNIT_WIDTH_THREE_SLOTS) { const nTD = dSK.length; const tIPN = nTD > 1 ? cIP * (nTD - 1) : 0; const tPN = cSP * 2 + tIPN; sW = nTD > 0 ? (unit.width - tPN) / nTD : SLOT_WIDTH_BASE; } } }
        let cSX = sSX; const sOForD = ['qr1', 'birth', 'qr2']; let dCnt = 0;
        for (const sK of sOForD) {
          if (!dSK.includes(sK) && dCnt >= iC && iC > 0) continue; if (!unit.slots[sK]) continue;
          const sD = unit.slots[sK]; targetContext.save(); targetContext.translate(cSX, cSP);
          const iTD = sD?.img; const sAvH = (sK === 'birth') ? bIH : qIMSH; const sAvW = sW;
          if (iTD && iTD.complete && iTD.naturalWidth > 0) { try { const ar = iTD.naturalWidth / iTD.naturalHeight; let dW, dH; if (sK === 'birth') { dW = sAvW; dH = dW / ar; if (dH > sAvH) { dH = sAvH; dW = dH * ar; } } else { if (sAvW / ar <= sAvH) { dW = sAvW; dH = dW / ar; } else { dH = sAvH; dW = dH * ar; } } dW = Math.min(dW, sW); const iX = (sW - dW) / 2, iY = (sAvH - dH) / 2; targetContext.drawImage(iTD, iX, iY, dW, dH); } catch (e) { console.error("Error drawing image for save:", e); } }
          if (hTI && sD) { targetContext.font = `${fS}px ${DEFAULT_FONT}`; targetContext.textAlign = 'center'; let cTLY = tSY; const tAvH = unit.height - tSY - cSP; const tSSt = 'rgba(255,255,255,0.8)'; const tSWi = 3; const dTWOF = (t, y) => { if (y - tSY + tLH <= tAvH + 1) { targetContext.strokeStyle = tSSt; targetContext.lineWidth = tSWi; targetContext.strokeText(t, sW / 2, y - cSP, sW); targetContext.fillStyle = '#333'; targetContext.fillText(t, sW / 2, y - cSP, sW); return true; } return false; }; if (sD.name) { if (dTWOF(truncateText(sD.name, 12), cTLY)) cTLY += tLH; } if (sD.food && sD.food !== '未選択') { if (dTWOF(truncateText('好物:' + sD.food, 15), cTLY)) cTLY += tLH; } if (sD.order && (sK === 'qr1' || sK === 'qr2')) { dTWOF(sD.order, cTLY); } }
          targetContext.restore(); dCnt++; if (dCnt < dSK.length || (dSK.length < 3 && dCnt < 3)) cSX += sW + cIP;
        }
        targetContext.restore();
      }

      function updateZoom() { scale = Math.pow(1.2, zoomLevel); zoomLevelIndicator.textContent = zoomLevel; drawCanvas(); }
      function openModal(modalElement) { modalOverlay.style.display = 'block'; modalElement.style.display = 'block'; if (modalElement === cropperModal && (currentEditingUnitContext === 'unit-edit-modal' || currentEditingUnitContext === 'collection-edit-modal')) modalOverlay.style.zIndex = '1055'; else modalOverlay.style.zIndex = '1040'; }
      function closeModal(modalElement) { modalElement.style.display = 'none'; const anyOtherOpen = Array.from(document.querySelectorAll('.modal')).some(m => m !== modalElement && (m.style.display === 'block' || m.style.display === 'flex')); if (!anyOtherOpen) modalOverlay.style.display = 'none'; else if (unitEditModal.style.display === 'block' || unitEditModal.style.display === 'flex' || collectionEditModal.style.display === 'block' || collectionEditModal.style.display === 'flex') modalOverlay.style.zIndex = '1040'; }

      function openUnitEditModal(unit) {
        editingUnit = unit;
        editingLine = null;
        editingGroup = null;
        editingTextItem = null;
        editingCollectionUnit = null;
        unitEditModalTitle.textContent = `ユニット編集: ${truncateText(getItemDisplayName(unit), 20)}`;
        unitEditModalBody.innerHTML = '';

        function setupModalQrOrderLogic() {
          console.log("setupModalQrOrderLogic called");
          const qr1Saki = document.getElementById('unit-edit-qr1-order-先');
          const qr1Ato = document.getElementById('unit-edit-qr1-order-後');
          const qr2Saki = document.getElementById('unit-edit-qr2-order-先');
          const qr2Ato = document.getElementById('unit-edit-qr2-order-後');

          console.log("Checkboxes in setupModalQrOrderLogic:", qr1Saki, qr1Ato, qr2Saki, qr2Ato);

          if (!qr1Saki || !qr1Ato || !qr2Saki || !qr2Ato) {
            console.warn("Modal QR order checkboxes not found for logic setup.");
            return;
          }

          const updateChecks = (changedSlot, changedValue, isChecked) => {
            if (isChecked) {
              if (changedSlot === 'qr1' && changedValue === '先') {
                qr1Ato.checked = false;
                qr2Saki.checked = false;
                if (!qr2Ato.checked) qr2Ato.checked = true;
              } else if (changedSlot === 'qr1' && changedValue === '後') {
                qr1Saki.checked = false;
                qr2Ato.checked = false;
                if (!qr2Saki.checked) qr2Saki.checked = true;
              } else if (changedSlot === 'qr2' && changedValue === '先') {
                qr2Ato.checked = false;
                qr1Saki.checked = false;
                if (!qr1Ato.checked) qr1Ato.checked = true;
              } else if (changedSlot === 'qr2' && changedValue === '後') {
                qr2Saki.checked = false;
                qr1Ato.checked = false;
                if (!qr1Saki.checked) qr1Saki.checked = true;
              }
            } else {
              if (changedSlot === 'qr1' && changedValue === '先') {
                qr2Ato.checked = false;
              } else if (changedSlot === 'qr1' && changedValue === '後') {
                qr2Saki.checked = false;
              } else if (changedSlot === 'qr2' && changedValue === '先') {
                qr1Ato.checked = false;
              } else if (changedSlot === 'qr2' && changedValue === '後') {
                qr1Saki.checked = false;
              }
            }
          };

          qr1Saki.addEventListener('change', (e) => updateChecks('qr1', '先', e.target.checked));
          qr1Ato.addEventListener('change', (e) => updateChecks('qr1', '後', e.target.checked));
          qr2Saki.addEventListener('change', (e) => updateChecks('qr2', '先', e.target.checked));
          qr2Ato.addEventListener('change', (e) => updateChecks('qr2', '後', e.target.checked));
        }

        const checkboxesRowContainer = document.createElement('div');
        checkboxesRowContainer.className = 'checkbox-row-container';

        const borderItemContainer = document.createElement('div');
        borderItemContainer.className = 'checkbox-item-container';
        const borderCheckboxInput = document.createElement('input');
        borderCheckboxInput.type = 'checkbox';
        borderCheckboxInput.id = 'unit-edit-border-visible';
        borderCheckboxInput.checked = unit.borderVisible !== undefined ? unit.borderVisible : true;
        const borderLabel = document.createElement('label');
        borderLabel.htmlFor = 'unit-edit-border-visible';
        borderLabel.textContent = '枠表示';
        borderItemContainer.appendChild(borderCheckboxInput);
        borderItemContainer.appendChild(borderLabel);
        checkboxesRowContainer.appendChild(borderItemContainer);

        const monocolorItemContainer = document.createElement('div');
        monocolorItemContainer.className = 'checkbox-item-container';
        const monocolorCheckboxInput = document.createElement('input');
        monocolorCheckboxInput.type = 'checkbox';
        monocolorCheckboxInput.id = 'unit-edit-is-monocolor';
        monocolorCheckboxInput.checked = unit.isMonocolor === true;
        const monocolorLabel = document.createElement('label');
        monocolorLabel.htmlFor = 'unit-edit-is-monocolor';
        monocolorLabel.textContent = '単色(SP化リスクあり)';
        monocolorItemContainer.appendChild(monocolorCheckboxInput);
        monocolorItemContainer.appendChild(monocolorLabel);
        checkboxesRowContainer.appendChild(monocolorItemContainer);

        const targetItemContainer = document.createElement('div');
        targetItemContainer.className = 'checkbox-item-container';
        const targetIndividualCheckboxInput = document.createElement('input');
        targetIndividualCheckboxInput.type = 'checkbox';
        targetIndividualCheckboxInput.id = 'unit-edit-is-target-individual';
        targetIndividualCheckboxInput.checked = unit.isTargetIndividual === true;
        const targetIndividualLabel = document.createElement('label');
        targetIndividualLabel.htmlFor = 'unit-edit-is-target-individual';
        targetIndividualLabel.textContent = '最終目標個体';

        const imageCount = unit.activeSlotKeys ? unit.activeSlotKeys.length : 0;
        if (unit.type === 'unit' && imageCount === 1) {
          targetIndividualCheckboxInput.disabled = false;
          targetIndividualLabel.title = 'このユニットを推奨捕獲順の最終目標に設定します。';
        } else {
          targetIndividualCheckboxInput.disabled = true;
          targetIndividualCheckboxInput.checked = false;
          targetIndividualLabel.title = '推奨捕獲順の最終目標は、画像が1枚含まれるユニットのみ設定できます。';
        }
        targetItemContainer.appendChild(targetIndividualCheckboxInput);
        targetItemContainer.appendChild(targetIndividualLabel);
        checkboxesRowContainer.appendChild(targetItemContainer);

        unitEditModalBody.appendChild(checkboxesRowContainer);
        unitEditModalBody.appendChild(document.createElement('hr'));

        Object.keys(unit.slots).forEach(sK => {
          const sD = unit.slots[sK];
          const sDv = document.createElement('div');
          sDv.className = 'slot-edit-section';

          const titleH5 = document.createElement('h5');
          titleH5.textContent = `${sK === 'birth' ? '出生' : sK.toUpperCase()}スロット`;
          sDv.appendChild(titleH5);

          const previewImg = document.createElement('img');
          previewImg.id = `unit-edit-preview-${sK}`;
          previewImg.src = sD?.imgDataUrl || 'https://placehold.co/100x50/eee/ccc?text=No+Image';
          previewImg.style.cssText = 'max-width:100px;max-height:50px;display:block;margin-bottom:5px; background-color: #fff; border: 1px solid #ddd;';
          sDv.appendChild(previewImg);

          const currentSlotEditImageButton = document.createElement('button');
          currentSlotEditImageButton.textContent = '画像を編集';
          currentSlotEditImageButton.id = `unit-edit-edit-image-btn-${sK}`;
          currentSlotEditImageButton.style.marginBottom = '5px';
          currentSlotEditImageButton.onclick = () => {
            currentImageSlotKeyForEditing = sK;
            currentEditingUnitContext = 'unit-edit-modal';
            const urlToEdit = editingUnit.slots[sK]?.originalDataUrl || editingUnit.slots[sK]?.imgDataUrl;
            if (urlToEdit) {
              imageToCrop.src = urlToEdit;
              openModal(cropperModal);
              if (cropper) cropper.destroy();
              const aspectRatio = (sK === 'birth') ? NaN : 1;
              aspectRatioSelect.value = isNaN(aspectRatio) ? "NaN" : aspectRatio.toString();
              cropper = new Cropper(imageToCrop, {
                aspectRatio: aspectRatio, viewMode: 1, dragMode: 'move', background: false,
                responsive: true, restore: true, checkCrossOrigin: true, checkOrientation: true,
                modal: true, guides: true, center: true, highlight: true,
                cropBoxMovable: true, cropBoxResizable: true, toggleDragModeOnDblclick: false,
              });
              currentCropFinalizeCallback = (croppedDataUrl) => {
                const img = new Image();
                img.onload = () => {
                  if (!editingUnit.slots[currentImageSlotKeyForEditing]) {
                    editingUnit.slots[currentImageSlotKeyForEditing] = {};
                  }
                  const targetSlot = editingUnit.slots[currentImageSlotKeyForEditing];
                  targetSlot.img = img;
                  targetSlot.imgDataUrl = croppedDataUrl;
                  if (!targetSlot.originalDataUrl || targetSlot.originalDataUrl !== croppedDataUrl) {
                    targetSlot.originalDataUrl = croppedDataUrl;
                  }
                  const modalPreviewImage = document.getElementById(`unit-edit-preview-${currentImageSlotKeyForEditing}`);
                  if (modalPreviewImage) modalPreviewImage.src = croppedDataUrl;
                };
                img.onerror = () => { console.error("モーダル内での切り抜き後画像読み込みエラー:", currentImageSlotKeyForEditing); };
                img.src = croppedDataUrl;
                closeCropperModal();
              };
            } else {
              alert('このスロットに編集可能な元画像データがありません。先に「画像を変更」で画像をアップロードするか、既存の画像があることを確認してください。');
            }
          };
          sDv.appendChild(currentSlotEditImageButton);

          const currentSlotChangeNewImageButton = document.createElement('button');
          currentSlotChangeNewImageButton.textContent = '画像を変更';
          currentSlotChangeNewImageButton.id = `unit-edit-change-new-image-btn-${sK}`;
          currentSlotChangeNewImageButton.style.marginBottom = '10px';
          currentSlotChangeNewImageButton.onclick = () => {
            currentImageSlotKeyForEditing = sK;
            currentEditingUnitContext = 'unit-edit-modal';

            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'image/*';
            fileInput.onchange = (event) => {
              const file = event.target.files[0];
              if (file) {
                const reader = new FileReader();
                reader.onload = (e_reader) => {
                  const newImageDataUrl = e_reader.target.result;
                  const img = new Image();
                  img.onload = () => {
                    if (!editingUnit.slots[currentImageSlotKeyForEditing]) {
                      editingUnit.slots[currentImageSlotKeyForEditing] = { name: '', food: '未選択', order: null, img: null, imgDataUrl: null, originalDataUrl: null, fileName: null };
                    }
                    const targetSlot = editingUnit.slots[currentImageSlotKeyForEditing];
                    targetSlot.img = img;
                    targetSlot.imgDataUrl = newImageDataUrl;
                    targetSlot.originalDataUrl = newImageDataUrl;
                    targetSlot.fileName = file.name;

                    const modalPreviewImage = document.getElementById(`unit-edit-preview-${currentImageSlotKeyForEditing}`);
                    if (modalPreviewImage) modalPreviewImage.src = newImageDataUrl;
                  };
                  img.onerror = () => {
                    console.error("モーダル内での「画像を変更」時の新しい画像読み込みエラー:", currentImageSlotKeyForEditing);
                    alert("画像の読み込みに失敗しました。");
                  };
                  img.src = newImageDataUrl;
                };
                reader.readAsDataURL(file);
              }
            };
            fileInput.click();
          };
          sDv.appendChild(currentSlotChangeNewImageButton);

          // 名前入力
          const nameGroup = document.createElement('div'); nameGroup.className = 'form-group';
          const nameLabel = document.createElement('label'); nameLabel.htmlFor = `unit-edit-name-${sK}`; nameLabel.textContent = '名前:';
          const nameInput = document.createElement('input'); nameInput.type = 'text'; nameInput.id = `unit-edit-name-${sK}`; nameInput.value = sD?.name || ''; nameInput.maxLength = 10; nameInput.dataset.slotKey = sK; nameInput.className = 'unit-edit-slot-name';
          nameGroup.appendChild(nameLabel); nameGroup.appendChild(nameInput); sDv.appendChild(nameGroup);

          // 好物選択
          const foodGroup = document.createElement('div'); foodGroup.className = 'form-group';
          const foodLabel = document.createElement('label'); foodLabel.htmlFor = `unit-edit-food-${sK}`; foodLabel.textContent = '好物:';
          const foodSelect = document.createElement('select'); foodSelect.id = `unit-edit-food-${sK}`; foodSelect.dataset.slotKey = sK; foodSelect.className = 'unit-edit-slot-food';
          ['未選択', 'いちご', 'にがうり', 'とうがらし', 'バナナ', 'レモン', 'ぶどう', 'かき'].forEach(food => {
            const option = document.createElement('option'); option.value = food; option.textContent = food === '未選択' ? '選択(任意)' : food; foodSelect.appendChild(option);
          });
          foodSelect.value = sD?.food || '未選択';
          foodGroup.appendChild(foodLabel); foodGroup.appendChild(foodSelect); sDv.appendChild(foodGroup);

          // 入居順 (QR1, QR2スロットのみ)
          if (sK === 'qr1' || sK === 'qr2') {
            const orderGroup = document.createElement('div');
            orderGroup.className = 'order-checkbox-group';
            const orderMainLabel = document.createElement('label');
            orderMainLabel.textContent = '入居順(任意):';
            orderMainLabel.className = 'order-label';
            orderGroup.appendChild(orderMainLabel);

            const sakiCheckId = `unit-edit-${sK}-order-先`;
            const sakiOrderCheck = document.createElement('input');
            sakiOrderCheck.type = 'checkbox';
            sakiOrderCheck.name = `unit-edit-${sK}-order`;
            sakiOrderCheck.value = '先';
            sakiOrderCheck.id = sakiCheckId;
            sakiOrderCheck.checked = sD?.order === '先';
            sakiOrderCheck.dataset.slotKey = sK;
            sakiOrderCheck.className = 'unit-edit-slot-order';

            const atoCheckId = `unit-edit-${sK}-order-後`;
            const atoOrderCheck = document.createElement('input');
            atoOrderCheck.type = 'checkbox';
            atoOrderCheck.name = `unit-edit-${sK}-order`;
            atoOrderCheck.value = '後';
            atoOrderCheck.id = atoCheckId;
            atoOrderCheck.checked = sD?.order === '後';
            atoOrderCheck.dataset.slotKey = sK;
            atoOrderCheck.className = 'unit-edit-slot-order';

            sakiOrderCheck.addEventListener('change', (e) => {
              if (e.target.checked) {
                atoOrderCheck.checked = false;
                const otherSlotKey = sK === 'qr1' ? 'qr2' : 'qr1';
                const otherSlotSaki = document.getElementById(`unit-edit-${otherSlotKey}-order-先`);
                const otherSlotAto = document.getElementById(`unit-edit-${otherSlotKey}-order-後`);
                if (otherSlotSaki && otherSlotAto) {
                  otherSlotSaki.checked = false;
                  if (!otherSlotAto.checked) otherSlotAto.checked = true;
                }
              }
            });
            atoOrderCheck.addEventListener('change', (e) => {
              if (e.target.checked) {
                sakiOrderCheck.checked = false;
                const otherSlotKey = sK === 'qr1' ? 'qr2' : 'qr1';
                const otherSlotSaki = document.getElementById(`unit-edit-${otherSlotKey}-order-先`);
                const otherSlotAto = document.getElementById(`unit-edit-${otherSlotKey}-order-後`);
                if (otherSlotSaki && otherSlotAto) {
                  otherSlotAto.checked = false;
                  if (!otherSlotSaki.checked) otherSlotSaki.checked = true;
                }
              }
            });

            const sakiLabelElement = document.createElement('label');
            sakiLabelElement.htmlFor = sakiCheckId;
            sakiLabelElement.textContent = '先';
            sakiLabelElement.style.fontWeight = 'normal';

            const atoLabelElement = document.createElement('label');
            atoLabelElement.htmlFor = atoCheckId;
            atoLabelElement.textContent = '後';
            atoLabelElement.style.fontWeight = 'normal';

            orderGroup.appendChild(sakiOrderCheck);
            orderGroup.appendChild(sakiLabelElement);
            orderGroup.appendChild(atoOrderCheck);
            orderGroup.appendChild(atoLabelElement);
            sDv.appendChild(orderGroup);
          }
          unitEditModalBody.appendChild(sDv);
        });
        setupModalQrOrderLogic();

        const duplicateButton = document.getElementById('unit-edit-duplicate-button');
        const deleteButton = document.getElementById('unit-edit-delete-button');
        const applyButton = document.getElementById('unit-edit-apply-button');
        const cancelButton = document.getElementById('unit-edit-cancel-button');

        if (duplicateButton) {
          duplicateButton.style.display = 'inline-block';
        }
        if (deleteButton) {
          deleteButton.style.display = 'inline-block';
          deleteButton.textContent = 'ユニット削除';
        }
        if (applyButton) {
          applyButton.style.display = 'inline-block';
        }
        if (cancelButton) {
          cancelButton.style.display = 'inline-block';
        }

        openModal(unitEditModal);
      }

      function openGroupEditModal(group) {
        editingGroup = group; groupEditModalTitle.textContent = `グループ編集: ${truncateText(group.name || '無名グループ', 20)}`;
        groupEditNameInput.value = group.name || '';
        groupEditBorderVisibleCheckbox.checked = group.borderVisible !== undefined ? group.borderVisible : true;
        openModal(groupEditModal);
      }

      function openTextEditModal(textItem) {
        editingTextItem = textItem; textEditModalTitle.textContent = `テキスト編集: ${truncateText(textItem.text, 15)}`;
        textEditModalBody.innerHTML = `<div class="form-group"><label for="modal-text-content">内容:</label><textarea id="modal-text-content" rows="3">${textItem.text}</textarea></div><div class="form-group"><label for="modal-text-color">文字色:</label><input type="color" id="modal-text-color" value="${textItem.color}"></div><div class="form-group"><label for="modal-text-bgcolor">背景色:</label><input type="color" id="modal-text-bgcolor" value="${textItem.backgroundColor}"></div><div class="form-group"><label for="modal-text-size">サイズ:</label><input type="number" id="modal-text-size" value="${textItem.fontSize}" min="8"></div><div class="form-group-checkbox"><label for="modal-text-border-visible">枠を表示:</label><input type="checkbox" id="modal-text-border-visible"></div><div class="form-group"><label for="modal-text-rotation">回転角度:</label><input type="number" id="modal-text-rotation" value="${textItem.rotation || 0}" step="1" min="-360" max="360"></div>`;
        document.getElementById('modal-text-border-visible').checked = textItem.borderVisible !== undefined ? textItem.borderVisible : true;
        openModal(textEditModal);
      }
      function openLineStyleEditModal(line) {
        editingLine = line;
        editingUnit = null;
        editingGroup = null;
        editingTextItem = null;
        editingCollectionUnit = null;

        const modal = document.getElementById('unit-edit-modal');
        const modalTitle = document.getElementById('unit-edit-modal-title');
        const modalBody = document.getElementById('unit-edit-modal-body');
        const applyButton = document.getElementById('unit-edit-apply-button');
        const cancelButton = document.getElementById('unit-edit-cancel-button');
        const deleteButton = document.getElementById('unit-edit-delete-button');
        const duplicateButton = document.getElementById('unit-edit-duplicate-button');

        modalTitle.textContent = `接続線スタイル編集 (ID: ${truncateText(line.id, 15)})`;
        modalBody.innerHTML = '';

        // 色選択UI
        const colorGroup = document.createElement('div');
        colorGroup.className = 'form-group';
        const colorLabel = document.createElement('label');
        colorLabel.htmlFor = 'line-edit-color';
        colorLabel.textContent = '線の色:';
        const colorInput = document.createElement('input');
        colorInput.type = 'color';
        colorInput.id = 'line-edit-color';
        colorInput.value = line.color || '#555555'; // 現在の色をセット
        colorGroup.appendChild(colorLabel);
        colorGroup.appendChild(colorInput);
        modalBody.appendChild(colorGroup);

        // 太さ選択UI
        const lineWidthGroup = document.createElement('div');
        lineWidthGroup.className = 'form-group';
        const lineWidthLabel = document.createElement('label');
        lineWidthLabel.htmlFor = 'line-edit-lineWidth';
        lineWidthLabel.textContent = '線の太さ:';
        const lineWidthInput = document.createElement('input');
        lineWidthInput.type = 'number';
        lineWidthInput.id = 'line-edit-lineWidth';
        lineWidthInput.value = line.lineWidth || 10;
        lineWidthInput.min = '1';   // 最小値
        lineWidthInput.max = '50';  // 最大値 (適宜調整)
        lineWidthInput.step = '1';
        lineWidthGroup.appendChild(lineWidthLabel);
        lineWidthGroup.appendChild(lineWidthInput);
        modalBody.appendChild(lineWidthGroup);
        const lineDashGroup = document.createElement('div');
        lineDashGroup.className = 'form-group';
        const lineDashLabel = document.createElement('label');
        lineDashLabel.htmlFor = 'line-edit-dashType';
        lineDashLabel.textContent = '線の種類:';
        const lineDashSelect = document.createElement('select');
        lineDashSelect.id = 'line-edit-dashType';

        const lineTypes = [
          { name: '実線', value: '[]' },
          { name: '破線 (標準)', value: '[15, 10]' },
          { name: '破線 (短め)', value: '[8, 6]' },
          { name: '点線 (標準)', value: '[2, 5]' },
          { name: '点線 (細かめ)', value: '[1, 3]' }
        ];

        lineTypes.forEach(type => {
          const option = document.createElement('option');
          option.value = type.value;
          option.textContent = type.name;
          lineDashSelect.appendChild(option);
        });

        const currentDashArrayString = JSON.stringify(line.dashArray || []);
        lineDashSelect.value = currentDashArrayString;
        if (!lineTypes.some(type => type.value === currentDashArrayString)) {
          lineDashSelect.value = '[]';
        }

        lineDashGroup.appendChild(lineDashLabel);
        lineDashGroup.appendChild(lineDashSelect);
        modalBody.appendChild(lineDashGroup);

        if (duplicateButton) {
          duplicateButton.style.display = 'none';
        }
        if (deleteButton) {
          deleteButton.style.display = 'inline-block';
          deleteButton.textContent = '接続線削除';
        }
        if (applyButton) applyButton.style.display = 'inline-block';
        if (cancelButton) cancelButton.style.display = 'inline-block';


        openModal(modal);
      }

      function createGroupFromSelection() {
        if (itemsToGroup.length < 2) return; let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        const groupUnitIds = []; let canGroup = true; let firstItemGroupId = null; let allFromSameGroup = true;
        for (const item of itemsToGroup) {
          if (item.type !== 'unit' && item.type !== 'image-collection' && item.type !== 'text') { showStatusBar("グループ化はユニット系のみ", currentModeButtonElement); canGroup = false; break; }
          const containingGroup = groups.find(g => g.itemIds.includes(item.id));
          if (itemsToGroup.length > 1) { if (firstItemGroupId === null && containingGroup) firstItemGroupId = containingGroup.id; else if (containingGroup?.id !== firstItemGroupId) allFromSameGroup = false; else if (!containingGroup && firstItemGroupId !== null) allFromSameGroup = false; }
          groupUnitIds.push(item.id); minX = Math.min(minX, item.x); minY = Math.min(minY, item.y); maxX = Math.max(maxX, item.x + item.width); maxY = Math.max(maxY, item.y + item.height);
        }
        if (!canGroup) { itemsToGroup = []; drawCanvas(); return; }
        const selectedUnitsAreAllUngrouped = itemsToGroup.every(item => !groups.some(g => g.itemIds.includes(item.id)));
        const selectedUnitsAreAllFromTheSameExistingGroup = firstItemGroupId !== null && allFromSameGroup && itemsToGroup.every(item => groups.find(g => g.itemIds.includes(item.id))?.id === firstItemGroupId);
        if (!selectedUnitsAreAllUngrouped && !selectedUnitsAreAllFromTheSameExistingGroup) { showStatusBar("異なるグループや内外混在は不可", currentModeButtonElement); itemsToGroup = []; drawCanvas(); return; }
        if (selectedUnitsAreAllFromTheSameExistingGroup) { showStatusBar("既に同じグループ", currentModeButtonElement); itemsToGroup = []; drawCanvas(); return; }
        const groupX = minX - GROUP_PADDING; const groupY = minY - GROUP_PADDING;
        const groupWidth = (maxX - minX) + GROUP_PADDING * 2; const groupHeight = (maxY - minY) + GROUP_PADDING * 2;
        const newGroup = { id: `item-${nextItemId++}`, type: 'group', itemIds: groupUnitIds, x: groupX, y: groupY, width: groupWidth, height: groupHeight, name: '', isSelected: false, borderVisible: true };
        groups.push(newGroup); itemsToGroup = []; saveState(); drawCanvas(); showStatusBar("グループ作成完了", currentModeButtonElement);
      }

      function updateInfoModal() {
        const cropCounts = {
          'いちご': 0, 'にがうり': 0, 'とうがらし': 0,
          'バナナ': 0, 'レモン': 0, 'ぶどう': 0, 'かき': 0
        };
        let totalUnitImagesWithFoodSlot = 0; // 好物スロットを持つ可能性のあるユニット内の総画像数
        let birthImagesCount = 0;
        let baseUnitCountWithoutFavFood = 0;

        units.forEach(unit => {
          let isBaseUnitForThisUnit = false;
          let unitHasAnyFavoriteFoodActuallySet = false;

          if (unit.type === 'image-collection') {
            if (unit.images) {
              unit.images.forEach(imgInfo => {
                totalUnitImagesWithFoodSlot++;
                if (imgInfo.food && imgInfo.food !== '未選択' && cropCounts.hasOwnProperty(imgInfo.food)) {
                  cropCounts[imgInfo.food]++;
                  unitHasAnyFavoriteFoodActuallySet = true;
                }
              });
            }
          } else if (unit.type === 'unit') {
            const parents = getDirectParentsStrictRule(unit.id);
            if (parents.length === 0 && unit.activeSlotKeys && unit.activeSlotKeys.length > 0) {
              isBaseUnitForThisUnit = true;
            }

            Object.entries(unit.slots).forEach(([slotKey, slotData]) => {
              if (slotData) {
                if (slotData.img || slotData.imgDataUrl) {
                  totalUnitImagesWithFoodSlot++;
                  if (slotKey === 'birth') birthImagesCount++;
                }
                if (slotData.food && slotData.food !== '未選択' && cropCounts.hasOwnProperty(slotData.food)) {
                  cropCounts[slotData.food]++;
                  unitHasAnyFavoriteFoodActuallySet = true;
                }
              }
            });

            if (isBaseUnitForThisUnit && !unitHasAnyFavoriteFoodActuallySet) {
              baseUnitCountWithoutFavFood++;
              console.log(`[InfoModal] Base unit ${getItemDisplayName(unit)} has no favorite food set. Counting for default seed cost.`);
            }
          }
        });

        requiredCropsList.innerHTML = '';
        let hasAnyCropRequirement = false;
        Object.entries(cropCounts).forEach(([food, count]) => {
          if (count > 0) {
            hasAnyCropRequirement = true;
            const li = document.createElement('li');
            li.className = 'crop-list-item';
            const dot = document.createElement('span');
            dot.className = 'crop-color-dot';
            dot.style.backgroundColor = cropColors[food] || '#ccc';
            li.appendChild(dot);
            li.appendChild(document.createTextNode(`${food}: ${count}個`));
            requiredCropsList.appendChild(li);
          }
        });
        if (!hasAnyCropRequirement) {
          requiredCropsList.innerHTML = '<li><small>好物は設定されていません。</small></li>';
        }
        // --- ここまで「必要作物」リスト表示 ---


        // --- ゴールド計算 ---
        let totalSetFavoriteFoodItems = 0;
        for (const food in cropCounts) {
          totalSetFavoriteFoodItems += cropCounts[food];
        }

        // 1. 実際に好物が設定されている分の必要種数とコスト
        const seedsForSetFavorites = totalSetFavoriteFoodItems * 7; // 各7個必要
        const seedPricePerOne = 150; // 1個あたりの種の値段
        const costForSetFavoritesSeeds = seedsForSetFavorites * seedPricePerOne;

        // 2. 好物未設定の基本ユニット分のデフォルト種コスト (各ユニットにつき7個 * 150G)
        const costForDefaultBaseUnitSeeds = baseUnitCountWithoutFavFood * 7 * seedPricePerOne;

        // 総作物の種コスト
        const totalCropSeedCost = costForSetFavoritesSeeds + costForDefaultBaseUnitSeeds;
        const totalSeedsCalculated = seedsForSetFavorites + (baseUnitCountWithoutFavFood * 7);
        const limitBreakCost = totalUnitImagesWithFoodSlot * 300;
        const birthEventCost = birthImagesCount * 1000; // 出生スロットを持つ画像数に基づく

        const totalGold = limitBreakCost + birthEventCost + totalCropSeedCost;

        document.getElementById('total-gold-cost').textContent = `${totalGold.toLocaleString()} G`;

        updateRecommendedCaptureOrder();
      }

      function calculateImageCollectionUnitSize(images, layoutSettings = null) {
        console.log("[CalcSize] 開始", "画像数:", images?.length, "渡されたLayoutSettings:", layoutSettings);
        const imageCount = images?.length || 0;

        const defaultLayout = {
          maxSize: COLLECTION_IMAGE_MAX_SIZE, margin: COLLECTION_IMAGE_MARGIN, padding: COLLECTION_PADDING,
          textGap: minTextGapLogical, perRow: COLLECTION_IMAGES_PER_ROW, fontSize: textFontSizeLogical
        };
        // settings オブジェクトの各プロパティが数値であることを保証する
        const getSetting = (key, defaultValue) => {
          let val = (layoutSettings && layoutSettings[key] !== undefined) ? layoutSettings[key] :
            (editingCollectionUnit && editingCollectionUnit.layoutSettings && editingCollectionUnit.layoutSettings[key] !== undefined) ? editingCollectionUnit.layoutSettings[key] :
              defaultValue;
          const numVal = parseInt(val, 10); // 必ず数値に変換
          return isNaN(numVal) ? defaultValue : numVal; // NaNならデフォルト
        };

        const settings = {
          maxSize: getSetting('maxSize', COLLECTION_IMAGE_MAX_SIZE),
          margin: getSetting('margin', COLLECTION_IMAGE_MARGIN),
          padding: getSetting('padding', COLLECTION_PADDING),
          textGap: getSetting('textGap', minTextGapLogical),
          perRow: getSetting('perRow', COLLECTION_IMAGES_PER_ROW),
          fontSize: getSetting('fontSize', textFontSizeLogical)
        };
        console.log("[CalcSize] 使用するSettings:", JSON.parse(JSON.stringify(settings)));


        const logicalPadding = settings.padding;
        const logicalImageMaxSize = settings.maxSize;
        const baseLogicalImageMargin = settings.margin;
        let logicalImagesPerRow = settings.perRow;
        const textFontSizeLogicalValue = settings.fontSize;
        const minTextGapLogicalValue = settings.textGap;
        const textLineHeightLogical = SLOT_TEXT_LINE_HEIGHT_BASE * TEXT_LINE_HEIGHT_MULTIPLIER;
        const imageTextPaddingLogical = IMAGE_TEXT_PADDING;

        if (imageCount === 0) {
          console.log("[CalcSize] 画像0枚 -> デフォルト最小サイズ返却");
          return { width: logicalPadding * 2 + logicalImageMaxSize, height: logicalPadding * 2 + logicalImageMaxSize };
        }

        if (isNaN(logicalImagesPerRow) || logicalImagesPerRow <= 0) {
          console.warn(`[CalcSize] 不正な logicalImagesPerRow (${settings.perRow}) -> デフォルト ${COLLECTION_IMAGES_PER_ROW} 使用`);
          logicalImagesPerRow = COLLECTION_IMAGES_PER_ROW;
        }
        if (logicalImagesPerRow === 0) { // 0除算を避ける
          console.error("[CalcSize] logicalImagesPerRow が0です。デフォルト1を使用します。");
          logicalImagesPerRow = 1;
        }


        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        if (!tempCtx) {
          console.error("[CalcSize] 一時Canvasコンテキスト作成失敗。固定サイズ返却。");
          return { width: 200, height: 150 };
        }
        const fontForMeasure = `${textFontSizeLogicalValue}px ${DEFAULT_FONT}`;
        tempCtx.font = fontForMeasure;
        console.log("[CalcSize] テキスト幅測定用フォント:", fontForMeasure);

        const imageTextWidths = images.map((imgData, idx) => {
          let maxWidth = 0;
          if (imgData.name) {
            const nameWidth = tempCtx.measureText(imgData.name).width;
            maxWidth = Math.max(maxWidth, isNaN(nameWidth) ? 0 : nameWidth);
          }
          if (imgData.food && imgData.food !== '未選択') {
            const foodWidth = tempCtx.measureText('好物:' + imgData.food).width;
            maxWidth = Math.max(maxWidth, isNaN(foodWidth) ? 0 : foodWidth);
          }
          return maxWidth;
        });
        console.log("[CalcSize] 計算された全テキスト幅:", imageTextWidths);


        const hasTextInfo = imageTextWidths.some(width => width > 0);
        const textHeightPerImage = hasTextInfo ? (textLineHeightLogical * 2) + imageTextPaddingLogical : 0;
        const numRows = Math.ceil(imageCount / logicalImagesPerRow);
        console.log(`[CalcSize] 計算された行数 (numRows): ${numRows}`);


        let maxRowOccupiedWidthLogical = 0;
        for (let r = 0; r < numRows; r++) {
          let currentRowContentWidthLogical = 0;
          let currentRowMarginWidthLogical = 0;
          const startIndex = r * logicalImagesPerRow;
          const endIndex = Math.min(startIndex + logicalImagesPerRow, imageCount);
          const imagesInThisRow = endIndex - startIndex;

          for (let i = 0; i < imagesInThisRow; i++) {
            currentRowContentWidthLogical += logicalImageMaxSize;
            if (i > 0) {
              const prevImageIndex = startIndex + i - 1;
              const currentImageIndex = startIndex + i;
              const prevTextW = imageTextWidths[prevImageIndex] || 0;
              const currentTextW = imageTextWidths[currentImageIndex] || 0;
              const neededSpaceForText = (prevTextW / 2) + (currentTextW / 2) + minTextGapLogicalValue;
              const marginToUse = Math.max(baseLogicalImageMargin, (isNaN(neededSpaceForText) ? 0 : neededSpaceForText));
              currentRowMarginWidthLogical += marginToUse;
            }
          }
          currentRowContentWidthLogical += currentRowMarginWidthLogical;

          let requiredLeftPadding = logicalPadding;
          let requiredRightPadding = logicalPadding;
          if (imagesInThisRow > 0) {
            const firstImageIndex = startIndex;
            const lastImageIndex = endIndex - 1;
            const firstImageTextWidth = imageTextWidths[firstImageIndex] || 0;
            const lastImageTextWidth = imageTextWidths[lastImageIndex] || 0;
            requiredLeftPadding = Math.max(logicalPadding, firstImageTextWidth / 2);
            requiredRightPadding = Math.max(logicalPadding, lastImageTextWidth / 2);
          }
          const currentRowOccupiedWidth = requiredLeftPadding + currentRowContentWidthLogical + requiredRightPadding;
          maxRowOccupiedWidthLogical = Math.max(maxRowOccupiedWidthLogical, currentRowOccupiedWidth);
        }
        console.log("[CalcSize] 最大行占有幅(論理):", maxRowOccupiedWidthLogical);

        const unitWidth = maxRowOccupiedWidthLogical;
        const contentHeight = (numRows * logicalImageMaxSize) + (Math.max(0, numRows - 1) * baseLogicalImageMargin) + (numRows * textHeightPerImage);
        const unitHeight = contentHeight + (logicalPadding * 2);
        const minHeightBase = logicalPadding * 2 + logicalImageMaxSize;
        const minHeightWithText = hasTextInfo ? minHeightBase + textHeightPerImage : minHeightBase;
        const minWidthBase = logicalPadding * 2 + logicalImageMaxSize;

        let finalWidth = Math.max(unitWidth, minWidthBase);
        let finalHeight = Math.max(unitHeight, minHeightWithText);

        if (isNaN(finalWidth) || finalWidth <= 0) {
          console.error(`[CalcSize] finalWidth が不正 (${finalWidth})。デフォルト幅200を使用します。`);
          finalWidth = 200;
        }
        if (isNaN(finalHeight) || finalHeight <= 0) {
          console.error(`[CalcSize] finalHeight が不正 (${finalHeight})。デフォルト高150を使用します。`);
          finalHeight = 150;
        }
        console.log(`[CalcSize] 結果: width=${finalWidth}, height=${finalHeight}`);
        return {
          width: finalWidth,
          height: finalHeight
        };
      }

      function drawImagesInCollectionUnit(targetCtx, unit, currentScale = 1, layoutSettings = null) {
        const images = unit.images || [];
        if (images.length === 0) {
          return;
        }

        // --- 設定値取得 ---
        const settings = layoutSettings || unit.layoutSettings || {
          maxSize: COLLECTION_IMAGE_MAX_SIZE, margin: COLLECTION_IMAGE_MARGIN, padding: COLLECTION_PADDING,
          textGap: minTextGapLogical, perRow: COLLECTION_IMAGES_PER_ROW, fontSize: textFontSizeLogical
        };

        const logicalPadding = settings.padding;
        const logicalImageMaxSize = settings.maxSize;
        const baseLogicalImageMargin = settings.margin;
        let logicalImagesPerRow = settings.perRow;
        const textFontSizeLogicalValue = settings.fontSize;
        const minTextGapLogicalValue = settings.textGap;
        const textLineHeightLogical = SLOT_TEXT_LINE_HEIGHT_BASE * TEXT_LINE_HEIGHT_MULTIPLIER;
        const imageTextPaddingLogical = IMAGE_TEXT_PADDING;

        // logicalImagesPerRow バリデーション
        if (isNaN(logicalImagesPerRow) || logicalImagesPerRow <= 0) {
          logicalImagesPerRow = COLLECTION_IMAGES_PER_ROW;
        }

        // --- テキスト幅測定 (tempCtxを使用) ---
        let textMeasurementCtx = null;
        try {
          const tempCanvas = document.createElement('canvas');
          textMeasurementCtx = tempCanvas.getContext('2d');
        } catch (e) {
          console.error("drawImagesInCollectionUnit: 一時Canvasコンテキストの作成に失敗:", e);
        }

        const imageTextWidthsForDrawing = images.map((imgData, idx) => {
          if (!textMeasurementCtx) return 0;
          let mW = 0;
          try {
            textMeasurementCtx.font = `${textFontSizeLogicalValue}px ${DEFAULT_FONT}`;
            if (imgData.name) mW = Math.max(mW, textMeasurementCtx.measureText(truncateText(imgData.name, 8)).width);
            if (imgData.food && imgData.food !== '未選択') mW = Math.max(mW, textMeasurementCtx.measureText(truncateText('好物:' + imgData.food, 10)).width);
            if (isNaN(mW)) return 0;
          } catch (e) { return 0; } return mW;
        });

        const hasTextInfo = imageTextWidthsForDrawing.some(w => w > 0);
        const textHeightPerImage = hasTextInfo ? (textLineHeightLogical * 2) + imageTextPaddingLogical : 0;
        const numRows = Math.ceil(images.length / logicalImagesPerRow);
        if (isNaN(numRows) || numRows <= 0) { /* console.error("行数不正"); */ return; }

        let currentY_logical = logicalPadding;

        for (let r = 0; r < numRows; r++) {
          const startIndex = r * logicalImagesPerRow;
          const endIndex = Math.min(startIndex + logicalImagesPerRow, images.length);
          const imagesInThisRow = endIndex - startIndex;

          let currentRowContentWidthLogical = 0;
          let requiredMarginsWidthLogical = 0;
          let dynamicMargins = [];
          for (let i = 0; i < imagesInThisRow; i++) {
            currentRowContentWidthLogical += logicalImageMaxSize;
            if (i > 0) {
              const prevImageIndex = startIndex + i - 1;
              const currentImageIndex = startIndex + i;
              const prevW = imageTextWidthsForDrawing[prevImageIndex] === undefined ? 0 : imageTextWidthsForDrawing[prevImageIndex];
              const currW = imageTextWidthsForDrawing[currentImageIndex] === undefined ? 0 : imageTextWidthsForDrawing[currentImageIndex];
              const gap = isNaN(minTextGapLogicalValue) ? 4 : minTextGapLogicalValue;
              const baseM = isNaN(baseLogicalImageMargin) ? 5 : baseLogicalImageMargin;
              const needed = (prevW / 2) + (currW / 2) + gap;
              const margin = Math.max(baseM, (isNaN(needed) ? 0 : needed));
              requiredMarginsWidthLogical += margin;
              dynamicMargins.push(margin);
            }
          }
          currentRowContentWidthLogical += requiredMarginsWidthLogical;

          const logicalDrawableUnitWidth = unit.width - (logicalPadding * 2);
          let startX_L = logicalPadding + (logicalDrawableUnitWidth - currentRowContentWidthLogical) / 2;
          if (startX_L < logicalPadding) startX_L = logicalPadding;

          let currentX_L = startX_L;
          for (let i = 0; i < imagesInThisRow; i++) {
            const currentImageDrawIndex = startIndex + i;

            const imgData = images[currentImageDrawIndex];
            const imgObject = imgData.img;

            if (imgObject && imgObject.complete && imgObject.naturalWidth > 0) {
              try {
                let dWL, dHL; const ar = imgObject.naturalWidth / imgObject.naturalHeight;
                if (ar >= 1) { dWL = logicalImageMaxSize; dHL = dWL / ar; } else { dHL = logicalImageMaxSize; dWL = dHL * ar; }
                if (dHL > logicalImageMaxSize) { dHL = logicalImageMaxSize; dWL = dHL * ar; }
                if (dWL > logicalImageMaxSize) { dWL = logicalImageMaxSize; dHL = dWL / ar; }
                const offX = (logicalImageMaxSize - dWL) / 2, offY = (logicalImageMaxSize - dHL) / 2;
                targetCtx.drawImage(imgObject, currentX_L + offX, currentY_logical + offY, dWL, dHL);
              } catch (e) {
                const errBoxSizeL = logicalImageMaxSize; targetCtx.strokeStyle = 'red';
                targetCtx.lineWidth = 1 / currentScale; targetCtx.strokeRect(currentX_L, currentY_logical, errBoxSizeL, errBoxSizeL);
                console.error(`drawImagesInCollectionUnit 画像 ${currentImageDrawIndex}: drawImage中にエラー`, e);
              }
            } else {
              const pSizeL = logicalImageMaxSize; targetCtx.fillStyle = '#e0e0e0';
              targetCtx.fillRect(currentX_L, currentY_logical, pSizeL, pSizeL);
              targetCtx.fillStyle = '#a0a0a0'; targetCtx.font = `${textFontSizeLogicalValue / currentScale}px ${DEFAULT_FONT}`;
              targetCtx.textAlign = 'center'; targetCtx.textBaseline = 'middle';
              targetCtx.fillText('N/A', currentX_L + pSizeL / 2, currentY_logical + pSizeL / 2);
            }

            if (imgData.name || (imgData.food && imgData.food !== '未選択')) {
              targetCtx.fillStyle = '#333'; targetCtx.font = `${textFontSizeLogicalValue / currentScale}px ${DEFAULT_FONT}`;
              targetCtx.textAlign = 'center'; targetCtx.textBaseline = 'top';
              const tStartX_L = currentX_L + logicalImageMaxSize / 2; let tStartY_L = currentY_logical + logicalImageMaxSize + imageTextPaddingLogical;
              const uBY = unit.height - logicalPadding;
              if (imgData.name) { if ((tStartY_L + textLineHeightLogical) <= uBY) targetCtx.fillText(truncateText(imgData.name, 8), tStartX_L, tStartY_L); tStartY_L += textLineHeightLogical; }
              if (imgData.food && imgData.food !== '未選択') { if ((tStartY_L + textLineHeightLogical) <= uBY) targetCtx.fillText(truncateText('好物:' + imgData.food, 10), tStartX_L, tStartY_L); }
            }

            if (i < imagesInThisRow - 1) {
              const mTU = dynamicMargins[i];
              if (isNaN(mTU)) currentX_L += logicalImageMaxSize + baseLogicalImageMargin;
              else currentX_L += logicalImageMaxSize + mTU;
            } else {
              // console.log(`      行 ${r} の最後の画像 (${currentImageDrawIndex})`); // デバッグ用
            }
          }

          currentY_logical += logicalImageMaxSize + textHeightPerImage + baseLogicalImageMargin;
        }
      }

      function drawImageCollectionForSave(targetContext, unit) {
        targetContext.save();
        targetContext.translate(unit.x, unit.y);
        if (unit.borderVisible) {
          targetContext.strokeStyle = '#4caf50'; targetContext.lineWidth = 2;
          targetContext.fillStyle = 'rgba(240, 240, 240, 0.8)';
          drawRoundedRect(targetContext, 0, 0, unit.width, unit.height, 8);
          targetContext.fill(); targetContext.stroke();
        }
        drawImagesInCollectionUnit(targetContext, unit, 1, unit.layoutSettings);
        targetContext.restore();
      }
      function getItemDisplayName(item) {
        if (!item) return 'アイテム';
        if (item.type === 'unit') return item.slots.birth?.name || item.slots.qr1?.name || item.slots.qr2?.name || 'ユニット';
        if (item.type === 'group') return item.name || 'グループ';
        if (item.type === 'text') return truncateText(item.text, 10) || 'テキスト';
        if (item.type === 'image-collection') return item.name || `画像集合 (${item.images?.length || 0}枚)`;
        return 'アイテム';
      }

      function openImageCollectionEditModal(unit) {
        editingCollectionUnit = unit;
        collectionEditModalTitle.textContent = `画像集合編集: ${truncateText(getItemDisplayName(unit), 20)}`;
        collectionEditNameInput.value = unit.name || '';
        collectionEditBorderCheckbox.checked = unit.borderVisible !== undefined ? unit.borderVisible : true;
        collectionEditImageCount.textContent = unit.images?.length || 0;
        if (!unit.layoutSettings) {
          unit.layoutSettings = {
            maxSize: COLLECTION_IMAGE_MAX_SIZE, margin: COLLECTION_IMAGE_MARGIN, padding: COLLECTION_PADDING,
            textGap: minTextGapLogical, perRow: COLLECTION_IMAGES_PER_ROW, fontSize: textFontSizeLogical
          };
        }
        document.getElementById('collection-edit-max-size').value = unit.layoutSettings.maxSize;
        document.getElementById('collection-edit-margin').value = unit.layoutSettings.margin;
        document.getElementById('collection-edit-padding').value = unit.layoutSettings.padding;
        document.getElementById('collection-edit-text-gap').value = unit.layoutSettings.textGap;
        document.getElementById('collection-edit-per-row').value = unit.layoutSettings.perRow;
        document.getElementById('collection-edit-font-size').value = unit.layoutSettings.fontSize;
        const layoutDetails = document.getElementById('collection-layout-settings');
        if (layoutDetails) layoutDetails.open = false;
        collectionEditImageList.innerHTML = '';
        if (unit.images && unit.images.length > 0) {
          unit.images.forEach((imgData, index) => {
            const listItem = document.createElement('li');
            listItem.dataset.originalIndex = index; listItem.draggable = true;
            addDragDropListeners(listItem);
            const imgElement = document.createElement('img'); imgElement.id = `collection-edit-img-${index}`;
            imgElement.src = imgData.imgDataUrl || 'https://placehold.co/40x40/eee/ccc?text=N/A';
            imgElement.alt = imgData.fileName || '画像プレビュー'; listItem.appendChild(imgElement);
            const detailsDiv = document.createElement('div'); detailsDiv.className = 'image-details';
            const fileNameP = document.createElement('p'); fileNameP.textContent = `ファイル: ${truncateText(imgData.fileName || '不明', 25)}`; detailsDiv.appendChild(fileNameP);
            const nameGroup = document.createElement('div'); nameGroup.className = 'detail-form-group';
            const nameLabel = document.createElement('label'); nameLabel.textContent = '名前:';
            const nameInput = document.createElement('input'); nameInput.type = 'text'; nameInput.value = imgData.name || ''; nameInput.maxLength = 10; nameInput.placeholder = '名前(任意)'; nameInput.dataset.field = 'name';
            nameGroup.appendChild(nameLabel); nameGroup.appendChild(nameInput); detailsDiv.appendChild(nameGroup);
            const foodGroup = document.createElement('div'); foodGroup.className = 'detail-form-group';
            const foodLabel = document.createElement('label'); foodLabel.textContent = '好物:';
            const foodSelect = document.createElement('select'); foodSelect.dataset.field = 'food';
            ['未選択', 'いちご', 'にがうり', 'とうがらし', 'バナナ', 'レモン', 'ぶどう', 'かき'].forEach(food => { const opt = document.createElement('option'); opt.value = food; opt.textContent = food === '未選択' ? '選択(任意)' : food; foodSelect.appendChild(opt); });
            foodSelect.value = imgData.food || '未選択';
            foodGroup.appendChild(foodLabel); foodGroup.appendChild(foodSelect); detailsDiv.appendChild(foodGroup);
            listItem.appendChild(detailsDiv);
            const editImageBtn = document.createElement('button'); editImageBtn.textContent = '編集';
            editImageBtn.title = 'この画像を編集'; editImageBtn.style.cssText = 'font-size:0.75em;padding:2px 6px;margin-left:5px;';
            editImageBtn.onclick = () => {
              currentImageSlotKeyForEditing = null; currentEditingUnitContext = 'collection-edit-modal'; editingCollectionImageIndex = index;
              const urlToEdit = imgData.originalDataUrl || imgData.imgDataUrl;
              if (urlToEdit) {
                imageToCrop.src = urlToEdit; openModal(cropperModal); if (cropper) cropper.destroy();
                aspectRatioSelect.value = "NaN";
                cropper = new Cropper(imageToCrop, { aspectRatio: NaN, viewMode: 1, background: false, zoomable: true, movable: true, cropBoxResizable: true, dragMode: 'move' });
                currentCropFinalizeCallback = (croppedDataUrl) => {
                  const targetImageIndex = editingCollectionImageIndex;
                  if (editingCollectionUnit && editingCollectionUnit.images[targetImageIndex]) {
                    const targetImgData = editingCollectionUnit.images[targetImageIndex]; const img = new Image();
                    img.onload = () => {
                      targetImgData.img = img; targetImgData.imgDataUrl = croppedDataUrl;
                      if (!targetImgData.originalDataUrl) targetImgData.originalDataUrl = urlToEdit;
                      const previewInModal = document.getElementById(`collection-edit-img-${targetImageIndex}`);
                      if (previewInModal) previewInModal.src = croppedDataUrl;
                      closeCropperModal();
                    };
                    img.onerror = () => { console.error("編集後画像の読み込みエラー:", targetImageIndex); closeCropperModal(); };
                    img.src = croppedDataUrl;
                  } else { console.error("編集対象の画像データが見つかりません:", targetImageIndex); closeCropperModal(); }
                };
              } else { alert('編集可能な画像データが見つかりません。'); }
            }; listItem.appendChild(editImageBtn);
            const deleteBtn = document.createElement('button'); deleteBtn.innerHTML = '&times;'; deleteBtn.title = 'この画像を削除リストに追加'; deleteBtn.className = 'delete-image-btn';
            deleteBtn.onclick = () => {
              if (listItem.dataset.deleted === 'true') {
                if (confirm(`画像「${imgData.fileName || '選択画像'}」の削除を取り消しますか？`)) {
                  listItem.style.opacity = '1'; listItem.style.textDecoration = 'none'; listItem.dataset.deleted = 'false';
                  const currentCount = parseInt(collectionEditImageCount.textContent, 10) + 1;
                  collectionEditImageCount.textContent = currentCount;
                }
              } else {
                if (confirm(`画像「${imgData.fileName || '選択画像'}」を削除リストに追加しますか？ (適用ボタンで削除)`)) {
                  listItem.style.opacity = '0.5'; listItem.style.textDecoration = 'line-through'; listItem.dataset.deleted = 'true';
                  const currentCount = parseInt(collectionEditImageCount.textContent, 10) - 1;
                  collectionEditImageCount.textContent = Math.max(0, currentCount);
                }
              }
            }; listItem.appendChild(deleteBtn);
            collectionEditImageList.appendChild(listItem);
          });
        } else { collectionEditImageList.innerHTML = '<li>画像がありません。</li>'; }
        openModal(collectionEditModal);
      }

      function addDragDropListeners(item) { item.addEventListener('dragstart', handleDragStart); item.addEventListener('dragover', handleDragOver); item.addEventListener('dragenter', handleDragEnter); item.addEventListener('dragleave', handleDragLeave); item.addEventListener('drop', handleDrop); item.addEventListener('dragend', handleDragEnd); }
      function handleDragStart(e) { draggedItem = this; e.dataTransfer.effectAllowed = 'move'; setTimeout(() => this.classList.add('dragging'), 0); }
      function handleDragOver(e) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; return false; }
      function handleDragEnter(e) { if (draggedItem !== this) this.style.borderTop = '2px dashed blue'; }
      function handleDragLeave(e) { this.style.borderTop = ''; }
      function handleDrop(e) { e.stopPropagation(); if (draggedItem !== this) { const list = collectionEditImageList; const items = Array.from(list.children); const dragIdx = items.indexOf(draggedItem); const dropIdx = items.indexOf(this); if (dragIdx < dropIdx) list.insertBefore(draggedItem, this.nextSibling); else list.insertBefore(draggedItem, this); } this.style.borderTop = ''; return false; }
      function handleDragEnd(e) { collectionEditImageList.querySelectorAll('li').forEach(item => { item.classList.remove('dragging'); item.style.borderTop = ''; }); draggedItem = null; }

      function getResizeCursor(handle) {
        switch (handle) {
          case 'bottom-right': case 'top-left': return 'nwse-resize';
          case 'bottom-left': case 'top-right': return 'nesw-resize';
          case 'right': case 'left': return 'ew-resize';
          case 'bottom': case 'top': return 'ns-resize';
          default: return 'grab'; // デフォルトは掴むカーソル
        }
      }
      function updateFillOptionVisibility() {
        if (drawingFillGroup && drawingShapeSelect) {
          const shape = drawingShapeSelect.value;
          if (shape === 'rectangle' || shape === 'circle') {
            drawingFillGroup.style.display = 'flex';
          } else {
            drawingFillGroup.style.display = 'none';
          }
        }
      }
      function getDirectParents(childId, visitedConnections = new Set()) {
        console.log(`[getDirectParents] Called for childId: ${childId}`);
        const directParentUnits = new Set();

        // 1. childId (ユニット) に直接接続している接続を探す
        for (const conn of connections) {
          if (visitedConnections.has(conn.id)) continue;

          // パターンA: 親ユニット → 子ユニット (通常の接続)
          if (conn.toId === childId && !conn.fromId.startsWith('conn-')) {
            const parentUnit = findItemById(conn.fromId);
            if (parentUnit && (parentUnit.type === 'unit' || parentUnit.type === 'image-collection')) {
              directParentUnits.add(parentUnit);
              console.log(`  [GDP] Found direct parent (U→U): ${getItemDisplayName(parentUnit)} for child ${childId}`);
            }
          }
          // パターンB: 子ユニットが「線からユニットへの接続」の終点になっている
          // (つまり、ある線の中点からこの子ユニットへ線が引かれている)
          // conn = { id: 'conn-幹', fromId: 'conn-枝のID', toId: childId, isLineToUnit: true }
          else if (conn.toId === childId && conn.fromId.startsWith('conn-') && conn.isLineToUnit) {
            const branchLineId = conn.fromId; // T字の「枝」となる元の線のID
            const branchLine = connections.find(c => c.id === branchLineId);
            if (branchLine) {
              const parent1 = findItemById(branchLine.fromId);
              const parent2 = findItemById(branchLine.toId);
              if (parent1 && (parent1.type === 'unit' || parent1.type === 'image-collection')) {
                directParentUnits.add(parent1);
                console.log(`  [GDP] Found parent via T-branch (L→U, branch P1): ${getItemDisplayName(parent1)} for child ${childId}`);
              }
              if (parent2 && (parent2.type === 'unit' || parent2.type === 'image-collection')) {
                directParentUnits.add(parent2);
                console.log(`  [GDP] Found parent via T-branch (L→U, branch P2): ${getItemDisplayName(parent2)} for child ${childId}`);
              }
              visitedConnections.add(branchLine.id);
            } else {
              console.warn(`  [GDP] For L→U connection ${conn.id}, branch line ${branchLineId} not found.`);
            }
          }
          // パターンC: 子ユニットが「ユニットから線への接続」の始点になっている (これは親子関係ではない)
          // if (conn.fromId === childId && conn.toId.startsWith('conn-') && conn.isUnitToLine) {
          //   このユニットはT字の「枝」の一部であり、この接続自体は親を示さない
          // }

          visitedConnections.add(conn.id);
        }

        // 補足：ケース3のような、子が枝の先にあり、別のユニットが幹として接続している場合、
        // その「別のユニット」も親としてカウントするには、さらに複雑な探索が必要。
        // 例えば、子に直接つながる線L1があり、そのL1の中点に別のユニットP2から線L2がつながっている場合。
        // この場合、L1のfromIdであるP1はパターンAで検出される。
        // P2を検出するには、L1 (conn.id) をtoIdとして持つ isUnitToLine の接続を探す。
        for (const conn_L1 of connections.filter(c => c.toId === childId && !c.fromId.startsWith('conn-'))) {
          for (const conn_L2 of connections.filter(c => c.toId === conn_L1.id && c.isUnitToLine && !c.fromId.startsWith('conn-'))) {
            const otherParent = findItemById(conn_L2.fromId);
            if (otherParent && (otherParent.type === 'unit' || otherParent.type === 'image-collection')) {
              directParentUnits.add(otherParent);
              console.log(`  [GDP] Found other T-branch parent (U→L to L1): ${getItemDisplayName(otherParent)} for child ${childId}`);
            }
          }
        }


        const parentObjects = Array.from(directParentUnits);
        console.log(`[getDirectParents] Returning for ${childId}:`, parentObjects.map(p => getItemDisplayName(p)));
        return parentObjects;
      }



      function buildCaptureListRecursive(currentUnit, rolePath, isSakiBranchPrimary, captureList, visitedUnits = new Set(), targetIndividualId = null) {
        if (!currentUnit) {
          console.warn(`[BCR] currentUnit is null for rolePath: ${rolePath}`);
          return;
        }
        if (visitedUnits.has(currentUnit.id)) {
          return;
        }
        if (targetIndividualId && currentUnit.id === targetIndividualId) {
          console.log(`  [BCR] Encountered target individual itself: ${getItemDisplayName(currentUnit)}. Will trace its parents if any.`);
          visitedUnits.add(currentUnit.id);
        } else {
          visitedUnits.add(currentUnit.id);
          console.log(`[buildCaptureListRecursive] Processing: ${getItemDisplayName(currentUnit)}, RolePath: "${rolePath}", isSakiBranchPrimary: ${isSakiBranchPrimary}`);
        }

        const parents = getDirectParentsStrictRule(currentUnit.id);
        console.log(`  Parents of ${getItemDisplayName(currentUnit)}:`, parents.map(p => getItemDisplayName(p)));

        if (parents.length === 0) {
          if (targetIndividualId && currentUnit.id === targetIndividualId) {
            console.log(`  [BCR] Target individual ${getItemDisplayName(currentUnit)} is a base unit. Not adding to capture list.`);
          } else {
            console.log(`  [BCR] ${getItemDisplayName(currentUnit)} is a base unit (to be captured via QR).`);
            const qrSlotKey = currentUnit.activeSlotKeys && currentUnit.activeSlotKeys.length > 0 ? currentUnit.activeSlotKeys[0] : null;
            let qrImageUrl = null;
            if (qrSlotKey && currentUnit.slots[qrSlotKey] && currentUnit.slots[qrSlotKey].imgDataUrl) {
              qrImageUrl = currentUnit.slots[qrSlotKey].imgDataUrl;
            } else {
              const firstPopulatedSlot = Object.values(currentUnit.slots).find(s => s && s.imgDataUrl);
              if (firstPopulatedSlot) {
                qrImageUrl = firstPopulatedSlot.imgDataUrl;
                console.log(`    [BCR] Used fallback QR image from a populated slot for ${getItemDisplayName(currentUnit)}`);
              } else {
                console.warn(`    [BCR] No QR image found for base unit ${getItemDisplayName(currentUnit)}`);
              }
            }

            if (qrImageUrl) {
              console.log(`  [BCR] Adding ${getItemDisplayName(currentUnit)} to capture list.`);
              captureList.push({
                unit: currentUnit,
                rolePath: rolePath,
                isMonocolor: currentUnit.isMonocolor === true,
                isSakiBranchPrimary: isSakiBranchPrimary,
                qrImage: qrImageUrl,
                unitName: getItemDisplayName(currentUnit)
              });
            } else {
              console.warn(`  [BCR] Base unit ${getItemDisplayName(currentUnit)} has no QR image to display.`);
            }
          }
          if (!(targetIndividualId && currentUnit.id === targetIndividualId)) {
            visitedUnits.delete(currentUnit.id);
          }
          return;
        }

        let sakiDescendant, atoDescendant;
        if (parents.length === 1) {
          sakiDescendant = parents[0];
          console.warn(`  [BCR] Unit ${getItemDisplayName(currentUnit)} has only one parent according to rule. Processing as saki.`);
        } else if (parents.length >= 2) {
          const sortedParents = [...parents].sort((a, b) => a.x - b.x); // X座標でソート
          sakiDescendant = sortedParents[0];
          atoDescendant = sortedParents[1];
        }

        if (sakiDescendant) {
          buildCaptureListRecursive(sakiDescendant, rolePath + ` -> [先素材]`, isSakiBranchPrimary, captureList, new Set(visitedUnits), targetIndividualId);
        }
        if (atoDescendant) {
          buildCaptureListRecursive(atoDescendant, rolePath + ` -> [後素材]`, false, captureList, new Set(visitedUnits), targetIndividualId);
        }
        if (!(targetIndividualId && currentUnit.id === targetIndividualId)) {
          visitedUnits.delete(currentUnit.id);
        }
      }


      function updateRecommendedCaptureOrder() {
        const displayContent = document.getElementById('recommended-capture-order-content');
        if (!displayContent) { console.error("recommended-capture-order-content not found."); return; }
        displayContent.innerHTML = '';

        const targetIndividual = units.find(u => u.isTargetIndividual === true);
        if (!targetIndividual || !(targetIndividual.type === 'unit' && targetIndividual.activeSlotKeys?.length === 1)) {
          displayContent.innerHTML = '<p>推奨捕獲順を表示するには、画像1枚のユニットを「最終目標個体」に設定してください。</p>';
          return;
        }

        displayContent.innerHTML = `<h4>目標: ${getItemDisplayName(targetIndividual)}</h4>`;

        const { sakiParent, atoParent, birthPartner, error } = determineTargetParentRoles(targetIndividual);

        if (error) {
          displayContent.innerHTML += `<p style="color:red;">エラー: ${error}</p><p><small>家系図の接続やルールを確認してください。</small></p>`;
          return;
        }
        if (!sakiParent || !atoParent) {
          let missingMsg = "";
          if (!sakiParent && !atoParent) missingMsg = "「先」と「後」の両方の親";
          else if (!sakiParent) missingMsg = "「先」の親";
          else missingMsg = "「後」の親";
          displayContent.innerHTML += `<p style="color:orange;">警告: 目標個体の${missingMsg}を特定できませんでした。接続を確認してください。</p>`;
          return;
        }

        displayContent.innerHTML += `<p><b>先の親(系統):</b> ${getItemDisplayName(sakiParent)}, <b>後の親(系統):</b> ${getItemDisplayName(atoParent)}</p>`;
        if (birthPartner) {
          displayContent.innerHTML += `<p><i>出生の相方(参考): ${getItemDisplayName(birthPartner)} (この個体の系統は下記捕獲順には直接反映されません)</i></p>`;
        }

        let sakiBranchCaptureList = [];
        let atoBranchCaptureList = [];

        // buildCaptureListRecursive の呼び出し (targetIndividual.id を渡す)
        if (sakiParent) {
          buildCaptureListRecursive(sakiParent, `[${getItemDisplayName(sakiParent)}系統]`, true, sakiBranchCaptureList, new Set(), targetIndividual.id);
        }
        if (atoParent) {
          buildCaptureListRecursive(atoParent, `[${getItemDisplayName(atoParent)}系統]`, false, atoBranchCaptureList, new Set(), targetIndividual.id);
        }

        // フェーズ分け
        const phase1_saki_mono = sakiBranchCaptureList.filter(item => item.isMonocolor);
        const phase2_saki_gara = sakiBranchCaptureList.filter(item => !item.isMonocolor);
        const phase3_ato_mono = atoBranchCaptureList.filter(item => item.isMonocolor);
        const phase4_ato_gara = atoBranchCaptureList.filter(item => !item.isMonocolor);

        // リスト表示用ヘルパー関数
        const renderCaptureList = (phaseTitle, listItems, phaseNumber) => {
          let html = `<div class="capture-phase capture-phase-${phaseNumber}"><h5>フェーズ${phaseNumber}: ${phaseTitle}</h5>`;
          if (listItems.length === 0) {
            html += "<p><small>該当なし</small></p>";
          } else {
            html += "<ul>";
            listItems.forEach(item => {
              const roleSegments = item.rolePath.split('->');
              const specificRole = roleSegments.length > 1 ? roleSegments[roleSegments.length - 1].trim() : item.rolePath;

              html += `<li>
                    <img src="${item.qrImage}" alt="${item.unitName}" style="width:40px; height:40px; border:1px solid #ddd; background-color:white; object-fit:contain;">
                    <div style="margin-left: 10px; flex-grow:1;">
                        <strong>${item.unitName}</strong>
                        ${item.isMonocolor ? '<span style="color:#e74c3c; font-weight:bold;"> (単色 - SP化注意!)</span>' : '<span style="color:#2ecc71;"> (柄)</span>'}
                        <small style="color:#7f8c8d; display:block; margin-top:2px;">役割: ${specificRole} (元系統: ${roleSegments[0].trim()})</small>
                    </div>
                 </li>`;
            });
            html += "</ul>";
          }
          html += "</div>";
          return html;
        };

        let displayHtml = "";
        displayHtml += renderCaptureList(`「先の親」系統の単色ユニット (最優先)`, phase1_saki_mono, 1);
        displayHtml += renderCaptureList(`「先の親」系統の柄ユニット`, phase2_saki_gara, 2);
        displayHtml += renderCaptureList(`「後の親」系統の単色ユニット`, phase3_ato_mono, 3);
        displayHtml += renderCaptureList(`「後の親」系統の柄ユニット`, phase4_ato_gara, 4);

        if (sakiBranchCaptureList.length === 0 && atoBranchCaptureList.length === 0 && (sakiParent || atoParent)) {
          displayHtml = "<p>親系統は特定できましたが、その先の捕獲対象ユニット(QR)が見つかりませんでした。家系図が末端まで完成し、各ユニットにQR画像が設定されているか確認してください。</p>";
        } else if (displayHtml.trim() === "") {
          displayHtml = "<p>推奨捕獲順を生成できませんでした。設定や家系図の構成を確認してください。</p>";
        }

        displayContent.innerHTML += displayHtml;
        displayContent.innerHTML += "<hr><p><small><b>注意:</b> 上記はSP化リスクを考慮した一般的な育成順です。特定の固定ルートやゲーム内状況により、最適な順番は異なる場合があります。</small></p>";
      }
      function getIntersectionPointWithUnitBoundary(unit, pointP) {
        const unitCenterX = unit.x + unit.width / 2;
        const unitCenterY = unit.y + unit.height / 2;

        // ユニットの中心から点Pへのベクトル
        const dx = pointP.x - unitCenterX;
        const dy = pointP.y - unitCenterY;

        if (dx === 0 && dy === 0) {
          return { x: unitCenterX, y: unitCenterY };
        }

        let t = Infinity;
        let intersectionX = null, intersectionY = null;

        // 上辺との交差チェック (y = unit.y)
        if (dy !== 0) {
          const tEdge = (unit.y - unitCenterY) / dy;
          if (tEdge > 0) {
            const xEdge = unitCenterX + tEdge * dx;
            if (xEdge >= unit.x && xEdge <= unit.x + unit.width) {
              if (tEdge < t) {
                t = tEdge;
                intersectionX = xEdge;
                intersectionY = unit.y;
              }
            }
          }
        }

        // 下辺との交差チェック (y = unit.y + unit.height)
        if (dy !== 0) {
          const tEdge = (unit.y + unit.height - unitCenterY) / dy;
          if (tEdge > 0) {
            const xEdge = unitCenterX + tEdge * dx;
            if (xEdge >= unit.x && xEdge <= unit.x + unit.width) {
              if (tEdge < t) {
                t = tEdge;
                intersectionX = xEdge;
                intersectionY = unit.y + unit.height;
              }
            }
          }
        }

        // 左辺との交差チェック (x = unit.x)
        if (dx !== 0) {
          const tEdge = (unit.x - unitCenterX) / dx;
          if (tEdge > 0) {
            const yEdge = unitCenterY + tEdge * dy;
            if (yEdge >= unit.y && yEdge <= unit.y + unit.height) {
              if (tEdge < t) {
                t = tEdge;
                intersectionX = unit.x;
                intersectionY = yEdge;
              }
            }
          }
        }

        // 右辺との交差チェック (x = unit.x + unit.width)
        if (dx !== 0) {
          const tEdge = (unit.x + unit.width - unitCenterX) / dx;
          if (tEdge > 0) {
            const yEdge = unitCenterY + tEdge * dy;
            if (yEdge >= unit.y && yEdge <= unit.y + unit.height) {
              if (tEdge < t) {
                t = tEdge;
                intersectionX = unit.x + unit.width;
                intersectionY = yEdge;
              }
            }
          }
        }

        if (intersectionX !== null && intersectionY !== null) {
          return { x: intersectionX, y: intersectionY };
        } else {
          console.warn("getIntersectionPointWithUnitBoundary: No intersection found, returning center.", unit, pointP);
          return { x: unitCenterX, y: unitCenterY };
        }
      }
      function getDirectParentsStrictRule(childUnitId) {
        console.log(`[getDirectParentsStrictRule] Called for child: ${childUnitId}`);
        const childUnit = findItemById(childUnitId);
        if (!childUnit) {
          console.warn(`[GDPSR] Child unit ${childUnitId} not found.`);
          return [];
        }

        let parentDefiningConnection = null;
        let connectionToParentStructureId = null;

        // 子ユニットに接続している「幹」の線を見つける
        // isLineToUnit: 親ペア線の中点(from) -> 子ユニット(to)
        // isUnitToLine: 子ユニット(from) -> 親ペア線の中点(to)  (接続方向による)
        for (const conn of connections) {
          if (conn.toId === childUnitId && conn.isLineToUnit && conn.fromId.startsWith('conn-')) {
            parentDefiningConnection = conn;
            connectionToParentStructureId = conn.fromId;
            break;
          }
          // 逆方向の接続も考慮する場合 (ユーザーが子から親ペア線の中点へ引いた場合)
          if (conn.fromId === childUnitId && conn.isUnitToLine && conn.toId.startsWith('conn-')) {
            parentDefiningConnection = conn;
            connectionToParentStructureId = conn.toId;
            break;
          }
        }

        if (!parentDefiningConnection) {
          console.warn(`[GDPSR] No 'trunk' connection found for child ${childUnitId} according to the strict rule (must be L→U or U→L to a line).`);
          const directUnitConnections = connections.filter(c =>
            (c.toId === childUnitId && !c.fromId.startsWith('conn-')) ||
            (c.fromId === childUnitId && !c.toId.startsWith('conn-'))
          );
          if (directUnitConnections.length === 1) {
            console.warn(`[GDPSR] Child ${childUnitId} is connected directly to a single unit via ${directUnitConnections[0].id}. This might be a rule violation or a special case (e.g., topmost unit, or a partner unit). Returning no parents.`);
          } else if (directUnitConnections.length > 1) {
            console.warn(`[GDPSR] Child ${childUnitId} is connected directly to multiple units. Rule violation.`);
          }
          return [];
        }

        console.log(`[GDPSR] Trunk connection for ${childUnitId} is ${parentDefiningConnection.id}. It connects to parent structure (line) ID: ${connectionToParentStructureId}`);

        // 親ペア線を見つける
        const parentPairLine = connections.find(conn => conn.id === connectionToParentStructureId);

        if (!parentPairLine) {
          console.warn(`[GDPSR] Parent pair line with ID ${connectionToParentStructureId} not found for child ${childUnitId}.`);
          return [];
        }

        // 親ペア線の両端のユニットが親
        const parent1 = findItemById(parentPairLine.fromId);
        const parent2 = findItemById(parentPairLine.toId);

        const parentObjects = [];
        if (parent1 && (parent1.type === 'unit' || parent1.type === 'image-collection')) {
          parentObjects.push(parent1);
        } else {
          console.warn(`[GDPSR] Parent1 (ID: ${parentPairLine.fromId}) of parent pair line ${parentPairLine.id} is not a valid unit.`);
        }
        if (parent2 && (parent2.type === 'unit' || parent2.type === 'image-collection')) {
          parentObjects.push(parent2);
        } else {
          console.warn(`[GDPSR] Parent2 (ID: ${parentPairLine.toId}) of parent pair line ${parentPairLine.id} is not a valid unit.`);
        }

        if (parentObjects.length !== 2 && parentObjects.length !== 0) {
          console.warn(`[GDPSR] Expected 2 parents from parent pair line ${parentPairLine.id}, but found ${parentObjects.length}. (P1: ${parent1 ? getItemDisplayName(parent1) : 'N/A'}, P2: ${parent2 ? getItemDisplayName(parent2) : 'N/A'})`);
        }
        if (parentObjects.length === 0 && (parent1 || parent2)) {
          console.warn(`[GDPSR] Parent pair line ${parentPairLine.id} connects to non-unit items. P1 type: ${parent1?.type}, P2 type: ${parent2?.type}`);
        }


        console.log(`[getDirectParentsStrictRule] Returning for ${childUnitId}:`, parentObjects.map(p => getItemDisplayName(p)));
        return parentObjects;
      }
      function determineTargetParentRoles(targetUnit) {
        let sakiParent = null;
        let atoParent = null;
        let birthPartner = null;
        let error = null;

        console.log(`[DTPR V5 - Simplified] Target: ${getItemDisplayName(targetUnit)}`);

        // 目標個体は画像1枚のユニットのみという前提
        const targetImageCount = targetUnit.activeSlotKeys ? targetUnit.activeSlotKeys.length : 0;
        if (!(targetUnit.type === 'unit' && targetImageCount === 1)) {
          error = "目標個体は画像1枚のユニットである必要があります。";
          console.warn(`[DTPR V5] Error: ${error}`);
          return { sakiParent, atoParent, birthPartner, error };
        }

        // 親の特定には getDirectParentsStrictRule を使用
        const parentsList = getDirectParentsStrictRule(targetUnit.id);
        console.log(`  [DTPR V5] Parents from StrictRule:`, parentsList.map(p => getItemDisplayName(p)));

        if (parentsList.length === 0) {
          error = `推奨捕獲順のルールに従った親ユニットが見つかりませんでした。子ユニットは親ペアを繋ぐ線の中点に接続されていますか？`;
        } else if (parentsList.length === 1) {
          sakiParent = parentsList[0];
          error = `親ユニットが1体のみ見つかりました。ルールでは通常2体の親が必要です。`;
          console.warn(`  [DTPR V5] Only one parent found for 1-image target.`);
        } else if (parentsList.length === 2) {
          const sortedParents = [...parentsList].sort((a, b) => a.x - b.x);
          sakiParent = sortedParents[0];
          atoParent = sortedParents[1];
        } else if (parentsList.length === 3) {
          const sortedByY = [...parentsList].sort((a, b) => a.y - b.y);
          const mainParentsPair = [sortedByY[0], sortedByY[1]].sort((a, b) => a.x - b.x);
          sakiParent = mainParentsPair[0];
          atoParent = mainParentsPair[1];
          birthPartner = sortedByY[2];
          console.log(`    [DTPR V5] Found 2 parents and 1 birth partner.`);
        } else { // parentsList.length > 3
          error = `親ユニットが多すぎます (${parentsList.length}体)。ルール違反の可能性があります。`;
        }

        // 最終チェック: sakiParent と atoParent が揃っているか (birthPartner はオプション)
        if (!error && (!sakiParent || !atoParent)) {
          // sakiParentのみ存在し、birthPartnerもいない場合は、atoParentが見つからないエラー
          if (sakiParent && !atoParent && !birthPartner) {
            error = "「後」の親が見つかりませんでした。";
          } else if (!sakiParent && !atoParent) { // 両方見つからないのは上の parentsList.length === 0 で処理済みのはず
            error = "「先」と「後」の両方の親が見つかりませんでした。";
          }
          // sakiParent と birthPartner がいて atoParent がいない、というケースは通常考えにくい
        }


        if (error) {
          console.warn(`[DTPR V5] Error/Warning after processing: ${error}`);
        }
        console.log(`[DTPR V5] Returning: Saki=${sakiParent ? getItemDisplayName(sakiParent) : 'N/A'}, Ato=${atoParent ? getItemDisplayName(atoParent) : 'N/A'}, Partner=${birthPartner ? getItemDisplayName(birthPartner) : 'N/A'}, Error=${error}`);
        return { sakiParent, atoParent, birthPartner, error };
      }

      // ヘルパー関数: 指定されたユニットに直接接続しているユニットのリストを取得
      // (T字の幹や枝の中間点は考慮せず、ユニット間の物理的な直接接続のみを見る)
      function getDirectlyConnectedUnits(unitId) {
        const connectedUnitIds = new Set();
        connections.forEach(conn => {
          // fromId が unitId で、toId がユニットIDの場合
          if (conn.fromId === unitId && !conn.toId.startsWith('conn-')) {
            const targetUnit = findItemById(conn.toId);
            if (targetUnit && (targetUnit.type === 'unit' || targetUnit.type === 'image-collection')) {
              connectedUnitIds.add(conn.toId);
            }
          }
          // toId が unitId で、fromId がユニットIDの場合
          else if (conn.toId === unitId && !conn.fromId.startsWith('conn-')) {
            const sourceUnit = findItemById(conn.fromId);
            if (sourceUnit && (sourceUnit.type === 'unit' || sourceUnit.type === 'image-collection')) {
              connectedUnitIds.add(conn.fromId);
            }
          }
        });
        return Array.from(connectedUnitIds).map(id => findItemById(id)).filter(Boolean); // filter(Boolean)でnullを除去
      }

      // ヘルパー関数: 指定されたユニットに直接接続しているユニットのリストを取得
      function getDirectlyConnectedUnits(unitId) {
        const connectedUnitIds = new Set();
        connections.forEach(conn => {
          if (conn.fromId === unitId && !conn.toId.startsWith('conn-')) {
            connectedUnitIds.add(conn.toId);
          } else if (conn.toId === unitId && !conn.fromId.startsWith('conn-')) {
            connectedUnitIds.add(conn.fromId);
          }
          // T字の幹がこのユニットに接続している場合、その幹の元の線(枝)の端点ユニットは含めない
          // (この関数は「直接物理的に線で繋がっているユニット」のみを対象とするため)
        });
        return Array.from(connectedUnitIds).map(id => findItemById(id)).filter(u => u && (u.type === 'unit' || u.type === 'image-collection'));
      }
      function drawAllElementsOnContext(targetContext, targetCanvasElement, items, currentDrawingSettings, isTransparentBackground = false) {
        const drawScale = currentDrawingSettings.scale;
        const currentSelectedItem = (targetCanvasElement === canvas) ? items.selectedItem : null;
        const currentConnectFromItem = (targetCanvasElement === canvas) ? items.connectFromItem : null;
        const currentItemsToGroup = (targetCanvasElement === canvas) ? items.itemsToGroup : [];

        targetContext.save();
        targetContext.clearRect(0, 0, targetCanvasElement.width, targetCanvasElement.height);

        if (!isTransparentBackground) {
          let bgColorToFill = '#fdfdfd';
          if (targetCanvasElement === canvas) {
            bgColorToFill = window.getComputedStyle(canvas).backgroundColor || '#fdfdfd';
          }
          targetContext.fillStyle = bgColorToFill;
          targetContext.fillRect(0, 0, targetCanvasElement.width, targetCanvasElement.height);
        }
        targetContext.translate(currentDrawingSettings.originX, currentDrawingSettings.originY);
        targetContext.scale(drawScale, drawScale);

        // 1. 接続線の描画
        items.connections.forEach(conn => {
          const fromItem = findItemById(conn.fromId);
          const toItem = findItemById(conn.toId);

          if (!fromItem || !toItem) {
            console.warn(`接続線描画エラー: fromItemまたはtoItemが見つかりません。 connId: ${conn.id}`);
            return;
          }

          if (conn.isUnitToLine || conn.isLineToUnit) {
            let p1 = getIntersectionPointWithUnitBoundary(fromItem, { x: toItem.x + toItem.width / 2, y: toItem.y + toItem.height / 2 });
            let p2 = getIntersectionPointWithUnitBoundary(toItem, { x: fromItem.x + fromItem.width / 2, y: fromItem.y + fromItem.height / 2 });
            if (conn.isUnitToLine) {
              const lineMid = getLineMidpoint(conn.toId);
              if (!lineMid) return;
              p1 = getIntersectionPointWithUnitBoundary(fromItem, lineMid);
              p2 = lineMid;
            } else if (conn.isLineToUnit) {
              const lineMid = getLineMidpoint(conn.fromId);
              if (!lineMid) return;
              p1 = lineMid;
              p2 = getIntersectionPointWithUnitBoundary(toItem, lineMid);
            }
            if (p1 && p2) {
              targetContext.beginPath();
              targetContext.moveTo(p1.x, p1.y);
              targetContext.lineTo(p2.x, p2.y);
              const isSelectedConn = currentSelectedItem && currentSelectedItem.id === conn.id && targetCanvasElement === canvas;
              const baseLineWidth = conn.lineWidth || 10;
              targetContext.strokeStyle = isSelectedConn ? '#007bff' : (conn.color || '#555555');
              targetContext.lineWidth = isSelectedConn ? (baseLineWidth + 2) / drawScale : baseLineWidth / drawScale;
              targetContext.setLineDash((conn.dashArray || []).map(d => d / drawScale));
              targetContext.stroke();
              targetContext.setLineDash([]);
            }
            return;
          }

          // 通常のユニット間接続
          const fromCenterX = fromItem.x + fromItem.width / 2;
          const fromCenterY = fromItem.y + fromItem.height / 2;
          const toCenterX = toItem.x + toItem.width / 2;
          const toCenterY = toItem.y + toItem.height / 2;

          targetContext.beginPath();
          const isSelectedConn = currentSelectedItem && currentSelectedItem.id === conn.id && targetCanvasElement === canvas;
          const baseLineWidth = conn.lineWidth || 10; // デフォルトの太さ
          const displayLineWidth = baseLineWidth / drawScale;
          targetContext.strokeStyle = isSelectedConn ? '#007bff' : (conn.color || '#555555');
          targetContext.lineWidth = isSelectedConn ? (displayLineWidth + (2 / drawScale)) : displayLineWidth;
          targetContext.setLineDash((conn.dashArray || []).map(d => d / drawScale));

          const otherParentConnections = items.connections.filter(
            c => c.toId === toItem.id && c.fromId !== fromItem.id && !c.isUnitToLine && !c.isLineToUnit
          );

          if (otherParentConnections.length === 1) {
            const otherParent = findItemById(otherParentConnections[0].fromId);
            if (otherParent) {
              const otherParentCenterX = otherParent.x + otherParent.width / 2;
              const otherParentCenterY = otherParent.y + otherParent.height / 2;

              // 親ペア線の中点を計算
              const parentMidX = (fromCenterX + otherParentCenterX) / 2;
              const parentMidY = (fromCenterY + otherParentCenterY) / 2;
              const p1_start = getIntersectionPointWithUnitBoundary(fromItem, { x: parentMidX, y: fromCenterY });
              targetContext.moveTo(p1_start.x, p1_start.y);
              targetContext.lineTo(parentMidX, fromCenterY);
              const p_child_target = getIntersectionPointWithUnitBoundary(toItem, { x: parentMidX, y: parentMidY });
              targetContext.lineTo(parentMidX, parentMidY);
              targetContext.lineTo(p_child_target.x, p_child_target.y);

            } else {
              const p1 = getIntersectionPointWithUnitBoundary(fromItem, { x: toCenterX, y: toCenterY });
              const p2 = getIntersectionPointWithUnitBoundary(toItem, { x: fromCenterX, y: fromCenterY });
              targetContext.moveTo(p1.x, p1.y);
              targetContext.lineTo(p2.x, p2.y);
            }
          } else {
            const p1 = getIntersectionPointWithUnitBoundary(fromItem, { x: toCenterX, y: toCenterY });
            const p2 = getIntersectionPointWithUnitBoundary(toItem, { x: fromCenterX, y: fromCenterY });

            targetContext.moveTo(p1.x, p1.y);
            if (Math.abs(p1.y - p2.y) > displayLineWidth * 2 && Math.abs(p1.x - p2.x) > displayLineWidth * 2) {
              targetContext.lineTo(p1.x, p2.y);
            }
            targetContext.lineTo(p2.x, p2.y);
          }

          targetContext.stroke();
          targetContext.setLineDash([]);
        });

        // 2. 手書き描画 (保存済みパス)
        (items.drawnPaths || []).forEach(pathObj => {
          if (!pathObj || !pathObj.points || pathObj.points.length < 1) return;
          targetContext.strokeStyle = pathObj.color;
          targetContext.lineWidth = pathObj.lineWidth / drawScale;
          targetContext.lineCap = 'round';
          targetContext.lineJoin = 'round';
          if (pathObj.type === 'eraser') {
            const mainCanvasBgColor = (targetCanvasElement === canvas) ?
              (window.getComputedStyle(canvas).backgroundColor || '#fdfdfd') :
              (window.getComputedStyle(document.getElementById('family-tree-canvas')).backgroundColor || '#fdfdfd');
            targetContext.strokeStyle = mainCanvasBgColor;
          }
          targetContext.beginPath();
          if (pathObj.type === 'line' || pathObj.type === 'eraser') {
            targetContext.moveTo(pathObj.points[0][0], pathObj.points[0][1]);
            for (let i = 1; i < pathObj.points.length; i++) {
              targetContext.lineTo(pathObj.points[i][0], pathObj.points[i][1]);
            }
            targetContext.stroke();
          } else if (pathObj.type === 'arrow' && pathObj.points.length >= 2) {
            const points = pathObj.points;
            const endX = points[points.length - 1][0]; const endY = points[points.length - 1][1];
            const prevX = points.length > 1 ? points[points.length - 2][0] : points[0][0];
            const prevY = points.length > 1 ? points[points.length - 2][1] : points[0][1];
            targetContext.moveTo(points[0][0], points[0][1]);
            for (let i = 1; i < points.length; i++) { targetContext.lineTo(points[i][0], points[i][1]); }
            targetContext.stroke();
            drawArrowhead(targetContext, prevX, prevY, endX, endY, pathObj.lineWidth / drawScale);
          } else if (pathObj.type === 'rectangle' && pathObj.points.length >= 2 && pathObj.startX !== undefined) {
            const startX = pathObj.startX; const startY = pathObj.startY;
            const endX = pathObj.points[1][0]; const endY = pathObj.points[1][1];
            const rectX = Math.min(startX, endX); const rectY = Math.min(startY, endY);
            const rectW = Math.abs(startX - endX); const rectH = Math.abs(startY - endY);
            if (pathObj.isFilled) { targetContext.fillStyle = pathObj.color; targetContext.fillRect(rectX, rectY, rectW, rectH); }
            targetContext.strokeRect(rectX, rectY, rectW, rectH);
          } else if (pathObj.type === 'circle' && pathObj.points.length >= 2 && pathObj.startX !== undefined) {
            const startX = pathObj.startX; const startY = pathObj.startY;
            const endX = pathObj.points[1][0]; const endY = pathObj.points[1][1];
            const radiusX = Math.abs(startX - endX) / 2; const radiusY = Math.abs(startY - endY) / 2;
            const centerX = Math.min(startX, endX) + radiusX; const centerY = Math.min(startY, endY) + radiusY;
            targetContext.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
            if (pathObj.isFilled) { targetContext.fillStyle = pathObj.color; targetContext.fill(); }
            targetContext.stroke();
          }
        });

        // 3. 手書き描画 (現在描画中パス - メインキャンバスのみ)
        if (targetCanvasElement === canvas && items.isDrawing && items.drawnPathsInProgress && items.drawnPathsInProgress.length > 0) {
          const pathObj = items.drawnPathsInProgress[0];
          if (pathObj && pathObj.points && pathObj.points.length >= 1) {
            targetContext.strokeStyle = pathObj.color;
            targetContext.lineWidth = pathObj.lineWidth / drawScale;
            targetContext.lineCap = 'round'; targetContext.lineJoin = 'round';
            if (pathObj.type === 'eraser') {
              targetContext.strokeStyle = window.getComputedStyle(canvas).backgroundColor || '#fdfdfd';
            }
            targetContext.beginPath();
            if (pathObj.type === 'line' || pathObj.type === 'eraser') {
              if (pathObj.points.length > 0) {
                targetContext.moveTo(pathObj.points[0][0], pathObj.points[0][1]);
                for (let i = 1; i < pathObj.points.length; i++) {
                  targetContext.lineTo(pathObj.points[i][0], pathObj.points[i][1]);
                }
                targetContext.stroke();
              }
            } else if (pathObj.type === 'arrow' && pathObj.points.length >= 2) {
              const points = pathObj.points;
              const endX = points[points.length - 1][0]; const endY = points[points.length - 1][1];
              const prevX = points.length > 1 ? points[points.length - 2][0] : points[0][0];
              const prevY = points.length > 1 ? points[points.length - 2][1] : points[0][1];
              targetContext.moveTo(points[0][0], points[0][1]);
              for (let i = 1; i < points.length; i++) { targetContext.lineTo(points[i][0], points[i][1]); }
              targetContext.stroke();
              drawArrowhead(targetContext, prevX, prevY, endX, endY, pathObj.lineWidth / drawScale);
            } else if (pathObj.type === 'rectangle' && pathObj.points.length >= 2 && pathObj.startX !== undefined) {
              const startX = pathObj.startX; const startY = pathObj.startY;
              const endX = pathObj.points[1][0]; const endY = pathObj.points[1][1];
              const rectX = Math.min(startX, endX); const rectY = Math.min(startY, endY);
              const rectW = Math.abs(startX - endX); const rectH = Math.abs(startY - endY);
              if (pathObj.isFilled) { targetContext.fillStyle = pathObj.color; targetContext.fillRect(rectX, rectY, rectW, rectH); }
              targetContext.strokeRect(rectX, rectY, rectW, rectH);
            } else if (pathObj.type === 'circle' && pathObj.points.length >= 2 && pathObj.startX !== undefined) {
              const startX = pathObj.startX; const startY = pathObj.startY;
              const endX = pathObj.points[1][0]; const endY = pathObj.points[1][1];
              const radiusX = Math.abs(startX - endX) / 2; const radiusY = Math.abs(startY - endY) / 2;
              const centerX = Math.min(startX, endX) + radiusX; const centerY = Math.min(startY, endY) + radiusY;
              targetContext.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
              if (pathObj.isFilled) { targetContext.fillStyle = pathObj.color; targetContext.fill(); }
              targetContext.stroke();
            }
          }
        }

        // 4. グループの描画
        items.groups.forEach(group => {
          targetContext.save();
          targetContext.translate(group.x, group.y);
          const isSelectedForDisplay = currentSelectedItem && currentSelectedItem.id === group.id && targetCanvasElement === canvas;

          if (group.borderVisible) {
            targetContext.strokeStyle = isSelectedForDisplay ? '#007bff' : '#6f42c1';
            targetContext.lineWidth = (isSelectedForDisplay ? 6 : 4) / drawScale;
            targetContext.fillStyle = 'rgba(111, 66, 193, 0.05)';
            drawRoundedRect(targetContext, 0, 0, group.width, group.height, 15);
            targetContext.fill();
            targetContext.stroke();
          } else if (isSelectedForDisplay) {
            targetContext.strokeStyle = '#007bff';
            targetContext.lineWidth = 6 / drawScale;
            drawRoundedRect(targetContext, 0, 0, group.width, group.height, 15);
            targetContext.stroke();
          }
          if (group.name) {
            targetContext.fillStyle = '#6f42c1';
            targetContext.font = `${14 / drawScale}px ${DEFAULT_FONT}`;
            targetContext.textAlign = 'center';
            targetContext.strokeStyle = 'rgba(255,255,255,0.7)';
            targetContext.lineWidth = 3 / drawScale;
            targetContext.strokeText(truncateText(group.name, 20), group.width / 2, -(5 / drawScale));
            targetContext.fillText(truncateText(group.name, 20), group.width / 2, -(5 / drawScale));
          }
          targetContext.restore();
        });

        // 5. ユニットの描画
        items.units.forEach(unit => {
          targetContext.save();
          targetContext.translate(unit.x, unit.y);

          const isNormallySelected = currentSelectedItem && currentSelectedItem.id === unit.id && targetCanvasElement === canvas;
          const isUnitConnectFrom = currentConnectFromItem && currentConnectFromItem.id === unit.id && targetCanvasElement === canvas;
          const isUnitInGroupSelection = currentItemsToGroup.find(item => item.id === unit.id) && targetCanvasElement === canvas;
          const isUnitUnifyTarget = unit.isTargetSelectedForUnify === true && targetCanvasElement === canvas;
          const isAlignmentBaseForDisplay = alignBaseUnit && alignBaseUnit.id === unit.id && targetCanvasElement === canvas && currentMode && currentMode.startsWith('align');
          const isAlignmentTargetForDisplay = alignTargetUnits.some(target => target.id === unit.id) && targetCanvasElement === canvas && currentMode === 'align-select-targets';

          let currentUnitLineWidth = 2 / drawScale;
          let defaultStrokeColor = (targetCanvasElement === canvas) ?
            (unit.type === 'image-collection' ? '#4caf50' : '#333') :
            '#000000';
          let currentUnitStrokeStyle = defaultStrokeColor;
          let currentUnitFillStyle = unit.type === 'image-collection' ? 'rgba(240, 240, 240, 0.8)' : '#fff';

          if (targetCanvasElement === canvas) {
            if (isUnitUnifyTarget) { currentUnitLineWidth = 5 / drawScale; currentUnitStrokeStyle = '#20c997'; }
            else if (isAlignmentBaseForDisplay) { currentUnitLineWidth = 5 / drawScale; currentUnitStrokeStyle = '#ff69b4'; }
            else if (isAlignmentTargetForDisplay) { currentUnitLineWidth = 4 / drawScale; currentUnitStrokeStyle = '#ffa500'; }
            else if (isNormallySelected) { currentUnitLineWidth = 4 / drawScale; currentUnitStrokeStyle = '#007bff'; }
            else if (isUnitConnectFrom) { currentUnitLineWidth = 4 / drawScale; currentUnitStrokeStyle = '#ffc107'; }
            else if (isUnitInGroupSelection) { currentUnitLineWidth = 4 / drawScale; currentUnitStrokeStyle = '#28a745'; }
          }

          if (unit.borderVisible) {
            targetContext.lineWidth = currentUnitLineWidth;
            targetContext.strokeStyle = currentUnitStrokeStyle;
            targetContext.fillStyle = currentUnitFillStyle;
            drawRoundedRect(targetContext, 0, 0, unit.width, unit.height, 8);
            targetContext.fill();
            targetContext.stroke();
          } else if (targetCanvasElement === canvas && (isUnitUnifyTarget || isAlignmentBaseForDisplay || isAlignmentTargetForDisplay || isNormallySelected || isUnitConnectFrom || isUnitInGroupSelection)) {
            targetContext.lineWidth = currentUnitLineWidth;
            targetContext.strokeStyle = currentUnitStrokeStyle;
            drawRoundedRect(targetContext, 0, 0, unit.width, unit.height, 8);
            targetContext.stroke();
          }


          if (unit.type === 'image-collection') {
            drawImagesInCollectionUnit(targetContext, unit, drawScale, unit.layoutSettings);
            if (unit.images?.length === 0) {
              targetContext.fillStyle = '#000000'; // 保存時も黒
              targetContext.font = `${14 / drawScale}px ${DEFAULT_FONT}`;
              targetContext.textAlign = 'center'; targetContext.textBaseline = 'middle';
              targetContext.fillText(`画像なし`, unit.width / 2, unit.height / 2);
            }
          } else {
            const cSP = SLOT_PADDING_BASE; const cIP = UNIT_INTERNAL_PADDING_BASE;
            const fS_logical = 11 * BASE_SCALE_FACTOR;
            const fS_display = fS_logical / drawScale; // 描画時のフォントサイズ
            const tLH_logical = SLOT_TEXT_LINE_HEIGHT_BASE * TEXT_LINE_HEIGHT_MULTIPLIER;
            const tLH_display = tLH_logical / drawScale; // 描画時の行の高さ
            const bIH = SLOT_IMAGE_HEIGHT_BASE; const qIMSH = SLOT_QR_IMAGE_SIZE_BASE;
            let hasImg = Object.values(unit.slots).some(s => s && (s.img || s.imgDataUrl));
            let hasTxtInfo = Object.entries(unit.slots).some(([k, s]) => s && (s.name || (s.food && s.food !== '未選択') || ((k === 'qr1' || k === 'qr2') && s.order)));
            let txtStartY_logical = cSP;
            if (hasImg) txtStartY_logical += Math.max(bIH, qIMSH) + (hasTxtInfo ? IMAGE_TEXT_PADDING : 0);
            else if (hasTxtInfo) txtStartY_logical += cSP / 2;

            const activeSKs = unit.activeSlotKeys || [];
            const imgCnt = activeSKs.length;
            let slW, slStartX = cSP, dispSKs = [];

            if (imgCnt === 1) { slW = SLOT_WIDTH_BASE; slStartX = (unit.width - slW) / 2; if (activeSKs.length > 0) dispSKs.push(activeSKs[0]); }
            else if (imgCnt === 2) {
              slW = SLOT_WIDTH_BASE; const p_order = ['qr1', 'birth', 'qr2']; const srtK = [...activeSKs].sort((a, b) => p_order.indexOf(a) - p_order.indexOf(b));
              if (srtK.length >= 2) { dispSKs.push(srtK[0]); dispSKs.push(srtK[1]); slStartX = (unit.width - (slW * 2 + cIP)) / 2; }
              else if (srtK.length === 1) { dispSKs.push(srtK[0]); slStartX = (unit.width - slW) / 2; }
            } else {
              slW = SLOT_WIDTH_BASE;
              const p_order = ['qr1', 'birth', 'qr2'];
              p_order.forEach(k => {
                if (unit.slots[k] && (unit.slots[k].img || unit.slots[k].imgDataUrl)) {
                  if (!dispSKs.includes(k)) dispSKs.push(k);
                }
              });
              if (dispSKs.length === 0 && hasTxtInfo) {
                p_order.forEach(k => {
                  if (unit.slots[k] && (unit.slots[k].name || (unit.slots[k].food && unit.slots[k].food !== '未選択') || ((k === 'qr1' || k === 'qr2') && unit.slots[k].order))) {
                    if (!dispSKs.includes(k)) dispSKs.push(k);
                  }
                });
              }
              const numSlotsToDraw = dispSKs.length > 0 ? dispSKs.length : (unit.width === UNIT_WIDTH_THREE_SLOTS ? 3 : 1);
              const totalInternalPaddingForDisplay = numSlotsToDraw > 1 ? cIP * (numSlotsToDraw - 1) : 0;
              const totalPaddingForDisplay = cSP * 2 + totalInternalPaddingForDisplay;
              slW = numSlotsToDraw > 0 ? (unit.width - totalPaddingForDisplay) / numSlotsToDraw : SLOT_WIDTH_BASE;
              slStartX = cSP;
              if (numSlotsToDraw === 1 && unit.width > UNIT_WIDTH_ONE_SLOT) {
                slStartX = (unit.width - slW) / 2;
              }
            }


            let curSlX = slStartX; const slOrder = ['qr1', 'birth', 'qr2']; let slDrawn = 0;

            for (const slK of slOrder) {
              const shouldDisplayThisSlot = dispSKs.includes(slK);
              if (!shouldDisplayThisSlot && imgCnt > 0) continue;
              if (!shouldDisplayThisSlot && imgCnt === 0 && !hasTxtInfo) continue;

              const slData = unit.slots[slK];
              if (!slData && !dispSKs.includes(slK)) continue;
              if (slData && !slData.img && !slData.imgDataUrl && !slData.name && !(slData.food && slData.food !== '未選択') && !slData.order && !dispSKs.includes(slK)) continue;


              targetContext.save();
              targetContext.translate(curSlX, cSP);
              const sAH = (slK === 'birth') ? bIH : qIMSH;
              const sAW = slW;

              const imgToDraw = slData?.img;
              if (imgToDraw && imgToDraw.complete && imgToDraw.naturalWidth > 0) {
                try {
                  const ar = imgToDraw.naturalWidth / imgToDraw.naturalHeight; let dW, dH;
                  if (slK === 'birth') {
                    dH = sAH; dW = dH * ar; if (dW > sAW) { dW = sAW; dH = dW / ar; }
                  } else { if (sAW / ar <= sAH) { dW = sAW; dH = dW / ar; } else { dH = sAH; dW = dH * ar; } }
                  dW = Math.min(dW, sAW); dH = Math.min(dH, sAH);
                  const iX = (sAW - dW) / 2; const iY = (sAH - dH) / 2;
                  targetContext.drawImage(imgToDraw, iX, iY, dW, dH);
                } catch (e) { console.error("Error drawing unit slot image:", e); }
              }

              if (slData && (slData.name || (slData.food && slData.food !== '未選択') || slData.order)) {
                targetContext.font = `${fS_display}px ${DEFAULT_FONT}`;
                targetContext.textAlign = 'center';
                let currentTextLineY_InSlot_display = txtStartY_logical;

                const textShadowStyle = 'rgba(255,255,255,0.8)';
                const textShadowWidth = 3 / drawScale;

                const drawTextLineInSlot_ForRender = (text, yOffsetLogical, isFoodItem = false, foodColor = '#ccc') => {
                  const actualYInSlotLocal_display = yOffsetLogical - cSP;
                  targetContext.strokeStyle = textShadowStyle;
                  targetContext.lineWidth = textShadowWidth;
                  if (isFoodItem) {
                    const textMetrics = targetContext.measureText(text);
                    const textActualWidth_display = textMetrics.width;
                    const circleRadius_display = (fS_logical / 2.8) / drawScale; // 円の半径 (表示ピクセル)
                    const circleX_display = (sAW / 2) - (textActualWidth_display / 2) - circleRadius_display - (2 / drawScale);
                    const textRenderX_display = sAW / 2;
                    targetContext.beginPath();
                    targetContext.arc(circleX_display, actualYInSlotLocal_display - (fS_display / 2) + (circleRadius_display / 2), circleRadius_display, 0, 2 * Math.PI);
                    targetContext.fillStyle = foodColor;
                    targetContext.fill();
                    targetContext.strokeText(text, textRenderX_display, actualYInSlotLocal_display, sAW - circleRadius_display * 2 - (4 / drawScale));
                    targetContext.fillStyle = '#000000'; // 文字色は黒
                    targetContext.fillText(text, textRenderX_display, actualYInSlotLocal_display, sAW - circleRadius_display * 2 - (4 / drawScale));
                  } else {
                    targetContext.strokeText(text, sAW / 2, actualYInSlotLocal_display, sAW);
                    targetContext.fillStyle = '#000000'; // 文字色は黒
                    targetContext.fillText(text, sAW / 2, actualYInSlotLocal_display, sAW);
                  }
                };
                if (slData.name) { drawTextLineInSlot_ForRender(truncateText(slData.name, 12), currentTextLineY_InSlot_display); currentTextLineY_InSlot_display += tLH_logical; }
                if (slData.food && slData.food !== '未選択') { const foodColorForDisplay = cropColors[slData.food] || '#888'; drawTextLineInSlot_ForRender(truncateText('好物:' + slData.food, 15), currentTextLineY_InSlot_display, true, foodColorForDisplay); currentTextLineY_InSlot_display += tLH_logical; }
                if (slData.order && (slK === 'qr1' || slK === 'qr2')) { drawTextLineInSlot_ForRender(slData.order, currentTextLineY_InSlot_display); }
              }
              targetContext.restore();
              slDrawn++;
              if (slDrawn < (dispSKs.length > 0 ? dispSKs.length : 1)) {
                curSlX += slW + cIP;
              }
            }
          }
          targetContext.restore();
        });

        // 6. テキストアイテムの描画
        items.textItems.forEach(textItem => {
          targetContext.save();
          targetContext.translate(textItem.x + textItem.width / 2, textItem.y + textItem.height / 2);
          if (textItem.rotation) targetContext.rotate(textItem.rotation * Math.PI / 180);
          const dX = -textItem.width / 2, dY = -textItem.height / 2;

          const isSelectedForTextDisplay = currentSelectedItem && currentSelectedItem.id === textItem.id && targetCanvasElement === canvas;

          targetContext.fillStyle = textItem.backgroundColor;
          drawRoundedRect(targetContext, dX, dY, textItem.width, textItem.height, 5);
          targetContext.fill();

          if (textItem.borderVisible) {
            targetContext.lineWidth = (isSelectedForTextDisplay ? 4 : 2) / drawScale;
            targetContext.strokeStyle = isSelectedForTextDisplay ? '#007bff' : '#555';
            drawRoundedRect(targetContext, dX, dY, textItem.width, textItem.height, 5);
            targetContext.stroke();
          } else if (isSelectedForTextDisplay) {
            targetContext.lineWidth = 4 / drawScale;
            targetContext.strokeStyle = '#007bff';
            drawRoundedRect(targetContext, dX, dY, textItem.width, textItem.height, 5);
            targetContext.stroke();
          }
          targetContext.fillStyle = textItem.color;
          targetContext.font = `${textItem.fontSize / drawScale}px ${textItem.font || DEFAULT_FONT}`;
          targetContext.textAlign = 'left';
          targetContext.textBaseline = 'top';
          const textPaddingForRender_logical = TEXT_ITEM_PADDING;
          const contentMaxWidth_logical = textItem.width - (textPaddingForRender_logical * 2);

          if (contentMaxWidth_logical > 0) {
            const measured = wrapTextAndMeasure(textItem.text, contentMaxWidth_logical, textItem.fontSize, textItem.font || DEFAULT_FONT, TEXT_LINE_HEIGHT_MULTIPLIER);
            const linesToDraw = measured.linesArray;
            const lineHeightForRender_display = (textItem.fontSize * TEXT_LINE_HEIGHT_MULTIPLIER) / drawScale;
            let currentY_render_display = dY + textPaddingForRender_logical;

            for (let i = 0; i < linesToDraw.length; i++) {
              const lineText = linesToDraw[i];
              // 描画領域チェックも論理サイズで行う
              if (currentY_render_display + lineHeightForRender_display > dY + textItem.height - textPaddingForRender_logical && i < linesToDraw.length) {
                if (currentY_render_display + (textItem.fontSize / drawScale) <= dY + textItem.height - textPaddingForRender_logical) {
                  let visiblePortion = '';
                  for (let charIdx = 0; charIdx < lineText.length; charIdx++) {
                    const testPortion = visiblePortion + lineText[charIdx];
                    // measureText は現在のコンテキストのフォント設定で行われる
                    if (targetContext.measureText(testPortion + "...").width > contentMaxWidth_logical) break;
                    visiblePortion = testPortion;
                  }
                  targetContext.fillText(visiblePortion + "...", dX + textPaddingForRender_logical, currentY_render_display, contentMaxWidth_logical);
                }
                break;
              }
              if (currentY_render_display + (textItem.fontSize / drawScale) <= dY + textItem.height - textPaddingForRender_logical) {
                targetContext.fillText(lineText, dX + textPaddingForRender_logical, currentY_render_display, contentMaxWidth_logical);
              }
              currentY_render_display += lineHeightForRender_display;
            }
          }
          targetContext.restore();
        });
        targetContext.restore();
      }
      function saveDrawingState() {
        drawnPathsHistory = drawnPathsHistory.slice(0, drawnPathsHistoryIndex + 1);
        drawnPathsHistory.push(JSON.parse(JSON.stringify(drawnPaths)));
        drawnPathsHistoryIndex++;
        updateDrawingUndoRedoButtons();
      }

      function undoDrawing() {
        if (drawnPathsHistoryIndex <= 0) return;

        drawnPathsHistoryIndex--;
        drawnPaths = JSON.parse(JSON.stringify(drawnPathsHistory[drawnPathsHistoryIndex]));
        drawCanvas();
        updateDrawingUndoRedoButtons();
      }

      function redoDrawing() {
        if (drawnPathsHistoryIndex >= drawnPathsHistory.length - 1) return;

        drawnPathsHistoryIndex++;
        drawnPaths = JSON.parse(JSON.stringify(drawnPathsHistory[drawnPathsHistoryIndex]));
        drawCanvas();
        updateDrawingUndoRedoButtons();
      }

      function updateDrawingUndoRedoButtons() {
        if (drawingUndoButton) {
          drawingUndoButton.disabled = drawnPathsHistoryIndex <= 0;
        }
        if (drawingRedoButton) {
          drawingRedoButton.disabled = drawnPathsHistoryIndex >= drawnPathsHistory.length - 1;
        }
      }

      function resetDrawingHistory() {
        drawnPathsHistory = [JSON.parse(JSON.stringify(drawnPaths))];
        drawnPathsHistoryIndex = 0;
        updateDrawingUndoRedoButtons();
      }

      function performAlignment(alignType) {
        if (!alignBaseUnit || alignTargetUnits.length === 0) {
          alert("基準ユニットまたは対象ユニットが選択されていません。");
          closeModal(alignOptionsModal);
          toggleMode(null);
          return;
        }

        let changesMade = false;
        alignTargetUnits.forEach(targetUnit => {
          if (targetUnit.id === alignBaseUnit.id) return;

          if (alignType === 'horizontal') {
            if (targetUnit.y !== alignBaseUnit.y) {
              targetUnit.y = alignBaseUnit.y;
              changesMade = true;
            }
          } else if (alignType === 'vertical') {
            if (targetUnit.x !== alignBaseUnit.x) {
              targetUnit.x = alignBaseUnit.x;
              changesMade = true;
            }
          }
        });

        if (changesMade) {
          const message = alignType === 'horizontal' ? '水平方向に整列しました。' : '垂直方向に整列しました。';
          showStatusBar(message, alignButton);
          saveState();
          drawCanvas();
        } else {
          showStatusBar('ユニットは既に整列されています。変更はありませんでした。', alignButton);
        }

        closeModal(alignOptionsModal);
        toggleMode(null);
      }

      function initializeTemplateSelector() {
        if (!templateSelect) return;
        templateSelect.innerHTML = '<option value="">選択してください</option>';
        FAMILY_TREE_TEMPLATES.forEach(template => {
          const option = document.createElement('option');
          option.value = template.id;
          option.textContent = template.name;
          templateSelect.appendChild(option);
        });
      }

      function updateTemplateUI() {
        if (!templateSelect || !templateImageUpload || !templateImageInfo || !addFromTemplateButton) return;

        const selectedTemplateId = templateSelect.value;
        selectedTemplate = FAMILY_TREE_TEMPLATES.find(t => t.id === selectedTemplateId) || null;

        if (selectedTemplate) {
          templateImageUpload.disabled = false;
          templateImageInfo.textContent = `画像 ${templateUploadedImages.length} / ${selectedTemplate.maxImages} 枚選択中。`;
          if (templateUploadedImages.length === selectedTemplate.maxImages) {
            addFromTemplateButton.disabled = false;
            templateImageInfo.textContent += ' (必要枚数に達しました)';
          } else if (templateUploadedImages.length > selectedTemplate.maxImages) {
            addFromTemplateButton.disabled = true;
            templateImageInfo.textContent += ` (枚数超過: ${templateUploadedImages.length - selectedTemplate.maxImages}枚削除してください)`;
            templateImageInfo.style.color = 'red';
          } else {
            addFromTemplateButton.disabled = true;
            templateImageInfo.style.color = '#6c757d';
          }
        } else {
          templateImageUpload.disabled = true;
          templateImageInfo.textContent = 'テンプレートを選択すると、必要な画像枚数が表示されます。';
          addFromTemplateButton.disabled = true;
          templateUploadedImages = [];
          templateImagePreviews.innerHTML = '';
          templateImageInfo.style.color = '#6c757d';
        }
      }

      function adjustLayoutHeight() {
        if (!container || !topArea || !bottomControls) {
          // console.warn("Layout elements not found for height adjustment.");
          return;
        }

        const windowHeight = window.innerHeight;
        container.style.height = `${windowHeight}px`;
        const currentLeftPanel = document.getElementById('left-panel');
        const currentLeftPanelToggleButton = document.getElementById('left-panel-toggle-button');
        if (currentLeftPanel && currentLeftPanelToggleButton && !currentLeftPanel.classList.contains('collapsed')) {
          currentLeftPanelToggleButton.style.left = `${currentLeftPanel.offsetWidth}px`;
        }
      }


      // ========================================
      // 5. イベントリスナー設定 (...addEventListener(...))
      // ========================================
      leftPanelToggleButton.addEventListener('click', () => {
        leftPanel.classList.toggle('collapsed');

        if (leftPanel.classList.contains('collapsed')) {
          leftPanelToggleButton.innerHTML = '＞';
          leftPanelToggleButton.title = "左パネルを展開";
          leftPanelToggleButton.classList.remove('panel-is-open');
          leftPanelToggleButton.classList.add('panel-is-closed');
        } else {
          leftPanelToggleButton.innerHTML = '＜';
          leftPanelToggleButton.title = "左パネルを収納";
          leftPanelToggleButton.style.left = `${leftPanel.offsetWidth}px`;
          leftPanelToggleButton.classList.add('panel-is-open');
          leftPanelToggleButton.classList.remove('panel-is-closed');
        }
      });

      window.addEventListener('resize', () => { if (!leftPanel.classList.contains('collapsed')) leftPanelToggleButton.style.left = `${leftPanel.offsetWidth}px`; resizeCanvas(); });
      undoButton.addEventListener('click', () => {
        if (historyIndex < 0) {
          return;
        }

        const modeBeforeRestore = currentMode;

        historyIndex--;

        if (historyIndex < 0) {
          units = [];
          groups = [];
          textItems = [];
          connections = [];
          drawnPaths = [];
          nextItemId = 0;
          selectedItem = null;
          draggingItem = null;
          resizingItem = null;
          resizeHandle = null;
          connectFromItem = null;
          itemsToGroup = [];
          currentDrawingPath = [];

          if (modeBeforeRestore) {
            toggleMode(null);
          }

          // ズームやパンも初期化する場合 (必要に応じてコメント解除)
          // scale = 1.0;
          // zoomLevel = 0;
          // originX = 0;
          // originY = 0;
          // if (zoomLevelIndicator) zoomLevelIndicator.textContent = zoomLevel;
          resetDrawingHistory();
          drawCanvas();
          updateInfoModal();
        } else {
          restoreState(history[historyIndex]);
        }
        if (modeBeforeRestore === 'draw-path') {
          if (drawModeButton) {
            toggleMode('draw-path', drawModeButton);
          } else {
            currentMode = 'draw-path';
            if (drawingToolsPanel) drawingToolsPanel.style.display = 'block';
            canvas.style.cursor = 'crosshair';
            resetDrawingHistory();
          }
        } else if (currentMode === 'draw-path' && modeBeforeRestore !== 'draw-path') {
        }
        updateUndoRedoButtons();
      });
      redoButton.addEventListener('click', () => {
        if (historyIndex >= history.length - 1) return;

        const modeBeforeRestore = currentMode;

        historyIndex++;
        restoreState(history[historyIndex]);

        if (modeBeforeRestore === 'draw-path') {
          if (drawModeButton) {
            toggleMode('draw-path', drawModeButton);
          } else {
            currentMode = 'draw-path';
            if (drawingToolsPanel) drawingToolsPanel.style.display = 'block';
            canvas.style.cursor = 'crosshair';
            resetDrawingHistory();
          }
        } else if (currentMode === 'draw-path' && modeBeforeRestore !== 'draw-path') {
        }
        updateUndoRedoButtons();
      });
      imageSlots.qr1.orderSakiCheckbox.addEventListener('change', (e) => handleQrOrderChange('qr1', '先', 'left-panel'));
      imageSlots.qr1.orderAtoCheckbox.addEventListener('change', (e) => handleQrOrderChange('qr1', '後', 'left-panel'));
      imageSlots.qr2.orderSakiCheckbox.addEventListener('change', (e) => handleQrOrderChange('qr2', '先', 'left-panel'));
      imageSlots.qr2.orderAtoCheckbox.addEventListener('change', (e) => handleQrOrderChange('qr2', '後', 'left-panel'));
      Object.keys(imageSlots).forEach(slotKey => {
        const slotUI = imageSlots[slotKey];
        if (slotUI.orderSakiCheckbox) {
          slotUI.orderSakiCheckbox.addEventListener('change', (e) => { if (e.target.checked) slotUI.orderAtoCheckbox.checked = false; });
          slotUI.orderAtoCheckbox.addEventListener('change', (e) => { if (e.target.checked) slotUI.orderSakiCheckbox.checked = false; });
        }
        slotUI.uploadInput.addEventListener('change', (event) => {
          const file = event.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (e_reader) => {
              const originalDataUrl = e_reader.target.result;
              slotUI.previewImg.src = originalDataUrl; slotUI.previewImg.style.display = 'block';
              slotUI.editBtn.disabled = false; slotUI.clearBtn.classList.remove('hidden');
              const img = new Image();
              img.onload = () => { imageSlots[slotKey].data = { img: img, fileName: file.name, originalDataUrl: originalDataUrl, imgDataUrl: originalDataUrl }; checkAddUnitButtonState(); };
              img.onerror = () => { console.error("Orig img load err for slot:", slotKey); imageSlots[slotKey].data = null; slotUI.editBtn.disabled = true; slotUI.clearBtn.classList.add('hidden'); checkAddUnitButtonState(); };
              img.src = originalDataUrl;
            };
            reader.readAsDataURL(file);
          } else { slotUI.previewImg.style.display = 'none'; slotUI.previewImg.src = '#'; slotUI.editBtn.disabled = true; slotUI.clearBtn.classList.add('hidden'); imageSlots[slotKey].data = null; checkAddUnitButtonState(); }
        });
        slotUI.editBtn.addEventListener('click', () => {
          if (imageSlots[slotKey].data && imageSlots[slotKey].data.originalDataUrl) {
            currentImageSlotKeyForEditing = slotKey; currentEditingUnitContext = 'left-panel';
            imageToCrop.src = imageSlots[slotKey].data.originalDataUrl; openModal(cropperModal);
            if (cropper) cropper.destroy();
            const aspRatio = (slotKey === 'birth') ? NaN : 1; aspectRatioSelect.value = isNaN(aspRatio) ? "NaN" : aspRatio.toString();
            cropper = new Cropper(imageToCrop, { aspectRatio: aspRatio, viewMode: 1, background: false, zoomable: true, movable: true, cropBoxResizable: true, dragMode: 'move' });
            currentCropFinalizeCallback = (croppedDataUrl) => {
              const targetSlotUI = imageSlots[currentImageSlotKeyForEditing]; const targetSlotData = targetSlotUI.data;
              targetSlotUI.previewImg.src = croppedDataUrl; const img = new Image();
              img.onload = () => { targetSlotData.img = img; targetSlotData.imgDataUrl = croppedDataUrl; checkAddUnitButtonState(); };
              img.onerror = () => { console.error("Cropped img load err for slot:", currentImageSlotKeyForEditing); checkAddUnitButtonState(); };
              img.src = croppedDataUrl; closeCropperModal();
            };
          } else { alert("編集する画像がアップロードされていません。"); }
        });
        slotUI.clearBtn.addEventListener('click', () => { slotUI.previewImg.style.display = 'none'; slotUI.previewImg.src = '#'; slotUI.uploadInput.value = ''; slotUI.editBtn.disabled = true; slotUI.clearBtn.classList.add('hidden'); imageSlots[slotKey].data = null; checkAddUnitButtonState(); });
      });
      imageCollectionUploadInput.addEventListener('change', async (event) => {
        const files = event.target.files;
        if (!files || files.length === 0) { uploadedCollectionImages = []; imageCollectionPreviewsDiv.innerHTML = ''; imageCollectionDetailsDiv.innerHTML = ''; checkAddImageCollectionButtonState(); if (clearImageCollectionButton) clearImageCollectionButton.classList.add('hidden'); return; }
        if (clearImageCollectionButton) clearImageCollectionButton.classList.remove('hidden');
        if (files.length > 20) { alert('画像は最大20枚まで'); imageCollectionUploadInput.value = ''; return; }
        uploadedCollectionImages = []; imageCollectionPreviewsDiv.innerHTML = ''; imageCollectionDetailsDiv.innerHTML = ''; addImageCollectionButton.disabled = true;
        const loadImage = async (file) => { return new Promise((resolve) => { const reader = new FileReader(); reader.onload = (e_r) => { const iDU = e_r.target.result; const img = new Image(); img.onload = () => resolve({ img, imgDataUrl: iDU, originalDataUrl: iDU, fileName: file.name, name: '', food: '未選択' }); img.onerror = () => resolve(null); img.src = iDU; }; reader.onerror = () => resolve(null); reader.readAsDataURL(file); }); };
        try {
          const results = await Promise.all(Array.from(files).map(loadImage));
          uploadedCollectionImages = results.filter(r => r !== null);
          imageCollectionPreviewsDiv.innerHTML = '';
          uploadedCollectionImages.forEach((imgD, idx) => { imgD.originalIndex = idx; const pIE = document.createElement('img'); pIE.src = imgD.imgDataUrl; pIE.title = imgD.fileName; pIE.dataset.index = idx; pIE.onclick = () => selectCollectionImageForDetail(idx); imageCollectionPreviewsDiv.appendChild(pIE); });
          renderImageCollectionDetails(); checkAddImageCollectionButtonState();
        } catch (error) { console.error("Err loading collection imgs:", error); alert("画像読込エラー"); checkAddImageCollectionButtonState(); }
      });
      addImageCollectionButton.addEventListener('click', () => {
        if (addImageCollectionButton.disabled || uploadedCollectionImages.length === 0) return;
        const newCollectionImages = uploadedCollectionImages.map(imgData => ({ img: imgData.img, imgDataUrl: imgData.imgDataUrl, originalDataUrl: imgData.originalDataUrl, fileName: imgData.fileName, name: imgData.name, food: imgData.food }));
        const { width: unitWidth, height: unitHeight } = calculateImageCollectionUnitSize(newCollectionImages); // 初回はデフォルト設定
        const borderVisible = imageCollectionBorderCheckbox.checked;
        const newImageCollectionUnit = {
          id: `item-${nextItemId++}`, type: 'image-collection', images: newCollectionImages,
          x: (-originX + (mainCanvasArea.clientWidth / 2) - (unitWidth / 2)) / scale, y: (-originY + (mainCanvasArea.clientHeight / 2) - (unitHeight / 2)) / scale,
          width: unitWidth, height: unitHeight, isSelected: false, borderVisible: borderVisible, layoutSettings: null
        };
        units.push(newImageCollectionUnit); saveState(); drawCanvas(); updateInfoModal();
        resetImageUploadsAndInputs();
      });
      cropperZoomControls.addEventListener('click', (e) => { if (!cropper) return; const t = e.target; if (t.tagName === 'BUTTON') { if (t.dataset.zoom) cropper.zoomTo(parseFloat(t.dataset.zoom)); else if (t.dataset.zoomIn) cropper.zoom(0.1); else if (t.dataset.zoomOut) cropper.zoom(-0.1); } });
      aspectRatioSelect.addEventListener('change', () => { if (cropper) cropper.setAspectRatio(parseFloat(aspectRatioSelect.value)); });
      cropImageButton.addEventListener('click', () => { if (cropper && currentCropFinalizeCallback) { const cDU = cropper.getCroppedCanvas({ imageSmoothingEnabled: true, imageSmoothingQuality: 'high' }).toDataURL(); currentCropFinalizeCallback(cDU); } });
      cancelCropButton.addEventListener('click', closeCropperModal);
      cropperModalCloseButtonHeader.addEventListener('click', closeCropperModal);
      addUnitButton.addEventListener('click', () => {
        if (addUnitButton.disabled) return;

        const newUnitSlotsData = {};
        const activeSlotKeys = [];
        let imageCount = 0;

        // imageSlots に定義されている各スロットキー (birth, qr1, qr2) でループ
        for (const slotKey of Object.keys(imageSlots)) {
          const slotUI = imageSlots[slotKey];
          const slotLoadedData = slotUI.data;
          let orderValue = null;
          if (slotKey === 'qr1' || slotKey === 'qr2') {
            if (slotUI.orderSakiCheckbox && slotUI.orderSakiCheckbox.checked) orderValue = '先';
            else if (slotUI.orderAtoCheckbox && slotUI.orderAtoCheckbox.checked) orderValue = '後';
          }

          newUnitSlotsData[slotKey] = {
            img: null,
            imgDataUrl: null,
            originalDataUrl: null,
            fileName: null,
            name: slotUI.nameInput.value.trim(),
            food: slotUI.foodSelect.value,
            order: orderValue
          };

          if (slotLoadedData && slotLoadedData.img && slotLoadedData.imgDataUrl) {
            imageCount++;
            activeSlotKeys.push(slotKey);
            newUnitSlotsData[slotKey].img = slotLoadedData.img;
            newUnitSlotsData[slotKey].imgDataUrl = slotLoadedData.imgDataUrl; // 画像があれば上書き
            newUnitSlotsData[slotKey].originalDataUrl = slotLoadedData.originalDataUrl;
            newUnitSlotsData[slotKey].fileName = slotLoadedData.fileName;
          }
        }

        if (imageCount === 0) {
          console.warn("addUnitButton was clicked but imageCount is 0. This shouldn't happen if button is properly disabled.");
          // alert("ユニットを作成するには少なくとも1つの画像を選択してください。"); // 必要ならユーザーに通知
          return;
        }

        let unitWidth;
        if (imageCount === 1) unitWidth = UNIT_WIDTH_ONE_SLOT;
        else if (imageCount === 2) unitWidth = UNIT_WIDTH_TWO_SLOTS;
        else unitWidth = UNIT_WIDTH_THREE_SLOTS;

        const unitHeight = calculateUnitHeight(newUnitSlotsData); // newUnitSlotsData は適切に初期化されているはず
        const borderVisible = addUnitBorderVisibleCheckbox.checked;

        const newUnit = {
          id: `item-${nextItemId++}`,
          type: 'unit',
          slots: newUnitSlotsData,
          x: (-originX + (mainCanvasArea.clientWidth / 2) - (unitWidth / 2)) / scale,
          y: (-originY + (mainCanvasArea.clientHeight / 2) - (unitHeight / 2)) / scale,
          width: unitWidth,
          height: unitHeight,
          isSelected: false,
          borderVisible: borderVisible,
          activeSlotKeys: activeSlotKeys,
          isMonocolor: false,      // 新規追加プロパティのデフォルト値
          isTargetIndividual: false // 新規追加プロパティのデフォルト値
        };
        units.push(newUnit);
        console.log("Newly created unit with slots:", JSON.parse(JSON.stringify(newUnit.slots))); // 作成直後のスロット確認
        resetImageUploadsAndInputs();
        saveState();
        drawCanvas();
        updateInfoModal();
      });
      addTextContentInput.addEventListener('input', checkAddTextButtonState);
      addTextItemButton.addEventListener('click', () => {
        if (addTextItemButton.disabled) return; const textContent = addTextContentInput.value; if (textContent.trim() === '') return;
        const fontSize = parseInt(addTextSizeInput.value, 10); const font = DEFAULT_FONT; const textPadding = TEXT_ITEM_PADDING; const borderVisible = addTextBorderVisibleCheckbox.checked;
        const measureForWidth = wrapTextAndMeasure(textContent, Infinity, fontSize, font, TEXT_LINE_HEIGHT_MULTIPLIER);
        let calculatedWidth = measureForWidth.calculatedWidth + (textPadding * 2); calculatedWidth = Math.max(MIN_TEXT_ITEM_WIDTH, calculatedWidth);
        const finalMaxWidth = calculatedWidth - (textPadding * 2); const finalMeasured = wrapTextAndMeasure(textContent, finalMaxWidth, fontSize, font, TEXT_LINE_HEIGHT_MULTIPLIER);
        let calculatedHeight = finalMeasured.calculatedHeight + (textPadding * 2); calculatedHeight = Math.max(MIN_TEXT_ITEM_HEIGHT, calculatedHeight);
        const newTextItem = { id: `item-${nextItemId++}`, type: 'text', text: textContent, font: font, color: addTextColorInput.value, backgroundColor: addTextBgColorInput.value, fontSize: fontSize, x: (-originX + (mainCanvasArea.clientWidth / 2) - (calculatedWidth / 2)) / scale, y: (-originY + (mainCanvasArea.clientHeight / 2) - (calculatedHeight / 2)) / scale, width: calculatedWidth, height: calculatedHeight, isSelected: false, borderVisible: borderVisible, rotation: 0 };
        textItems.push(newTextItem); saveState(); drawCanvas();
        addTextContentInput.value = ''; addTextColorInput.value = "#000000"; addTextBgColorInput.value = "#ffffff"; addTextSizeInput.value = "20"; addTextBorderVisibleCheckbox.checked = true; checkAddTextButtonState();
      });
      canvas.addEventListener('mousedown', handleInteractionStart);
      canvas.addEventListener('mousemove', handleInteractionMove);
      canvas.addEventListener('mouseup', handleInteractionEnd);
      canvas.addEventListener('mouseup', handleInteractionEnd);
      canvas.addEventListener('mouseleave', handleInteractionEnd);
      canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleInteractionStart(e); }, { passive: false });
      canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleInteractionMove(e); }, { passive: false });
      canvas.addEventListener('touchend', handleInteractionEnd);
      canvas.addEventListener('touchcancel', handleInteractionEnd);
      connectButton.addEventListener('click', () => toggleMode('connect', connectButton));
      editUnitButton.addEventListener('click', () => toggleMode('edit-item', editUnitButton));
      if (drawModeButton) {
        drawModeButton.addEventListener('click', () => toggleMode('draw-path', drawModeButton));
      }
      groupButton.addEventListener('click', () => {
        if (currentMode === 'grouping') {
          if (itemsToGroup.length >= 2) {
            createGroupFromSelection();
            toggleMode(null);
          } else {
            alert("グループ化するには、少なくとも2つのユニットを選択してください。");
          }
        } else {
          toggleMode('grouping', groupButton);
        }
      });
      saveCanvasButton.addEventListener('click', async () => {
        console.log("保存ボタンがクリックされました！ (プレビュー表示へ)");

        const mainCanvasElement = document.getElementById('family-tree-canvas');
        if (!mainCanvasElement) {
          alert("メインキャンバスが見つかりません。");
          return;
        }
        const desiredBackgroundColor = '#fdfdfd'; // 画像全体の背景色

        // 1. 家系図コンテンツのバウンディングボックス計算 (既存ロジック流用)
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        let contentExists = false;
        const itemsToConsiderForBounds = [];
        [...units, ...groups, ...textItems].forEach(item => {
          itemsToConsiderForBounds.push({ x: item.x, y: item.y, width: item.width || 0, height: item.height || 0 });
        });
        drawnPaths.forEach(path => {
          if (path.points && path.points.length > 0) {
            path.points.forEach(p => itemsToConsiderForBounds.push({ x: p[0], y: p[1], width: 0, height: 0 }));
            if (path.startX !== undefined) { // For shapes like rectangle/circle
              itemsToConsiderForBounds.push({ x: path.startX, y: path.startY, width: 0, height: 0 });
            }
          }
        });
        connections.forEach(conn => {
          const fromItem = findItemById(conn.fromId);
          const toItem = findItemById(conn.toId);
          if (fromItem) itemsToConsiderForBounds.push({ x: fromItem.x, y: fromItem.y, width: fromItem.width, height: fromItem.height });
          if (toItem) itemsToConsiderForBounds.push({ x: toItem.x, y: toItem.y, width: toItem.width, height: toItem.height });
        });

        if (itemsToConsiderForBounds.length === 0 && drawnPaths.length === 0 && connections.length === 0) {
          alert("保存する内容がキャンバスにありません。");
          return;
        }

        itemsToConsiderForBounds.forEach(item => {
          contentExists = true;
          minX = Math.min(minX, item.x);
          minY = Math.min(minY, item.y);
          maxX = Math.max(maxX, item.x + (item.width || 0));
          maxY = Math.max(maxY, item.y + (item.height || 0));
        });

        if (!contentExists) {
          alert("保存する内容がキャンバスにありません。");
          return;
        }
        if (maxX - minX < 1) maxX = minX + 50; // 最小幅/高さを確保
        if (maxY - minY < 1) maxY = minY + 50;

        const treePadding = 30; // 家系図周囲の余白
        const treeContentWidth = maxX - minX;
        const treeContentHeight = maxY - minY;
        const treeDrawingAreaWidth = treeContentWidth + treePadding * 2;
        const treeDrawingAreaHeight = treeContentHeight + treePadding * 2;

        // 2. 情報エリアのコンテンツ収集と準備
        const INFO_AREA_BACKGROUND_COLOR = '#ffffff'; // 情報エリアの背景色
        const INFO_DEFAULT_TEXT_COLOR = '#000000';
        const INFO_HEADER_TEXT_COLOR = '#000000';
        const INFO_SECONDARY_TEXT_COLOR = '#555555';
        const INFO_ERROR_TEXT_COLOR = '#e74c3c';
        const INFO_INDENT_SIZE = 15; // インデント幅

        const infoAreaMinWidth = 350; // 情報エリアの最小幅
        const infoInternalPadding = 25; // 情報エリア内のパディング
        const infoLineHeight = 24;    // テキスト1行の基本高さ
        const infoFontSize = 15;      // 基本フォントサイズ
        const infoImageSize = 20;     // 推奨捕獲順のユニット画像のサイズ
        const infoImageTextGap = 5;   // 画像とテキストの間隔

        const infoAreaContent = [];   // 描画する情報をここに格納
        const captureImagesToLoad = {}; // 推奨捕獲順の画像URLとImageオブジェクトのマッピング

        // ヘルパー関数: 情報を行として追加
        const addInfo = (type, content, options = {}) => {
          infoAreaContent.push({
            type: type, // 'header', 'text', 'bullet', 'imageText', 'separator'
            content: content,
            indent: options.indent || 0,
            isBold: options.isBold || false,
            color: options.color || INFO_DEFAULT_TEXT_COLOR,
            imageUrl: options.imageUrl || null // for 'imageText'
          });
          if (type === 'imageText' && options.imageUrl && !captureImagesToLoad[options.imageUrl]) {
            captureImagesToLoad[options.imageUrl] = { img: null, loaded: false, error: false };
          }
        };

        // --- 必要作物 ---
        addInfo('header', "--- 必要作物 ---", { isBold: true, color: INFO_HEADER_TEXT_COLOR });
        const cropListItems = requiredCropsList.querySelectorAll('li.crop-list-item');
        if (cropListItems.length > 0) {
          cropListItems.forEach(item => {
            const foodTextContent = item.textContent ? item.textContent.trim() : "情報なし";
            const foodNameMatch = foodTextContent.match(/^([\u3040-\u309F\u30A0-\u30FF\uFF00-\uFFEF\w]+):/); // ひらがな、カタカナ、漢字、英数字
            const foodName = foodNameMatch ? foodNameMatch[1] : null;
            // cropColorsは既にグローバルスコープで定義されている想定
            const foodColor = foodName && typeof cropColors !== 'undefined' && cropColors[foodName] ? cropColors[foodName] : INFO_DEFAULT_TEXT_COLOR;
            addInfo('bullet', foodTextContent, { indent: 1, color: foodColor });
          });
        } else {
          addInfo('text', "なし", { indent: 1 });
        }
        addInfo('separator', '');

        // --- 必要ゴールド ---
        addInfo('header', "--- 必要ゴールド ---", { isBold: true, color: INFO_HEADER_TEXT_COLOR });
        addInfo('text', document.getElementById('total-gold-cost').textContent, { indent: 1 });
        const goldDetailsNode = document.getElementById('gold-details');
        const plainGoldDetails = goldDetailsNode ? goldDetailsNode.textContent.replace(/\(\s*内訳[^)]*\)/g, '').trim() : ""; // (内訳...) を除去
        addInfo('text', `(${plainGoldDetails})`, { indent: 1, color: INFO_SECONDARY_TEXT_COLOR });
        addInfo('separator', '');

        // --- 推奨捕獲順 ---
        const targetIndividualForSave = units.find(u => u.isTargetIndividual === true);
        if (targetIndividualForSave && targetIndividualForSave.type === 'unit' && targetIndividualForSave.activeSlotKeys?.length === 1) {
          const { sakiParent, atoParent, birthPartner, error: dtprError } = determineTargetParentRoles(targetIndividualForSave);
          if (!dtprError && sakiParent && atoParent) {
            addInfo('header', "--- 推奨捕獲順 ---", { isBold: true, color: INFO_HEADER_TEXT_COLOR });
            addInfo('text', `目標: ${getItemDisplayName(targetIndividualForSave)}`, { indent: 1 });
            if (sakiParent) addInfo('text', `先の親系統: ${getItemDisplayName(sakiParent)}`, { indent: 2 });
            if (atoParent) addInfo('text', `後の親系統: ${getItemDisplayName(atoParent)}`, { indent: 2 });
            if (birthPartner) addInfo('text', `出生の相方(参考): ${getItemDisplayName(birthPartner)}`, { indent: 2, color: INFO_SECONDARY_TEXT_COLOR });
            addInfo('separator', '');

            const capturePhasesElements = document.getElementById('recommended-capture-order-content')?.querySelectorAll('.capture-phase');
            if (capturePhasesElements && capturePhasesElements.length > 0) {
              capturePhasesElements.forEach(phaseEl => {
                const phaseTitle = phaseEl.querySelector('h5')?.textContent || "フェーズ";
                addInfo('header', phaseTitle, { indent: 1, isBold: true });
                const phaseItems = phaseEl.querySelectorAll('li');
                if (phaseItems.length > 0) {
                  phaseItems.forEach(li => {
                    const unitName = li.querySelector('strong')?.textContent || "不明";
                    const imgSrc = li.querySelector('img')?.src;
                    let attributesText = "";
                    const monoColorSpan = li.querySelector('span[style*="color:#e74c3c"]'); // 単色
                    const garaSpan = li.querySelector('span[style*="color:#2ecc71"]');    // 柄
                    if (monoColorSpan) attributesText = monoColorSpan.textContent.trim();
                    else if (garaSpan) attributesText = garaSpan.textContent.trim();

                    const roleText = li.querySelector('small') ? li.querySelector('small').textContent.trim() : "";
                    addInfo('imageText', `${unitName} ${attributesText}`, { indent: 2, imageUrl: imgSrc });
                    if (roleText) addInfo('text', `(${roleText})`, { indent: 3, color: INFO_SECONDARY_TEXT_COLOR });
                  });
                } else {
                  addInfo('text', "(該当なし)", { indent: 2, color: INFO_SECONDARY_TEXT_COLOR });
                }
                addInfo('separator', '');
              });
            } else {
              addInfo('text', "(表示できる捕獲順がありません)", { indent: 1, color: INFO_SECONDARY_TEXT_COLOR });
            }
          } else if (dtprError) {
            addInfo('header', "--- 推奨捕獲順 ---", { isBold: true, color: INFO_HEADER_TEXT_COLOR });
            addInfo('text', `(エラー: ${dtprError})`, { indent: 1, color: INFO_ERROR_TEXT_COLOR });
          }
        } else if (targetIndividualForSave) { // isTargetIndividualだが条件を満たさない場合
          addInfo('header', "--- 推奨捕獲順 ---", { isBold: true, color: INFO_HEADER_TEXT_COLOR });
          addInfo('text', "(目標個体の設定が無効です。画像1枚のユニットである必要があります)", { indent: 1, color: INFO_ERROR_TEXT_COLOR });
        }
        // ツール情報など
        addInfo('separator', '');
        addInfo('text', "Generated by DenpaKakeizuTool", { color: "#aaaaaa" });


        // 3. 情報エリアの幅と高さ計算
        let maxInfoTextWidth = 0;
        let calculatedInfoAreaHeight = infoInternalPadding; // 上下パディングの初期値
        const tempMeasureCtx = document.createElement('canvas').getContext('2d');
        if (!tempMeasureCtx) {
          alert("画像生成のための内部処理に失敗しました。");
          return;
        }

        infoAreaContent.forEach(line => {
          tempMeasureCtx.font = line.isBold ? `bold ${infoFontSize}px ${DEFAULT_FONT}` : `${infoFontSize}px ${DEFAULT_FONT}`;
          let lineContent = "";
          let lineIndentWidth = (line.indent || 0) * INFO_INDENT_SIZE;

          if (line.type === 'imageText' && line.imageUrl) {
            lineContent = line.content || "";
            maxInfoTextWidth = Math.max(maxInfoTextWidth, lineIndentWidth + infoImageSize + infoImageTextGap + tempMeasureCtx.measureText(lineContent).width);
            calculatedInfoAreaHeight += Math.max(infoLineHeight, infoImageSize);
          } else if (line.type === 'bullet') {
            lineContent = line.content || "";
            // cropColors から円の色を取得し、それに基づいてbulletを描画することを想定
            // ここではテキスト幅のみ計算
            const bulletIndent = (line.indent || 0) * INFO_INDENT_SIZE;
            const bulletRadius = infoFontSize * 0.28; // 文字サイズに対する比率で
            const bulletGap = infoInternalPadding / 4; // bulletとテキストの間
            maxInfoTextWidth = Math.max(maxInfoTextWidth, bulletIndent + bulletRadius * 2 + bulletGap + tempMeasureCtx.measureText(lineContent).width);
            calculatedInfoAreaHeight += infoLineHeight;
          } else if (line.type === 'separator') {
            calculatedInfoAreaHeight += infoLineHeight / 2; // 区切り線は少し間隔を狭く
          } else { // header or text
            lineContent = line.content || "";
            maxInfoTextWidth = Math.max(maxInfoTextWidth, lineIndentWidth + tempMeasureCtx.measureText(lineContent).width);
            calculatedInfoAreaHeight += infoLineHeight;
          }
        });
        calculatedInfoAreaHeight += infoInternalPadding; // 下パディング
        const calculatedInfoAreaWidth = Math.max(infoAreaMinWidth, maxInfoTextWidth + infoInternalPadding * 2); // 左右パディング込み

        // 4. 画像の事前読み込み (推奨捕獲順の画像)
        if (Object.keys(captureImagesToLoad).length > 0) {
          const loadImagePromises = Object.keys(captureImagesToLoad).map(url => {
            return new Promise((resolve) => {
              const img = new Image();
              img.crossOrigin = "Anonymous"; // クロスオリジン対応（DataURLなら不要だが念のため）
              img.onload = () => {
                captureImagesToLoad[url].img = img;
                captureImagesToLoad[url].loaded = true;
                resolve();
              };
              img.onerror = () => {
                captureImagesToLoad[url].error = true;
                console.warn("推奨捕獲順の画像読み込みエラー(事前):", url);
                resolve(); // エラーでも進む
              };
              img.src = url;
            });
          });
          await Promise.all(loadImagePromises);
        }

        // 5. 最終出力Canvasのサイズ設定と描画
        const spaceBetweenTreeAndInfo = 25; // 家系図と情報エリアの間の空白
        const finalCanvasWidth = treeDrawingAreaWidth + calculatedInfoAreaWidth + spaceBetweenTreeAndInfo;
        const finalCanvasHeight = Math.max(treeDrawingAreaHeight, calculatedInfoAreaHeight);

        const finalOutputCanvas = document.createElement('canvas');
        finalOutputCanvas.width = finalCanvasWidth;
        finalOutputCanvas.height = finalCanvasHeight;
        const finalOutputCtx = finalOutputCanvas.getContext('2d');
        if (!finalOutputCtx) {
          alert("最終画像の生成に失敗しました。");
          return;
        }

        // 全体を背景色で塗りつぶし
        finalOutputCtx.fillStyle = desiredBackgroundColor;
        finalOutputCtx.fillRect(0, 0, finalCanvasWidth, finalCanvasHeight);

        // 5a. 家系図部分の描画 (オフスクリーンCanvas経由)
        const treeLayerCanvas = document.createElement('canvas');
        treeLayerCanvas.width = treeDrawingAreaWidth;
        treeLayerCanvas.height = treeDrawingAreaHeight;
        const treeLayerCtx = treeLayerCanvas.getContext('2d');
        if (!treeLayerCtx) return;

        // drawAllElementsOnContext は背景透明で描画するオプションが必要
        drawAllElementsOnContext(
          treeLayerCtx, treeLayerCanvas,
          { units, groups, connections, textItems, drawnPaths, drawnPathsInProgress: [], selectedItem: null, connectFromItem: null, itemsToGroup: [], isDrawing: false }, // 現在の描画対象アイテム
          { scale: 1, originX: -minX + treePadding, originY: -minY + treePadding, mode: null }, // 描画設定 (スケール1、原点調整)
          true // isTransparentBackground = true
        );
        finalOutputCtx.drawImage(treeLayerCanvas, 0, 0);

        // 5b. 情報エリアの描画
        const infoAreaStartX = treeDrawingAreaWidth + spaceBetweenTreeAndInfo;
        // 情報エリアの背景 (オプション)
        // finalOutputCtx.fillStyle = INFO_AREA_BACKGROUND_COLOR;
        // finalOutputCtx.fillRect(infoAreaStartX, 0, calculatedInfoAreaWidth, finalCanvasHeight);

        finalOutputCtx.textBaseline = 'top'; // テキスト描画の基準を上端に
        let currentInfoY = infoInternalPadding; // 情報描画開始Y座標

        infoAreaContent.forEach(line => {
          let currentLineHeight = infoLineHeight;
          finalOutputCtx.font = line.isBold ? `bold ${infoFontSize}px ${DEFAULT_FONT}` : `${infoFontSize}px ${DEFAULT_FONT}`;
          finalOutputCtx.fillStyle = line.color; // 各行に設定された色を使用

          const indentWidth = (line.indent || 0) * INFO_INDENT_SIZE;
          let drawX = infoAreaStartX + infoInternalPadding + indentWidth; // 情報エリア内のX開始位置

          if (line.type === 'header' || line.type === 'text') {
            finalOutputCtx.fillText(line.content, drawX, currentInfoY);
          } else if (line.type === 'bullet') {
            const bulletRadius = infoFontSize * 0.28;
            const bulletX = drawX; // インデント後のX座標
            const bulletY = currentInfoY + infoLineHeight / 2 - bulletRadius / 2; // テキストの上端に合わせる
            const textX = bulletX + bulletRadius * 2 + (infoImageTextGap / 2); // bulletとテキストの間隔

            finalOutputCtx.beginPath();
            finalOutputCtx.arc(bulletX + bulletRadius, bulletY + bulletRadius, bulletRadius, 0, Math.PI * 2);
            finalOutputCtx.fill(); // fillStyleはline.colorで設定済み

            finalOutputCtx.fillStyle = INFO_DEFAULT_TEXT_COLOR; // リストのテキストは通常黒
            finalOutputCtx.fillText(line.content.replace(/^[\u3040-\u309F\u30A0-\u30FF\uFF00-\uFFEF\w]+:\s*/, ''), textX, currentInfoY); // 先頭の作物名＋コロンを削除して描画
          } else if (line.type === 'imageText' && line.imageUrl && captureImagesToLoad[line.imageUrl]) {
            const imgInfo = captureImagesToLoad[line.imageUrl];
            if (imgInfo.loaded && imgInfo.img) {
              try {
                const imageDrawY = currentInfoY + (infoLineHeight - infoImageSize) / 2; // 垂直中央揃え
                finalOutputCtx.drawImage(imgInfo.img, drawX, imageDrawY, infoImageSize, infoImageSize);
                drawX += infoImageSize + infoImageTextGap; // 画像の分だけX座標を進める
              } catch (e) { console.error("情報エリアの画像描画エラー:", e, imgInfo.img.src); }
            } else if (imgInfo.error) { // 画像読み込みエラーの場合
              finalOutputCtx.fillStyle = INFO_ERROR_TEXT_COLOR;
              const errorTextY = currentInfoY + (infoLineHeight - infoFontSize) / 2; // 垂直中央揃え
              finalOutputCtx.fillText('×', drawX + infoImageSize / 4, errorTextY); // 画像の代わりにバツ印
              drawX += infoImageSize + infoImageTextGap;
            }
            finalOutputCtx.fillStyle = line.color; // テキストの色に戻す
            finalOutputCtx.fillText(line.content, drawX, currentInfoY);
            currentLineHeight = Math.max(infoLineHeight, infoImageSize); // 画像がある場合は行の高さを調整
          } else if (line.type === 'separator') {
            currentLineHeight = infoLineHeight / 2;
          }
          currentInfoY += currentLineHeight;
        });

        // 6. プレビューモーダルに表示
        try {
          const dataURL = finalOutputCanvas.toDataURL('image/png');
          saveImagePreview.src = dataURL;
          saveImagePreview.dataset.fullDataUrl = dataURL; // ダウンロード用に保持
          openModal(imagePreviewModal);
        } catch (e) {
          console.error("プレビュー用画像のDataURL生成中にエラー:", e);
          if (e.name === "SecurityError") {
            alert("画像の生成中にセキュリティエラーが発生しました。外部サイトの画像が家系図に含まれている場合、この問題が発生することがあります。");
          } else {
            alert("画像プレビューの生成中にエラーが発生しました。");
          }
        }
      });
      if (imagePreviewModalCloseButton) {
        imagePreviewModalCloseButton.addEventListener('click', () => {
          closeModal(imagePreviewModal);
          saveImagePreview.src = "#"; // 画像データをクリア
          saveImagePreview.removeAttribute('data-full-data-url');
        });
      }
      if (forceDownloadButton) {
        forceDownloadButton.addEventListener('click', () => {
          const dataURL = saveImagePreview.dataset.fullDataUrl;
          if (dataURL) {
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.-]/g, '').slice(0, -4);
            link.download = `DenpaTree_Preview_${timestamp}.png`;
            link.href = dataURL;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          } else {
            alert("ダウンロードする画像データが見つかりません。");
          }
        });
      }
      document.addEventListener('keydown', (e) => {
        if ((e.key === 'Delete' || e.key === 'Backspace') && selectedItem && !currentMode) {
          if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'SELECT' && document.activeElement.tagName !== 'TEXTAREA') {
            const displayName = getItemDisplayName(selectedItem);
            if (confirm(`「${truncateText(displayName, 15)}」を削除しますか？`)) {
              if (selectedItem.type === 'unit' || selectedItem.type === 'image-collection') { units = units.filter(unit => unit.id !== selectedItem.id); groups.forEach(g => g.itemIds = g.itemIds.filter(id => id !== selectedItem.id)); }
              else if (selectedItem.type === 'group') { const uIG = [...selectedItem.itemIds]; units = units.filter(u => !uIG.includes(u.id)); connections = connections.filter(c => !uIG.includes(c.fromId) && !uIG.includes(c.toId)); groups = groups.filter(g => g.id !== selectedItem.id); }
              else if (selectedItem.type === 'text') { textItems = textItems.filter(t => t.id !== selectedItem.id); }
              connections = connections.filter(conn => conn.fromId !== selectedItem.id && conn.toId !== selectedItem.id);
              if (connectFromItem && connectFromItem.id === selectedItem.id) connectFromItem = null;
              selectedItem = null; saveState(); drawCanvas(); updateInfoModal();
            }
          }
        }
      });
      zoomInButton.addEventListener('click', () => { zoomLevel++; updateZoom(); });
      zoomOutButton.addEventListener('click', () => { zoomLevel--; updateZoom(); });
      canvas.addEventListener('wheel', (event) => { event.preventDefault(); const d = event.deltaY > 0 ? -1 : 1; const oS = scale; zoomLevel += d; scale = Math.pow(1.2, zoomLevel); zoomLevelIndicator.textContent = zoomLevel; const r = canvas.getBoundingClientRect(); const mX = event.clientX - r.left, mY = event.clientY - r.top; const mCXB = (mX - originX) / oS, mCYB = (mY - originY) / oS; originX = mX - mCXB * scale; originY = mY - mCYB * scale; drawCanvas(); }, { passive: false });
      unitEditModalCloseButton.addEventListener('click', () => {
        closeModal(unitEditModal);
        editingUnit = null;
        editingGroup = null;
        editingTextItem = null;
        editingCollectionUnit = null;
        editingLine = null;
        currentEditingUnitContext = null;
      });
      unitEditCancelButton.addEventListener('click', () => {
        closeModal(unitEditModal);
        editingUnit = null;
        editingGroup = null;
        editingTextItem = null;
        editingCollectionUnit = null;
        editingLine = null;
        currentEditingUnitContext = null;
        if (currentMode === 'edit-item') toggleMode(null);
      });
      unitEditApplyButton.addEventListener('click', () => {
        if (editingUnit) {
          const borderCheckbox = document.getElementById('unit-edit-border-visible');
          if (borderCheckbox) {
            editingUnit.borderVisible = borderCheckbox.checked;
          }

          const monocolorCheckbox = document.getElementById('unit-edit-is-monocolor');
          if (monocolorCheckbox) {
            editingUnit.isMonocolor = monocolorCheckbox.checked;
          }

          const targetIndividualCheckbox = document.getElementById('unit-edit-is-target-individual');
          if (targetIndividualCheckbox) {
            const newTargetState = targetIndividualCheckbox.checked;
            if (!targetIndividualCheckbox.disabled) {
              if (newTargetState && editingUnit.isTargetIndividual !== true) {
                units.forEach(u => {
                  if (u.id !== editingUnit.id) {
                    u.isTargetIndividual = false;
                  }
                });
              }
              editingUnit.isTargetIndividual = newTargetState;
            }
          }

          document.querySelectorAll('#unit-edit-modal-body .unit-edit-slot-name').forEach(input => {
            const slotKey = input.dataset.slotKey;
            if (!editingUnit.slots[slotKey] && input.value.trim()) {
              editingUnit.slots[slotKey] = { name: input.value.trim(), food: '未選択', order: null, img: null, imgDataUrl: null, originalDataUrl: null, fileName: null };
            } else if (editingUnit.slots[slotKey]) {
              editingUnit.slots[slotKey].name = input.value.trim();
            } else if (!input.value.trim() && editingUnit.slots[slotKey]) {
              editingUnit.slots[slotKey].name = '';
            }
          });
          document.querySelectorAll('#unit-edit-modal-body .unit-edit-slot-food').forEach(select => {
            const slotKey = select.dataset.slotKey;
            const selectedFood = select.value;
            if (!editingUnit.slots[slotKey]) {
              if (selectedFood !== '未選択') {
                editingUnit.slots[slotKey] = { name: '', food: selectedFood, order: null, img: null, imgDataUrl: null, originalDataUrl: null, fileName: null };
              }
            } else {
              editingUnit.slots[slotKey].food = selectedFood;
            }
          });
          ['qr1', 'qr2'].forEach(sk => {
            if (editingUnit.slots[sk]) {
              const sakiChk = document.getElementById(`unit-edit-${sk}-order-先`);
              const atoChk = document.getElementById(`unit-edit-${sk}-order-後`);
              if (sakiChk && sakiChk.checked) {
                editingUnit.slots[sk].order = '先';
              } else if (atoChk && atoChk.checked) {
                editingUnit.slots[sk].order = '後';
              } else {
                editingUnit.slots[sk].order = null;
              }
            }
          });

          editingUnit.height = calculateUnitHeight(editingUnit.slots);
          editingUnit.activeSlotKeys = Object.keys(editingUnit.slots).filter(k => editingUnit.slots[k]?.img || editingUnit.slots[k]?.imgDataUrl);
          const imageCount = editingUnit.activeSlotKeys.length;
          if (imageCount === 1) editingUnit.width = UNIT_WIDTH_ONE_SLOT;
          else if (imageCount === 2) editingUnit.width = UNIT_WIDTH_TWO_SLOTS;
          else editingUnit.width = UNIT_WIDTH_THREE_SLOTS;

          saveState();
          drawCanvas();
          updateInfoModal();
          closeModal(unitEditModal);
          editingUnit = null;
          currentEditingUnitContext = null;
          if (currentMode === 'edit-item') toggleMode(null);

        } else if (editingLine) {
          const colorInput = document.getElementById('line-edit-color');
          const lineWidthInput = document.getElementById('line-edit-lineWidth');
          const lineDashSelect = document.getElementById('line-edit-dashType');

          if (colorInput) {
            editingLine.color = colorInput.value;
          }
          if (lineWidthInput) {
            const newWidth = parseInt(lineWidthInput.value, 10);
            if (!isNaN(newWidth) && newWidth >= 1 && newWidth <= 50) {
              editingLine.lineWidth = newWidth;
            } else {
              alert("線の太さの値が不正です。1から50の間で入力してください。");
              return;
            }
          }
          if (lineDashSelect) {
            try {
              editingLine.dashArray = JSON.parse(lineDashSelect.value);
            } catch (e) {
              console.error("線の種類の値のパースに失敗しました:", e);
              editingLine.dashArray = [];
            }
          }

          saveState();
          drawCanvas();
          closeModal(unitEditModal);
          editingLine = null;
          if (currentMode === 'edit-item') toggleMode(null);
        }
      });
      unitEditDuplicateButton.addEventListener('click', () => {
        if (editingUnit) {
          const newUnitData = JSON.parse(JSON.stringify({
            ...editingUnit,
            slots: Object.fromEntries(
              Object.entries(editingUnit.slots).map(([key, slot]) => [
                key,
                slot ? { ...slot, img: null } : null
              ])
            )
          }));

          newUnitData.id = `item-${nextItemId++}`;
          newUnitData.x += 30 / scale;
          newUnitData.y += 30 / scale;
          newUnitData.isSelected = false;

          const imageLoadPromises = Object.keys(newUnitData.slots).map(async slotKey => {
            const slot = newUnitData.slots[slotKey];
            if (slot && slot.imgDataUrl) {
              const img = new Image();
              img.src = slot.imgDataUrl;
              try {
                await img.decode();
                slot.img = img;
              } catch (e) {
                console.error(`複製時エラー: 画像 ${slot.fileName} の読み込みに失敗`, e);
                slot.img = null; // 読み込み失敗時はnull
              }
            }
          });

          Promise.all(imageLoadPromises).then(() => {
            newUnitData.activeSlotKeys = Object.keys(newUnitData.slots).filter(k => newUnitData.slots[k]?.img || newUnitData.slots[k]?.imgDataUrl);
            const imageCount = newUnitData.activeSlotKeys.length;
            if (imageCount === 1) newUnitData.width = UNIT_WIDTH_ONE_SLOT;
            else if (imageCount === 2) newUnitData.width = UNIT_WIDTH_TWO_SLOTS;
            else newUnitData.width = UNIT_WIDTH_THREE_SLOTS;
            newUnitData.height = calculateUnitHeight(newUnitData.slots);

            units.push(newUnitData);
            saveState();
            drawCanvas();
            closeModal(unitEditModal);
            editingUnit = null;
            currentEditingUnitContext = null;
            if (currentMode === 'edit-item') toggleMode(null);
            alert("ユニットを複製しました。");
          }).catch(err => {
            console.error("複製時の画像読み込みでエラーが発生しました:", err);
            alert("ユニットの複製中にエラーが発生しました。");
          });
        }
      });
      unitEditDeleteButton.addEventListener('click', () => {
        if (editingUnit) {
          if (confirm(`ユニット「${getItemDisplayName(editingUnit)}」を削除しますか？`)) {
            units = units.filter(u => u.id !== editingUnit.id);
            connections = connections.filter(c => c.fromId !== editingUnit.id && c.toId !== editingUnit.id);
            groups.forEach(g => g.itemIds = g.itemIds.filter(id => id !== editingUnit.id));
            if (selectedItem && selectedItem.id === editingUnit.id) selectedItem = null;

            saveState();
            drawCanvas();
            updateInfoModal();
            closeModal(unitEditModal);
            editingUnit = null;
            currentEditingUnitContext = null;
            if (currentMode === 'edit-item') toggleMode(null);
          }
        } else if (editingLine) {
          if (confirm(`選択されている接続線 (ID: ${truncateText(editingLine.id, 15)}) を削除しますか？`)) {
            connections = connections.filter(conn => conn.id !== editingLine.id);
            if (selectedItem && selectedItem.id === editingLine.id) selectedItem = null;

            saveState();
            drawCanvas();
            closeModal(unitEditModal);
            editingLine = null;
            if (currentMode === 'edit-item') toggleMode(null);
          }
        }
      });
      groupEditModalCloseButton.addEventListener('click', () => { closeModal(groupEditModal); editingGroup = null; });
      groupEditCancelButton.addEventListener('click', () => { closeModal(groupEditModal); editingGroup = null; if (currentMode === 'edit-item') toggleMode(null); });
      groupEditApplyButton.addEventListener('click', () => {
        if (editingGroup) {
          editingGroup.name = groupEditNameInput.value.trim();
          editingGroup.borderVisible = groupEditBorderVisibleCheckbox.checked;
          saveState();
          drawCanvas();
          closeModal(groupEditModal);
          editingGroup = null;
          if (currentMode === 'edit-item') toggleMode(null); // 編集モードを解除
        }
      });
      groupEditUngroupButton.addEventListener('click', () => {
        if (editingGroup && confirm(`グループ「${editingGroup.name || '選択グループ'}」のグループ化を解除しますか？ (中のユニットは残ります)`)) {
          connections = connections.filter(c => c.fromId !== editingGroup.id && c.toId !== editingGroup.id);
          groups = groups.filter(g => g.id !== editingGroup.id);
          if (selectedItem && selectedItem.id === editingGroup.id) selectedItem = null;
          saveState();
          drawCanvas();
          closeModal(groupEditModal);
          editingGroup = null;
          if (currentMode === 'edit-item') toggleMode(null);
        }
      });
      if (groupEditDuplicateButton) {
        groupEditDuplicateButton.addEventListener('click', async () => {
          if (editingGroup) {
            const newGroupData = JSON.parse(JSON.stringify({
              ...editingGroup,
              id: `item-${nextItemId++}`,
              name: editingGroup.name ? `${editingGroup.name}_コピー` : "コピーされたグループ",
              x: editingGroup.x + 30 / scale,
              y: editingGroup.y + 30 / scale,
              isSelected: false,
              itemIds: []
            }));

            const newUnitPromises = [];
            const oldToNewIdMap = {};

            // 2. グループ内の各ユニットを複製
            for (const oldUnitId of editingGroup.itemIds) {
              const originalUnit = findItemById(oldUnitId);
              if (originalUnit) {
                const newUnitCopy = JSON.parse(JSON.stringify({
                  ...originalUnit,
                  slots: Object.fromEntries(
                    Object.entries(originalUnit.slots || {}).map(([key, slot]) => [
                      key,
                      slot ? { ...slot, img: null } : null
                    ])
                  )
                }));

                const newUnitId = `item-${nextItemId++}`;
                oldToNewIdMap[oldUnitId] = newUnitId;
                newUnitCopy.id = newUnitId;
                newUnitCopy.x = newGroupData.x + (originalUnit.x - editingGroup.x);
                newUnitCopy.y = newGroupData.y + (originalUnit.y - editingGroup.y);
                newUnitCopy.isSelected = false;

                newGroupData.itemIds.push(newUnitId);
                const imageLoadPromises = Object.keys(newUnitCopy.slots || {}).map(async slotKey => {
                  const slot = newUnitCopy.slots[slotKey];
                  if (slot && slot.imgDataUrl) {
                    const img = new Image();
                    img.src = slot.imgDataUrl;
                    try {
                      await img.decode();
                      slot.img = img;
                    } catch (e) {
                      console.error(`複製時エラー(グループ内ユニット): 画像 ${slot.fileName} 読込失敗`, e);
                      slot.img = null;
                    }
                  }
                });
                newUnitPromises.push(Promise.all(imageLoadPromises).then(() => units.push(newUnitCopy)));
              }
            }

            await Promise.all(newUnitPromises);

            groups.push(newGroupData);
            saveState();
            drawCanvas();
            closeModal(groupEditModal);
            editingGroup = null;
            if (currentMode === 'edit-item') toggleMode(null);
            alert("グループを複製しました。");
          }
        });
      }
      groupEditDeleteButton.addEventListener('click', () => {
        if (editingGroup && confirm(`グループ「${editingGroup.name || '選択グループ'}」と、内部の全てのユニットを削除しますか？`)) {
          const unitIdsInGroup = [...editingGroup.itemIds];
          units = units.filter(u => !unitIdsInGroup.includes(u.id));
          connections = connections.filter(c =>
            c.fromId !== editingGroup.id && c.toId !== editingGroup.id &&
            !unitIdsInGroup.includes(c.fromId) && !unitIdsInGroup.includes(c.toId)
          );
          groups = groups.filter(g => g.id !== editingGroup.id);
          if (selectedItem && (selectedItem.id === editingGroup.id || unitIdsInGroup.includes(selectedItem.id))) {
            selectedItem = null;
          }
          saveState();
          drawCanvas();
          updateInfoModal();
          closeModal(groupEditModal);
          editingGroup = null;
          if (currentMode === 'edit-item') toggleMode(null);
        }
      });
      textEditModalCloseButton.addEventListener('click', () => { closeModal(textEditModal); editingTextItem = null; });
      textEditCancelButton.addEventListener('click', () => { closeModal(textEditModal); editingTextItem = null; if (currentMode === 'edit-item') toggleMode(null); });
      textEditApplyButton.addEventListener('click', () => {
        if (editingTextItem) {
          editingTextItem.text = document.getElementById('modal-text-content').value;
          editingTextItem.font = DEFAULT_FONT;
          editingTextItem.color = document.getElementById('modal-text-color').value;
          editingTextItem.backgroundColor = document.getElementById('modal-text-bgcolor').value;
          editingTextItem.fontSize = parseInt(document.getElementById('modal-text-size').value, 10);
          editingTextItem.borderVisible = document.getElementById('modal-text-border-visible').checked;
          editingTextItem.rotation = parseFloat(document.getElementById('modal-text-rotation').value) || 0;

          const textPaddingForCalc = TEXT_ITEM_PADDING;
          const measureForWidth = wrapTextAndMeasure(editingTextItem.text, Infinity, editingTextItem.fontSize, editingTextItem.font || DEFAULT_FONT, TEXT_LINE_HEIGHT_MULTIPLIER);
          editingTextItem.width = Math.max(MIN_TEXT_ITEM_WIDTH, measureForWidth.calculatedWidth + (textPaddingForCalc * 2));

          const finalMaxWidth = editingTextItem.width - (textPaddingForCalc * 2);
          let minHeight = Math.max(MIN_TEXT_ITEM_HEIGHT, editingTextItem.fontSize * TEXT_LINE_HEIGHT_MULTIPLIER + (textPaddingForCalc * 2));
          if (finalMaxWidth > 0) {
            const finalMeasured = wrapTextAndMeasure(editingTextItem.text, finalMaxWidth, editingTextItem.fontSize, editingTextItem.font || DEFAULT_FONT, TEXT_LINE_HEIGHT_MULTIPLIER);
            const newCalculatedHeight = finalMeasured.calculatedHeight + (textPaddingForCalc * 2);
            editingTextItem.height = Math.max(minHeight, newCalculatedHeight);
          } else {
            editingTextItem.height = minHeight;
          }

          saveState();
          drawCanvas();
          closeModal(textEditModal);
          editingTextItem = null;
          if (currentMode === 'edit-item') toggleMode(null);
        }
      });
      textEditDeleteButton.addEventListener('click', () => {
        if (editingTextItem && confirm(`テキスト「${truncateText(editingTextItem.text, 15)}」を削除しますか？`)) {
          textItems = textItems.filter(t => t.id !== editingTextItem.id);
          if (selectedItem && selectedItem.id === editingTextItem.id) selectedItem = null;
          saveState();
          drawCanvas();
          closeModal(textEditModal);
          editingTextItem = null;
          if (currentMode === 'edit-item') toggleMode(null);
        }
      });
      if (textEditDuplicateButton) { // ボタンが存在すればリスナーを設定
        textEditDuplicateButton.addEventListener('click', () => {
          if (editingTextItem) {
            const newTextItem = JSON.parse(JSON.stringify({
              ...editingTextItem,
              id: `item-${nextItemId++}`,
              x: editingTextItem.x + 20 / scale, // 少しずらす
              y: editingTextItem.y + 20 / scale,
              isSelected: false
            }));

            textItems.push(newTextItem);
            saveState();
            drawCanvas();
            closeModal(textEditModal);
            editingTextItem = null;
            if (currentMode === 'edit-item') toggleMode(null);
            alert("テキストを複製しました。");
          }
        });
      }
      showInfoModalButton.addEventListener('click', () => { updateInfoModal(); openModal(infoModal); });
      infoModalCloseButtonHeader.addEventListener('click', () => closeModal(infoModal));
      infoModalCloseButtonFooter.addEventListener('click', () => closeModal(infoModal));

      modalOverlay.addEventListener('click', (e) => {
        if (e.target === modalOverlay) {
          if (cropperModal.style.display === 'block' || cropperModal.style.display === 'flex') {
            if (currentEditingUnitContext === 'unit-edit-modal' || currentEditingUnitContext === 'collection-edit-modal') closeCropperModal(); else closeModal(cropperModal);
          } else if (unitEditModal.style.display === 'block' || unitEditModal.style.display === 'flex') {
            closeModal(unitEditModal);
            editingUnit = null;
            editingGroup = null;
            editingTextItem = null;
            editingCollectionUnit = null;
            editingLine = null;
            currentEditingUnitContext = null;
          } else if (groupEditModal.style.display === 'block' || groupEditModal.style.display === 'flex') {
            closeModal(groupEditModal); editingGroup = null;
          } else if (textEditModal.style.display === 'block' || textEditModal.style.display === 'flex') {
            closeModal(textEditModal); editingTextItem = null;
          } else if (infoModal.style.display === 'block' || infoModal.style.display === 'flex') {
            closeModal(infoModal);
          }
        }
      });

      collectionEditModalCloseButton.addEventListener('click', () => { closeModal(collectionEditModal); editingCollectionUnit = null; });
      collectionEditCancelButton.addEventListener('click', () => { closeModal(collectionEditModal); editingCollectionUnit = null; if (currentMode === 'edit-item') toggleMode(null); });
      collectionEditApplyButton.addEventListener('click', () => {
        if (!editingCollectionUnit) return;

        editingCollectionUnit.name = collectionEditNameInput.value.trim();
        editingCollectionUnit.borderVisible = collectionEditBorderCheckbox.checked;
        editingCollectionUnit.layoutSettings = {
          maxSize: parseInt(document.getElementById('collection-edit-max-size').value, 10) || COLLECTION_IMAGE_MAX_SIZE,
          margin: parseInt(document.getElementById('collection-edit-margin').value, 10) || COLLECTION_IMAGE_MARGIN,
          padding: parseInt(document.getElementById('collection-edit-padding').value, 10) || COLLECTION_PADDING,
          textGap: parseInt(document.getElementById('collection-edit-text-gap').value, 10) || minTextGapLogical,
          perRow: parseInt(document.getElementById('collection-edit-per-row').value, 10) || COLLECTION_IMAGES_PER_ROW,
          fontSize: parseInt(document.getElementById('collection-edit-font-size').value, 10) || textFontSizeLogical
        };
        editingCollectionUnit.layoutSettings.maxSize = Math.max(10, editingCollectionUnit.layoutSettings.maxSize);
        editingCollectionUnit.layoutSettings.margin = Math.max(0, editingCollectionUnit.layoutSettings.margin);
        editingCollectionUnit.layoutSettings.padding = Math.max(0, editingCollectionUnit.layoutSettings.padding);
        editingCollectionUnit.layoutSettings.textGap = Math.max(0, editingCollectionUnit.layoutSettings.textGap);
        editingCollectionUnit.layoutSettings.perRow = Math.max(1, editingCollectionUnit.layoutSettings.perRow);
        editingCollectionUnit.layoutSettings.fontSize = Math.max(6, editingCollectionUnit.layoutSettings.fontSize);


        const updatedImagesData = [];
        const listItems = collectionEditImageList.querySelectorAll('li');

        listItems.forEach(item => {
          if (item.dataset.deleted !== 'true') {
            const originalIndex = parseInt(item.dataset.originalIndex, 10);

            if (isNaN(originalIndex) || !editingCollectionUnit.images[originalIndex]) {
              console.warn("collectionEditApplyButton: データ不整合の可能性。originalIndex:", originalIndex, "アイテム:", item, "現在の画像配列の長さ:", editingCollectionUnit.images.length);
              return;
            }

            const imageDataFromMaster = editingCollectionUnit.images[originalIndex];

            const nameInput = item.querySelector('input[data-field="name"]');
            const foodSelect = item.querySelector('select[data-field="food"]');

            updatedImagesData.push({
              img: imageDataFromMaster.img,
              imgDataUrl: imageDataFromMaster.imgDataUrl,
              originalDataUrl: imageDataFromMaster.originalDataUrl,
              fileName: imageDataFromMaster.fileName,
              name: nameInput ? nameInput.value.trim() : imageDataFromMaster.name,
              food: foodSelect ? foodSelect.value : imageDataFromMaster.food
            });
          }
        });

        editingCollectionUnit.images = updatedImagesData;


        const { width: newWidth, height: newHeight } = calculateImageCollectionUnitSize(editingCollectionUnit.images, editingCollectionUnit.layoutSettings);
        editingCollectionUnit.width = newWidth;
        editingCollectionUnit.height = newHeight;

        // 変更を保存し、UIを更新
        saveState();
        drawCanvas();
        updateInfoModal();
        closeModal(collectionEditModal);
        editingCollectionUnit = null;
        if (currentMode === 'edit-item') toggleMode(null);
      });
      collectionEditDeleteButton.addEventListener('click', () => {
        if (editingCollectionUnit && confirm(`画像集合ユニット「${getItemDisplayName(editingCollectionUnit)}」を削除しますか？ (内部の画像も全て削除されます)`)) {
          units = units.filter(u => u.id !== editingCollectionUnit.id);
          connections = connections.filter(c => c.fromId !== editingCollectionUnit.id && c.toId !== editingCollectionUnit.id);
          groups.forEach(g => g.itemIds = g.itemIds.filter(id => id !== editingCollectionUnit.id));
          if (selectedItem && selectedItem.id === editingCollectionUnit.id) selectedItem = null;
          saveState(); drawCanvas(); updateInfoModal(); closeModal(collectionEditModal);
          editingCollectionUnit = null; if (currentMode === 'edit-item') toggleMode(null);
        }
      });
      if (resetLayoutButton) {
        resetLayoutButton.addEventListener('click', () => {
          if (!editingCollectionUnit) return;
          document.getElementById('collection-edit-max-size').value = COLLECTION_IMAGE_MAX_SIZE;
          document.getElementById('collection-edit-margin').value = COLLECTION_IMAGE_MARGIN;
          document.getElementById('collection-edit-padding').value = COLLECTION_PADDING;
          document.getElementById('collection-edit-text-gap').value = minTextGapLogical;
          document.getElementById('collection-edit-per-row').value = COLLECTION_IMAGES_PER_ROW;
          document.getElementById('collection-edit-font-size').value = textFontSizeLogical;
        });
      }
      clearImageCollectionButton.addEventListener('click', () => {
        imageCollectionUploadInput.value = ''; uploadedCollectionImages = [];
        imageCollectionPreviewsDiv.innerHTML = ''; imageCollectionDetailsDiv.innerHTML = '';
        if (clearImageCollectionButton) clearImageCollectionButton.classList.add('hidden');
        checkAddImageCollectionButtonState();
      });
      if (clearStorageButton) {
        clearStorageButton.addEventListener('click', () => {
          if (confirm("保存されている家系図データを全て削除し、完全に新規の状態から開始します。よろしいですか？")) {
            try {
              localStorage.removeItem('kakeizuToolState');
              console.log("ローカルストレージのデータを削除しました。");
            } catch (e) {
              console.error("ローカルストレージのデータ削除に失敗しました:", e);
            }
            // 状態を完全に初期化
            units = []; groups = []; textItems = []; connections = []; nextItemId = 0;
            selectedItem = null; connectFromItem = null; itemsToGroup = [];
            drawnPaths = [];
            currentDrawingPath = [];
            isDrawing = false;
            if (drawingToolsPanel) drawingToolsPanel.style.display = 'none';
            if (currentMode) toggleMode(null);
            history = []; historyIndex = -1;
            scale = 1.0; zoomLevel = 0; originX = 0; originY = 0;
            zoomLevelIndicator.textContent = zoomLevel;

            drawCanvas();
            updateInfoModal();
            updateUndoRedoButtons();
            alert("データがクリアされました。ページをリロードするか、このまま新規作成を開始してください。");
          }
        });
      }
      if (drawingColorPicker) {
        drawingColorPicker.addEventListener('input', (e) => { drawingColor = e.target.value; });
      }
      if (drawingLineWidthSlider) {
        drawingLineWidthSlider.addEventListener('input', (e) => {
          drawingLineWidth = parseInt(e.target.value, 10);
          if (drawingLineWidthValue) drawingLineWidthValue.textContent = drawingLineWidth;
        });
      }
      if (drawingShapeSelect) {
        drawingShapeSelect.addEventListener('change', (e) => {
          drawingShape = e.target.value;
          updateFillOptionVisibility();
        });
      }
      if (clearAllDrawingsButton) {
        clearAllDrawingsButton.addEventListener('click', () => {
          if (confirm("キャンバス上のすべての手書き描画を消去しますか？")) {
            drawnPaths = [];
            resetDrawingHistory();
            drawCanvas();
          }
        });
      }
      if (drawingUndoButton) {
        drawingUndoButton.addEventListener('click', undoDrawing);
      }
      if (drawingRedoButton) {
        drawingRedoButton.addEventListener('click', redoDrawing);
      }

      if (unifySizeButton) {
        unifySizeButton.addEventListener('click', () => {
          if (currentMode && currentMode.startsWith('unify-size')) {
            toggleMode(null);
            unifySizeModeSubState = null;
            unifySizeBaseUnit = null;
            unifySizeTargetUnits.forEach(u => u.isTargetSelectedForUnify = false);
            unifySizeTargetUnits = [];
            drawCanvas();
            const unifySizeCompleteSelectionBtn = document.getElementById('unify-size-complete-selection-btn');
            if (unifySizeCompleteSelectionBtn) unifySizeCompleteSelectionBtn.style.display = 'none';

          } else {
            toggleMode('unify-size-select-base', unifySizeButton);
          }
        });
      }

      const unifyAllUnitsBtn = document.getElementById('unify-all-units-btn');
      const unifyVisibleUnitsBtn = document.getElementById('unify-visible-units-btn');
      const unifySelectTargetsBtn = document.getElementById('unify-select-targets-btn');
      const unifySizeOptionsModalCancelBtn = document.getElementById('unify-size-options-modal-cancel-btn');
      const unifySizeCompleteSelectionBtn = document.getElementById('unify-size-complete-selection-btn');
      const unifyOptionsModal = document.getElementById('unify-size-options-modal'); // モーダル要素取得

      if (unifyAllUnitsBtn) {
        unifyAllUnitsBtn.addEventListener('click', () => {
          if (!unifySizeBaseUnit) return;
          closeModal(unifyOptionsModal);
          if (confirm(`家系図上の全ての同種ユニットを「${getItemDisplayName(unifySizeBaseUnit)}」のサイズに統一しますか？`)) {
            performUnifySize(unifySizeBaseUnit, 'all');
          }
          toggleMode(null);
        });
      }

      if (unifyVisibleUnitsBtn) {
        unifyVisibleUnitsBtn.addEventListener('click', () => {
          if (!unifySizeBaseUnit) return;
          closeModal(unifyOptionsModal);
          if (confirm(`現在画面に表示されている同種ユニットを「${getItemDisplayName(unifySizeBaseUnit)}」のサイズに統一しますか？`)) {
            performUnifySize(unifySizeBaseUnit, 'visible');
          }
          toggleMode(null);
        });
      }

      if (unifySelectTargetsBtn) {
        unifySelectTargetsBtn.addEventListener('click', () => {
          if (!unifySizeBaseUnit) return;
          closeModal(unifyOptionsModal);
          unifySizeTargetUnits = [];
          units.forEach(u => u.isTargetSelectedForUnify = false);
          textItems.forEach(t => t.isTargetSelectedForUnify = false);
          toggleMode('unify-size-select-targets', unifySizeButton);
        });
      }

      if (unifySizeOptionsModalCancelBtn) {
        unifySizeOptionsModalCancelBtn.addEventListener('click', () => {
          closeModal(unifyOptionsModal);
          toggleMode(null);
        });
      }

      if (unifySizeCompleteSelectionBtn) {
        unifySizeCompleteSelectionBtn.addEventListener('click', () => {
          if (currentMode === 'unify-size-select-targets' && unifySizeBaseUnit) {
            if (unifySizeTargetUnits.length > 0) {
              if (confirm(`${unifySizeTargetUnits.length}個の選択されたユニットを「${getItemDisplayName(unifySizeBaseUnit)}」のサイズに統一しますか？`)) {
                performUnifySize(unifySizeBaseUnit, 'selected', [...unifySizeTargetUnits]);
                toggleMode(null);
              } else {
                showStatusBar(modeMessages['unify-size-select-targets'], unifySizeButton);
              }
            } else {
              alert("サイズを統一する対象ユニットが選択されていません。");
            }
          }
        });
      }
      const exportDataButton = document.getElementById('export-data-button');
      if (exportDataButton) {
        exportDataButton.addEventListener('click', () => {
          if (history.length === 0 || historyIndex < 0) {
            alert("エクスポートするデータがありません。");
            return;
          }

          // 現在の最新の状態を取得 (undoされていない最新の状態)
          const currentState = history[historyIndex]; // undo/redoを考慮してhistoryIndexのものをエクスポート

          if (!currentState) {
            alert("現在の状態を取得できませんでした。");
            return;
          }

          const exportableState = JSON.parse(JSON.stringify(currentState, (key, value) => {
            return value;
          }));

          const jsonString = JSON.stringify(exportableState, null, 2); // null, 2 で整形されたJSON文字列に
          const blob = new Blob([jsonString], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          const timestamp = new Date().toISOString().replace(/[:.-]/g, '').slice(0, -4);
          link.download = `denpa_kakeizu_data_${timestamp}.json`;
          link.href = url;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
          showStatusBar('家系図データをエクスポートしました。', exportDataButton);
        });
      }
      const importDataButton = document.getElementById('import-data-button');
      const importFileInput = document.getElementById('import-file-input');
      if (alignButton) {
        alignButton.addEventListener('click', () => {
          if (currentMode === 'align-select-base') {
            toggleMode(null);
          } else if (currentMode === 'align-select-targets') {
            if (alignBaseUnit && alignTargetUnits.length > 0) {
              alignOptionsBaseUnitName.textContent = getItemDisplayName(alignBaseUnit);
              alignOptionsTargetCount.textContent = alignTargetUnits.length;
              openModal(alignOptionsModal);
            } else if (!alignBaseUnit) {
              alert("先に基準ユニットを選択してください。");
              toggleMode('align-select-base', alignButton);
            } else {
              alert("整列する対象ユニットを1つ以上選択してください。");
            }
          } else {
            toggleMode('align-select-base', alignButton);
          }
        });
      }

      if (importDataButton && importFileInput) {
        importDataButton.addEventListener('click', () => {
          if (currentMode) {
            alert(`現在のモード (${currentMode}) をキャンセルしてからインポートしてください。`);
            return;
          }
          if (confirm("JSONファイルからデータをインポートします。\n現在の作業内容は上書きされますが、よろしいですか？")) {
            importFileInput.click();
          }
        });

        importFileInput.addEventListener('change', async (event) => {
          const file = event.target.files[0];
          if (!file) {
            return;
          }

          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const jsonString = e.target.result;
              const importedState = JSON.parse(jsonString);

              if (typeof importedState !== 'object' || importedState === null ||
                (!importedState.units && !importedState.groups && !importedState.textItems && !importedState.connections)) {
                alert("無効なファイル形式か、家系図データが含まれていません。");
                return;
              }


              history = [];
              historyIndex = -1;

              drawnPaths = [];
              currentDrawingPath = [];
              isDrawing = false;
              if (drawingToolsPanel) drawingToolsPanel.style.display = 'none';

              await restoreState(importedState);
              history = [JSON.parse(JSON.stringify(importedState))];
              historyIndex = 0;


              updateUndoRedoButtons();
              updateInfoModal();
              // resizeCanvas(); // restoreStateの最後にdrawCanvasがあるので不要な場合も
              showStatusBar('家系図データをインポートしました。', importDataButton);

            } catch (error) {
              console.error("ファイルのインポート中にエラーが発生しました:", error);
              alert("ファイルのインポートに失敗しました。ファイル形式が正しいか確認してください。");
            } finally {
              importFileInput.value = '';
            }
          };
          reader.onerror = () => {
            console.error("ファイルの読み込み中にエラーが発生しました。");
            alert("ファイルの読み込みに失敗しました。");
            importFileInput.value = '';
          };
          reader.readAsText(file);
        });
      }
      if (alignHorizontalBtn) {
        alignHorizontalBtn.addEventListener('click', () => {
          performAlignment('horizontal');
          closeModal(alignOptionsModal);
        });
      }

      if (alignVerticalBtn) {
        alignVerticalBtn.addEventListener('click', () => {
          performAlignment('vertical');
          closeModal(alignOptionsModal);
        });
      }

      if (alignOptionsModalCancelBtn) {
        alignOptionsModalCancelBtn.addEventListener('click', () => {
          closeModal(alignOptionsModal);
        });
      }

      if (templateSelect) {
        templateSelect.addEventListener('change', () => {
          templateUploadedImages = [];
          templateImagePreviews.innerHTML = '';
          templateImageUpload.value = '';
          updateTemplateUI();
        });
      }

      if (templateImageUpload) {
        templateImageUpload.addEventListener('change', async (event) => {
          if (!selectedTemplate) return;
          const files = event.target.files;
          templateUploadedImages = [];
          templateImagePreviews.innerHTML = '';
          addFromTemplateButton.disabled = true;

          if (!files || files.length === 0) {
            updateTemplateUI();
            return;
          }

          const loadImage = async (file) => { /* ... (省略: imageCollectionUpload と同様の実装) ... */ };

          const loadedImagesPromises = [];
          for (let i = 0; i < files.length; i++) {
            if (templateUploadedImages.length >= selectedTemplate.maxImages && files.length > selectedTemplate.maxImages) {
              alert(`選択できる画像は最大 ${selectedTemplate.maxImages} 枚です。超過分は無視されます。`);
              break;
            }
            loadedImagesPromises.push(
              new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e_reader) => {
                  const imgDataUrl = e_reader.target.result;
                  const img = new Image();
                  img.onload = () => resolve({ img, imgDataUrl, fileName: files[i].name });
                  img.onerror = () => resolve(null);
                  img.src = imgDataUrl;
                };
                reader.onerror = () => resolve(null);
                reader.readAsDataURL(files[i]);
              })
            );
          }

          const results = await Promise.all(loadedImagesPromises);
          templateUploadedImages = results.filter(r => r !== null);

          templateImagePreviews.innerHTML = '';
          templateUploadedImages.forEach((imgData, index) => {
            const previewElement = document.createElement('img');
            previewElement.src = imgData.imgDataUrl;
            previewElement.title = imgData.fileName;
            previewElement.style.width = '40px';
            previewElement.style.height = '40px';
            previewElement.style.objectFit = 'contain';
            previewElement.style.border = '1px solid #ddd';
            templateImagePreviews.appendChild(previewElement);
          });

          updateTemplateUI();
        });
      }

      if (addFromTemplateButton) {
        addFromTemplateButton.addEventListener('click', () => {
          if (!selectedTemplate || !selectedTemplate.layout || templateUploadedImages.length !== selectedTemplate.maxImages) {
            alert("テンプレートと正しい枚数の画像を選択してください。");
            return;
          }

          const layout = selectedTemplate.layout;
          const newUnitsFromTemplate = [];
          const newConnectionsFromTemplate = [];
          const tempIdToNewIdMap = {}; // テンプレート内のtempIdと実際のユニットIDの対応表

          const canvasCenterX = (-originX + (mainCanvasArea.clientWidth / 2)) / scale;
          const canvasCenterY = (-originY + (mainCanvasArea.clientHeight / 2)) / scale;
          const gridSize = layout.gridSize || UNIT_WIDTH_ONE_SLOT * 1.5; // デフォルトのグリッドサイズ

          // 1. ユニットを生成
          layout.units.forEach(unitDef => {
            const newUnitId = `item-${nextItemId++}`;
            tempIdToNewIdMap[unitDef.tempId] = newUnitId;

            const unitSlotsData = {};
            const activeSlotKeysForUnit = [];
            let imageForThisUnitFound = false;

            for (const slotName in unitDef.slotMapping) {
              const imageIndex = unitDef.slotMapping[slotName];
              if (imageIndex >= 0 && imageIndex < templateUploadedImages.length) {
                const imgData = templateUploadedImages[imageIndex];
                unitSlotsData[slotName] = {
                  img: imgData.img,
                  imgDataUrl: imgData.imgDataUrl,
                  originalDataUrl: imgData.imgDataUrl,
                  fileName: imgData.fileName,
                  name: '',
                  food: '未選択',
                  order: null
                };
                activeSlotKeysForUnit.push(slotName);
                imageForThisUnitFound = true;
              } else {
                unitSlotsData[slotName] = null;
              }
            }

            if (!imageForThisUnitFound && Object.keys(unitDef.slotMapping).length > 0) {
              console.warn(`テンプレートユニット「${unitDef.tempId}」に割り当てる画像が見つかりませんでした。`);
              return;
            }


            let unitWidth = layout.defaultWidth || UNIT_WIDTH_ONE_SLOT;
            if (activeSlotKeysForUnit.length === 1) unitWidth = UNIT_WIDTH_ONE_SLOT;
            else if (activeSlotKeysForUnit.length === 2) unitWidth = UNIT_WIDTH_TWO_SLOTS;
            else if (activeSlotKeysForUnit.length >= 3) unitWidth = UNIT_WIDTH_THREE_SLOTS;

            const unitHeight = calculateUnitHeight(unitSlotsData) * (layout.defaultHeightMultiplier || 1);

            newUnitsFromTemplate.push({
              id: newUnitId,
              type: layout.unitType || 'unit',
              slots: unitSlotsData,
              x: canvasCenterX + (unitDef.xOffset * gridSize) - (unitWidth / 2),
              y: canvasCenterY + (unitDef.yOffset * gridSize) - (unitHeight / 2),
              width: unitWidth,
              height: unitHeight,
              isSelected: false,
              borderVisible: true,
              activeSlotKeys: activeSlotKeysForUnit,
              isMonocolor: false,
              isTargetIndividual: false
            });
          });

          // 2. 接続線を生成
          layout.connections.forEach(connDef => {
            const fromUnitId = tempIdToNewIdMap[connDef.from];
            const toUnitId = tempIdToNewIdMap[connDef.to];
            if (fromUnitId && toUnitId) {
              newConnectionsFromTemplate.push({
                id: `conn-${nextItemId++}`,
                fromId: fromUnitId,
                toId: toUnitId,
                color: '#555555', // デフォルト色
                lineWidth: 10,    // デフォルト太さ
                dashArray: []     // デフォルト実線
              });
            }
          });

          // 3. 生成されたユニットと接続線をグローバル配列に追加
          if (newUnitsFromTemplate.length > 0) {
            units.push(...newUnitsFromTemplate);
          }
          if (newConnectionsFromTemplate.length > 0) {
            connections.push(...newConnectionsFromTemplate);
          }

          // 4. 状態を保存し、キャンバスを再描画
          if (newUnitsFromTemplate.length > 0 || newConnectionsFromTemplate.length > 0) {
            saveState();
            drawCanvas();
            updateInfoModal();
            showStatusBar(`「${selectedTemplate.name}」テンプレートをキャンバスに追加しました。`, addFromTemplateButton);
          } else {
            alert("テンプレートからユニットを生成できませんでした。画像選択やテンプレート定義を確認してください。");
          }

          // 処理後はリセット
          templateSelect.value = "";
          selectedTemplate = null;
          templateUploadedImages = [];
          templateImagePreviews.innerHTML = '';
          templateImageUpload.value = '';
          updateTemplateUI();
        });
      }


      // ========================================
      // 6. 初期化処理呼び出し
      // ========================================
      checkAddUnitButtonState();
      checkAddTextButtonState();
      checkAddImageCollectionButtonState();
      historyIndex = -1;

      async function initializeApp() {
        console.log("アプリケーション初期化開始");
        let restored = false;
        try {
          const savedStateString = localStorage.getItem('kakeizuToolState');
          if (savedStateString) {
            console.log("ローカルストレージから状態を復元します...");
            const savedState = JSON.parse(savedStateString);
            await restoreState(savedState);
            if (savedState.scale !== undefined) scale = savedState.scale;
            if (savedState.originX !== undefined) originX = savedState.originX;
            if (savedState.originY !== undefined) originY = savedState.originY;
            if (savedState.zoomLevel !== undefined) zoomLevel = savedState.zoomLevel;
            zoomLevelIndicator.textContent = zoomLevel;

            history = [savedState];
            historyIndex = 0;

            console.log("状態の復元が完了しました。");
            restored = true;
          } else {
            console.log("保存された状態は見つかりませんでした。新規作成します。");
            history = [];
            historyIndex = -1;
          }
        } catch (e) {
          console.error("ローカルストレージからの状態復元に失敗しました:", e);
          history = [];
          historyIndex = -1;
        }

        updateUndoRedoButtons();

        requestAnimationFrame(() => {
          console.log(restored ? "復元後の初回描画" : "新規作成時の初回描画");
          resizeCanvas();
          updateInfoModal();
          updateFillOptionVisibility();
          resetDrawingHistory();
        });
      }
      initializeTemplateSelector();
      updateTemplateUI();
      initializeApp();
      adjustLayoutHeight();
      window.addEventListener('resize', adjustLayoutHeight);
      window.addEventListener('orientationchange', adjustLayoutHeight);
      let scrollTimeout;
      window.addEventListener('scroll', () => {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(adjustLayoutHeight, 150);
      }, { passive: true });
      console.log("最終的なボタン初期表示設定 開始");
      if (leftPanel.classList.contains('collapsed')) {
        leftPanelToggleButton.innerHTML = '＞';
        leftPanelToggleButton.title = "左パネルを展開";
        leftPanelToggleButton.style.left = '0px';
        leftPanelToggleButton.classList.add('panel-is-closed');
        leftPanelToggleButton.classList.remove('panel-is-open');
        console.log("最終初期状態: パネルは収納");
      } else {
        leftPanelToggleButton.innerHTML = '＜';
        leftPanelToggleButton.title = "左パネルを収納";
        leftPanelToggleButton.style.left = `${leftPanel.offsetWidth}px`;
        leftPanelToggleButton.classList.add('panel-is-open');
        leftPanelToggleButton.classList.remove('panel-is-closed');
        console.log("最終初期状態: パネルは展開、ボタンleft:", leftPanelToggleButton.style.left, "パネル幅:", leftPanel.offsetWidth);
      }

    }); // DOMContentLoaded の終わり
  </script>
</body>

</html>
